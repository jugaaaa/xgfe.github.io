<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xgfe</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xgfe.github.io/"/>
  <updated>2018-04-12T12:51:48.000Z</updated>
  <id>http://xgfe.github.io/</id>
  
  <author>
    <name>xgfe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>routable-ios 源码解析</title>
    <link href="http://xgfe.github.io/2018/04/07/chenyu/routable-ios_sourceAnalysis/"/>
    <id>http://xgfe.github.io/2018/04/07/chenyu/routable-ios_sourceAnalysis/</id>
    <published>2018-04-07T05:12:00.000Z</published>
    <updated>2018-04-12T12:51:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析 <a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="external">routable-ios</a> 源码，通过本文可以了解路由的原理及使用。本文分为六个部分，从代码结构到具体的类依次介绍，文章最后会给出在项目中注册路由常用的方式。</p>
<a id="more"></a>
<h2 id="一、routable-ios-是什么？可以用来做什么？与之类似的框架还有哪些？"><a href="#一、routable-ios-是什么？可以用来做什么？与之类似的框架还有哪些？" class="headerlink" title="一、routable-ios 是什么？可以用来做什么？与之类似的框架还有哪些？"></a>一、routable-ios 是什么？可以用来做什么？与之类似的框架还有哪些？</h2><ul>
<li>routable-ios 是一个路由框架，由两个文件四个类组成，其中核心的类就一个。</li>
<li>可以很方便的实现 iOS 中<code>UIViewController</code>之间的跳转。跳转方式也可以灵活的设置，后面具体会讲到。</li>
<li>类似的框架还有 <a href="https://github.com/aaronbrethorst/ABRouter" target="_blank" rel="external">ABRouter</a> &amp; <a href="https://github.com/lightory/HHRouter" target="_blank" rel="external">HHRouter</a>。后期的文章也会对 HHRouter 做介绍。</li>
</ul>
<h2 id="二、routable-ios-中类的关系"><a href="#二、routable-ios-中类的关系" class="headerlink" title="二、routable-ios 中类的关系"></a>二、routable-ios 中类的关系</h2><p>&nbsp;&nbsp;了解类与类之间的关系，有助于理解整个框架。<code>Routable</code>继承自<code>UPRouter</code>，主要的功能都在<code>UPRouter</code>类中，路由主要的功能其实就两个：</p>
<ul>
<li>注册希望路由跳转的类及<code>URL</code></li>
<li>进行跳转</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/142772-7f18a54a0a327233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="routable-ios 类组织结构.png"></p>
<h2 id="三、routable-ios-如何使用"><a href="#三、routable-ios-如何使用" class="headerlink" title="三、routable-ios 如何使用"></a>三、routable-ios 如何使用</h2><ul>
<li>将<code>routable-ios</code>导入项目</li>
<li><p>注册路由：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[Routable sharedRouter] map:@&quot;user/:name/:age&quot; toController:[UserController class]];</div></pre></td></tr></table></figure>
</li>
<li><p>调用路由进行跳转：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[Routable sharedRouter] open:@&quot;user/chenyu/28&quot;];</div></pre></td></tr></table></figure>
</li>
<li><p>在 VC 中获取传递的参数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@implementation UserController</div><div class="line"></div><div class="line">- (id)initWithRouterParams:(NSDictionary *)params &#123;</div><div class="line">  if ((self = [self initWithNibName:nil bundle:nil])) &#123;</div><div class="line">    self.title = @&quot;User&quot;;</div><div class="line">      NSLog(@&quot;name: %@&quot;,[params objectForKey:@&quot;name&quot;]); //chenyu</div><div class="line">      NSLog(@&quot;age: %@&quot;,[params objectForKey:@&quot;age&quot;]);   //28</div><div class="line">  &#125;</div><div class="line">  return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、routable-ios-中的核心类"><a href="#四、routable-ios-中的核心类" class="headerlink" title="四、routable-ios 中的核心类"></a>四、routable-ios 中的核心类</h2><p>&nbsp;&nbsp;核心类分别有：<code>Routable</code>，<code>UPRouterOptions</code>，<code>RouterParams</code>，<code>UPRouter</code></p>
<h3 id="1-Routable"><a href="#1-Routable" class="headerlink" title="1.Routable"></a>1.<code>Routable</code></h3><p>&nbsp;&nbsp;<code>Routable</code>继承自<code>UPRouter</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedRouter; //提供单例方法，用来创建路由类</div><div class="line">+ (instancetype)newRouter;     //另一种创建路由的方式，一般不推荐，不是单例。</div></pre></td></tr></table></figure>
<h3 id="2-UPRouterOptions"><a href="#2-UPRouterOptions" class="headerlink" title="2.UPRouterOptions"></a>2.<code>UPRouterOptions</code></h3><p>&nbsp;&nbsp;<code>UPRouterOptions</code>继承自<code>NSObject</code>。首先看一下这个类提供的一些属性，我们就知道这个类是做什么的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic, getter=isModal) BOOL modal;  //是否是模态视图</div><div class="line">@property (readwrite, nonatomic) UIModalPresentationStyle presentationStyle;  //VC 显示的样式</div><div class="line">@property (readwrite, nonatomic) UIModalTransitionStyle transitionStyle;  //VC 出现时的动画</div><div class="line">@property (readwrite, nonatomic, strong) NSDictionary *defaultParams;  //默认的数据</div><div class="line">@property (readwrite, nonatomic, assign) BOOL shouldOpenAsRootViewController; //是否是根视图</div><div class="line"></div><div class="line">//.m 文件中的两个属性</div><div class="line">@property (readwrite, nonatomic, strong) Class openClass;  //注册的类</div><div class="line">@property (readwrite, nonatomic, copy) RouterOpenCallback callback;  //block 回调</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;通过以上内容，可以看到<code>UPRouterOptions</code>其实就是一个配置类，里面存储路由跳转时需要的一些数据，可以理解成一个辅助的类。这个类中提供了一系列的工厂方法，用来创建不同类型的对象，比如（只列举部分函数，其他同类型的函数还有很多，功能大体一致，只是某个配置项不同而已。）：</p>
<ul>
<li><p>全部使用默认配置</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Default construction; like [NSArray array]</div><div class="line">+ (instancetype)routerOptions &#123;</div><div class="line">  return [self routerOptionsWithPresentationStyle:UIModalPresentationNone</div><div class="line">                                  transitionStyle:UIModalTransitionStyleCoverVertical</div><div class="line">                                    defaultParams:nil</div><div class="line">                                           isRoot:NO</div><div class="line">                                          isModal:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>传入所有参数创建对象</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//Explicit construction</div><div class="line">+ (instancetype)routerOptionsWithPresentationStyle: (UIModalPresentationStyle)presentationStyle</div><div class="line">                                   transitionStyle: (UIModalTransitionStyle)transitionStyle</div><div class="line">                                     defaultParams: (NSDictionary *)defaultParams</div><div class="line">                                            isRoot: (BOOL)isRoot</div><div class="line">                                           isModal: (BOOL)isModal &#123;</div><div class="line">  UPRouterOptions *options = [[UPRouterOptions alloc] init];</div><div class="line">  options.presentationStyle = presentationStyle;</div><div class="line">  options.transitionStyle = transitionStyle;</div><div class="line">  options.defaultParams = defaultParams;</div><div class="line">  options.shouldOpenAsRootViewController = isRoot;</div><div class="line">  options.modal = isModal;</div><div class="line">  return options;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自定义部分参数创建对象</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Custom class constructors, with heavier Objective-C accent</div><div class="line">+ (instancetype)routerOptionsAsModal &#123;</div><div class="line">  return [self routerOptionsWithPresentationStyle:UIModalPresentationNone</div><div class="line">                                  transitionStyle:UIModalTransitionStyleCoverVertical</div><div class="line">                                    defaultParams:nil</div><div class="line">                                           isRoot:NO</div><div class="line">                                          isModal:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>剩余的基本就是一些快捷的方法及一些<code>setters</code>方法，可以查看源码。</p>
</li>
</ul>
<h3 id="3-RouterParams"><a href="#3-RouterParams" class="headerlink" title="3.RouterParams"></a>3.<code>RouterParams</code></h3><p>&nbsp;&nbsp;<code>RouterParams</code>继承自<code>NSObject</code>。<code>RouterParams</code>并没有在.h 文件中做声明，这个类只在<code>Routable</code>和<code>UPRouter</code>中的实现中才用到，而这三个类都在一个文件中，所以也没有必要出现在 .h 文件中。<br>首先看一下<code>RouterParams</code>的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface RouterParams : NSObject</div><div class="line"></div><div class="line">@property (readwrite, nonatomic, strong) UPRouterOptions *routerOptions;</div><div class="line">@property (readwrite, nonatomic, strong) NSDictionary *openParams; </div><div class="line">@property (readwrite, nonatomic, strong) NSDictionary *extraParams;</div><div class="line">@property (readwrite, nonatomic, strong) NSDictionary *controllerParams;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;这个类的出现，主要作用是将跳转时匹配好的所有内容存起来，缓存到另一个字典中，未来再次跳转的时候，直接可以拿出来用，你也许会问，我们的路由不是在一个字典里吗，也可以直接拿出来用，为什么还要缓存，后续到源代码的地方会细说，为什么要缓存，为什么跳转的时候不是直接去 map 中寻找。</p>
<h3 id="4-UPRouter"><a href="#4-UPRouter" class="headerlink" title="4.UPRouter"></a>4.<code>UPRouter</code></h3><p>&nbsp;&nbsp;<code>UPRouter</code>继承自<code>NSObject</code>，首先看一下类的声明，删除了很多注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface UPRouter : NSObject</div><div class="line"></div><div class="line">/**</div><div class="line"> The UINavigationController instance which mapped UIViewControllers will be pushed onto.</div><div class="line"> */</div><div class="line">@property (readwrite, nonatomic, strong) UINavigationController *navigationController;</div><div class="line"></div><div class="line">- (void)pop;</div><div class="line">- (void)popViewControllerFromRouterAnimated:(BOOL)animated;</div><div class="line">- (void)pop:(BOOL)animated;</div><div class="line"></div><div class="line">@property (readwrite, nonatomic, assign) BOOL ignoresExceptions;</div><div class="line"></div><div class="line">- (void)map:(NSString *)format toCallback:(RouterOpenCallback)callback;</div><div class="line">- (void)map:(NSString *)format toCallback:(RouterOpenCallback)callback withOptions:(UPRouterOptions *)options;</div><div class="line">- (void)map:(NSString *)format toController:(Class)controllerClass;</div><div class="line">//注册路由，本篇主要分析的方法。上面的方法最终会调用这个方法，options 传入的是 nil</div><div class="line">- (void)map:(NSString *)format toController:(Class)controllerClass withOptions:(UPRouterOptions *)options;</div><div class="line"></div><div class="line"></div><div class="line">- (void)openExternal:(NSString *)url;</div><div class="line">- (void)open:(NSString *)url;</div><div class="line">- (void)open:(NSString *)url animated:(BOOL)animated;</div><div class="line">//路由跳转，本篇主要分析的方法。上面两个方法最终都会调用这个方法。</div><div class="line">- (void)open:(NSString *)url animated:(BOOL)animated extraParams:(NSDictionary *)extraParams;</div><div class="line"></div><div class="line">- (NSDictionary*)paramsOfUrl:(NSString*)url;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface UPRouter ()</div><div class="line"></div><div class="line">// 存储注册的路由</div><div class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *routes;</div><div class="line">// 缓存已跳转过的路由</div><div class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *cachedRoutes;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;注册路由比较简单，就是将传入的<code>URL</code>作为 key，将<code>Class</code>作为值存入已初始化的<code>routes</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)map:(NSString *)format toController:(Class)controllerClass &#123;</div><div class="line">  [self map:format toController:controllerClass withOptions:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)map:(NSString *)format toController:(Class)controllerClass withOptions:(UPRouterOptions *)options &#123;</div><div class="line">  if (!format) &#123;</div><div class="line">    @throw [NSException exceptionWithName:@&quot;RouteNotProvided&quot;</div><div class="line">                                   reason:@&quot;Route #format is not initialized&quot;</div><div class="line">                                 userInfo:nil];</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  //如果没有传入 options，则会创建一个默认的配置对象</div><div class="line">  if (!options) &#123;</div><div class="line">    options = [UPRouterOptions routerOptions];</div><div class="line">  &#125;</div><div class="line">  options.openClass = controllerClass;</div><div class="line">  [self.routes setObject:options forKey:format];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;路由跳转一共有三个比较重要的方法，首先看<code>open:animated:extraParams:</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- (void)open:(NSString *)url</div><div class="line">    animated:(BOOL)animated</div><div class="line"> extraParams:(NSDictionary *)extraParams</div><div class="line">&#123;</div><div class="line">  //获取路由跳转相关的参数，往下滑动，先看怎么获取的数据，看完下面的方法再回来看这个方法</div><div class="line">  RouterParams *params = [self routerParamsForUrl:url extraParams: extraParams];</div><div class="line">  UPRouterOptions *options = params.routerOptions;</div><div class="line">  </div><div class="line">  //好了，拿到数据了，开始跳转。先判断是否有回调，如果有的话，则去执行 block</div><div class="line">  if (options.callback) &#123;</div><div class="line">    RouterOpenCallback callback = options.callback;</div><div class="line">    callback([params controllerParams]);</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  //此处删除了判断 self.navigationController 是否存在的容错代码，无关紧要。</div><div class="line">  </div><div class="line">  //获取将要跳转的 VC，并且将我们传递的数据以字典的形式，传递给这个 VC</div><div class="line">  //controllerForRouterParams 这个方法比较简单，打断点进去看看就 OK 了。</div><div class="line">  UIViewController *controller = [self controllerForRouterParams:params];</div><div class="line">  </div><div class="line">  //判断当前是否有 presented 的 UIViewController，有的话要 dismiss，因为接下来要跳转或者 presentViewController</div><div class="line">  if (self.navigationController.presentedViewController) &#123;</div><div class="line">    [self.navigationController dismissViewControllerAnimated:animated completion:nil];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //是否是以模态的方式弹出 UIViewController</div><div class="line">  if ([options isModal]) &#123;</div><div class="line">    if ([controller.class isSubclassOfClass:UINavigationController.class]) &#123;</div><div class="line">      [self.navigationController presentViewController:controller</div><div class="line">                                              animated:animated</div><div class="line">                                            completion:nil];</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">      UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:controller];</div><div class="line">      navigationController.modalPresentationStyle = controller.modalPresentationStyle;</div><div class="line">      navigationController.modalTransitionStyle = controller.modalTransitionStyle;</div><div class="line">      [self.navigationController presentViewController:navigationController</div><div class="line">                                              animated:animated</div><div class="line">                                            completion:nil];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  else if (options.shouldOpenAsRootViewController) &#123;</div><div class="line">    //设置根视图</div><div class="line">    [self.navigationController setViewControllers:@[controller] animated:animated];</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    //直接 push 一个 UIViewController</div><div class="line">    [self.navigationController pushViewController:controller animated:animated];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;获取路由跳转相关的参数方法（删除了一些容错处理的代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (RouterParams *)routerParamsForUrl:(NSString *)url extraParams: (NSDictionary *)extraParams &#123;</div><div class="line">  //如果缓存中已经有了（证明之前已经跳转过这个 VC），并且传递的参数没有变化。</div><div class="line">  //这里需要注意了，如果传递的参数你也不确定是不是没变化，最好给 extraParams 给个值，这样就不会走缓存了</div><div class="line">  //否则可能传递的数据变了，但是走的还是之前的缓存。</div><div class="line">  //如果 VC 之间不要传递数据，不用考虑这个问题</div><div class="line">  if ([self.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) &#123;</div><div class="line">    return [self.cachedRoutes objectForKey:url];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  NSArray *givenParts = url.pathComponents;</div><div class="line">  NSArray *legacyParts = [url componentsSeparatedByString:@&quot;/&quot;];</div><div class="line">  //这里判断传入的路由路径是否正确，如果传入这样的 &quot;iOS/app//first&quot; 路径，则会警告。</div><div class="line">  //也许你的路由路径是&quot;iOS/app&quot;，这样写你就少传了一个实参</div><div class="line">  if ([legacyParts count] != [givenParts count]) &#123;</div><div class="line">    NSLog(@&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;, url);</div><div class="line">    givenParts = legacyParts;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //使用枚举的方式去匹配，这里不能从 self.routes 中通过 [self.routes objectForKey:@&quot;key&quot;] 的方式获取，</div><div class="line">  //因为注册的时候，你后面添加的是参数（形参），在跳转的时候传递的是数据（实参）。</div><div class="line">  //这里也就是为什么需要缓存的原因了，每次跳转都要枚举这个字典，缓存了以后时间复杂度直接降到了 O(1)。</div><div class="line">  __block RouterParams *openParams = nil;</div><div class="line">  [self.routes enumerateKeysAndObjectsUsingBlock:</div><div class="line">   ^(NSString *routerUrl, UPRouterOptions *routerOptions, BOOL *stop) &#123;</div><div class="line">     //routerUrl 是枚举到的 key，也是当时注册路由时添加进去的 url，routerOptions 是枚举到的 value</div><div class="line"></div><div class="line">     NSArray *routerParts = [routerUrl pathComponents];</div><div class="line">     //判断注册的路由地址和跳转的带参数的地址是否一致，最简单的办法就是判断他们包含的元素个数是否一致，如果一致，再做更详细的判断</div><div class="line">     if ([routerParts count] == [givenParts count]) &#123;</div><div class="line">       //如果个数一致，再判断是否匹配</div><div class="line">       NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];</div><div class="line">       if (givenParams) &#123;</div><div class="line">         //givenParams 存储的是路由地址中给的数据，再将 extraParams 一起传入 RouterParams，创建 RouterParams 的对象。</div><div class="line">         openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];</div><div class="line">         *stop = YES;//结束遍历</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;];</div><div class="line">  </div><div class="line">  //如果没有匹配到路由</div><div class="line">  if (!openParams) &#123;</div><div class="line">    //用户设置了忽略异常，直接返回 nil，否则会走 @throw</div><div class="line">    if (_ignoresExceptions) &#123;</div><div class="line">      return nil;</div><div class="line">    &#125;</div><div class="line">    @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot;</div><div class="line">                                   reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url]</div><div class="line">                                 userInfo:nil];</div><div class="line">  &#125;</div><div class="line">  //将我们辛辛苦苦封装好的路由相关的所有数据缓存起来，下次在走这个 url 的时候，直接取缓存中的数据，这就是为什么要缓存了。</div><div class="line">  //除非你传递的参数变了，那么一定传给 extraParams，相关方法检测到 extraParams 不为空，会重新组装数据。</div><div class="line">  [self.cachedRoutes setObject:openParams forKey:url];</div><div class="line">  return openParams;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">//判断注册的路由和跳转的路由是否一致</div><div class="line">- (NSDictionary *)paramsForUrlComponents:(NSArray *)givenUrlComponents</div><div class="line">                     routerUrlComponents:(NSArray *)routerUrlComponents &#123;</div><div class="line">  </div><div class="line">  __block NSMutableDictionary *params = [NSMutableDictionary dictionary];</div><div class="line">  [routerUrlComponents enumerateObjectsUsingBlock:</div><div class="line">   ^(NSString *routerComponent, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">     </div><div class="line">     NSString *givenComponent = givenUrlComponents[idx];</div><div class="line">     //判断是否是形参，所以在注册路由时，一定要注意，参数以:开始，否则会当成路径字符串</div><div class="line">     if ([routerComponent hasPrefix:@&quot;:&quot;]) &#123;</div><div class="line">       //去除参数的:，然后将参数名作为 key，将对应的 givenComponent 作为值存入字典中，所以在调用路由的时候，传递参数（实参）顺序要一致，否则参数就错乱了</div><div class="line">       NSString *key = [routerComponent substringFromIndex:1];</div><div class="line">       [params setObject:givenComponent forKey:key];</div><div class="line">     &#125;</div><div class="line">     else if (![routerComponent isEqualToString:givenComponent]) &#123;</div><div class="line">       //在非传参数的情况下，如果路径不一致，则结束。结束后会去路由表中拿下一个路由来判断。</div><div class="line">       params = nil;</div><div class="line">       *stop = YES;</div><div class="line">     &#125;</div><div class="line">   &#125;];</div><div class="line">  return params;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;将路由跳转最重要的三个方法分析了一下，在重要的代码前都加上了注释。接下来总结一下整体的思路。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>&nbsp;&nbsp;注册的时候，比较简单，将我们的路径和 VC 传递进去，保存在字典中就可以了。跳转的时候，做的判断就比较多。首先判断缓存中是否有这个路径，如果有的话，直接跳转，在注释中也详细说明了为什么要缓存。如果没有的话，则去枚举这个路由字典，并组装数据，存入缓存中。</p>
<p>&nbsp;&nbsp;任何框架，都会有不完美的地方，没错，这里要说说了。如果需要给你跳转的 VC 传递数据，那么需要你的 VC 实现这个方法：<code>initWithRouterParams:params</code>，通过<code>params</code>去获取你的值。其实在这里也可以通过获取这个 VC 的所有属性，在创建这个 VC 的时候，通过 KVC 的方式把值赋给这个 VC 的属性。</p>
<p>&nbsp;&nbsp;另一种实现办法是扩展<code>UIViewController</code>，在这里可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface UIViewController (Routable)</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSDictionary *params;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@implementation UIViewController (Routable)</div><div class="line"></div><div class="line">static char kAssociatedParamsObjectKey;</div><div class="line"></div><div class="line">- (void)setParams:(NSDictionary *)params&#123;</div><div class="line">    objc_setAssociatedObject(self, &amp;kAssociatedParamsObjectKey, params, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSDictionary *)params</div><div class="line">&#123;</div><div class="line">    return objc_getAssociatedObject(self, &amp;kAssociatedParamsObjectKey);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;这样每个<code>UIViewController</code>中就不用实现固定的方法了，在使用的时候，直接调用<code>self.params</code>就可以拿到这个字典了。</p>
<h2 id="六、建议"><a href="#六、建议" class="headerlink" title="六、建议"></a>六、建议</h2><p>&nbsp;&nbsp;在<code>routable-ios</code>中给出的注册路由的方式是，一个 VC 一个 VC 的注册。可以将需要路由跳转的 VC 配置到 plist 文件中，写一个方法，读取 plist 文件，循环注册即可，在<code>application:didFinishLaunchingWithOptions:</code>方法中，调用注册路由的方法即可。</p>
<p>&nbsp;&nbsp;我 fork 了一份代码，并在里面添加了注释，想通过 Xcode 看的，可以下载下来看。 <a href="https://github.com/chenyu1520/routable-ios" target="_blank" rel="external">传送门</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分析 &lt;a href=&quot;https://github.com/clayallsopp/routable-ios&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;routable-ios&lt;/a&gt; 源码，通过本文可以了解路由的原理及使用。本文分为六个部分，从代码结构到具体的类依次介绍，文章最后会给出在项目中注册路由常用的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="chenyu" scheme="http://xgfe.github.io/categories/chenyu/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="http://xgfe.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="路由" scheme="http://xgfe.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>iOS源码解读-对象关联实现分析</title>
    <link href="http://xgfe.github.io/2018/03/24/lixiaoqiang/ios%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xgfe.github.io/2018/03/24/lixiaoqiang/ios中对象关联的底层实现/</id>
    <published>2018-03-24T12:31:49.000Z</published>
    <updated>2018-04-04T09:05:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析iOS对象关联的实现。<br><a id="more"></a></p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在iOS开发中，经常为了将代码解耦或者在原有的类的基础上扩展功能，经常会使用类目(Catogery)。但是大家都知道分类添加的属性Xcode不会自动的为其生成一个下划线开头的成员变量及set和get方法，如果你没有手动实现这两个方法，直接在外面通过点语法调用这个属性，肯定就挂了，会报“unrecognized selector sent to instance”的错误。假设我们在类目.h中放置一个属性（但是并不声明set方法和get方法），我们在类目中.m中尝试添加自定义set方法和get方法，我们发现已经可以像正常类一样调用这个类目的属性，这里就说明了@property已经帮我们申明了set和get方法，只是并没有实现。这样我们自己实现了set和get方法，但是没有成员变量来存放我们set的值，这样get的时候也就无法取到set的值，这样肯定是不行的。那我们猜想一下苹果会怎么设计这个set的值存储的方式。</p>
<h3 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h3><p>在没有看到苹果的实现之前，我想的是将set的值存放在一个单例下的变量中，这样在get的时候去取这个单例中被set的变量。但是这会产生一个问题，那就是如果我们在一个工程中创建了很多类目，事实上，在开发的过程中类目文件很多也是很正常的。那么我们可能需要创建单例来保存这些类目下的属性，也许会用一个全局的单例，或者是每个类目创建一个单例来存储。这是我的想法，那我们看看苹果的做法究竟是什么。</p>
<h3 id="苹果的做法"><a href="#苹果的做法" class="headerlink" title="苹果的做法"></a>苹果的做法</h3><p>通过查阅资料，我们看到给category的做法是利用了“_object_set_associative_reference(id object, void *key, id value, uintptr_t policy)”这个方法，这个方法是将要添加的属性和类目扩展的对象关联起来，方法的第一个参数Object是需要关联的对象，key是一个常量，value是需要添加的属性。<br>policy对应的是枚举表示关联引用的存储策略。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></div><div class="line">                                            *   The association is not made atomically. */</div><div class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></div><div class="line">                                            *   The association is made atomically. */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接下来我们来看这个“_object_set_associative_reference”的方法的具体实现，虽然是c++的代码，我们只要认真的沉下心来分析，还是能分析出苹果这个方法的实现思路。方法所做的事情我在代码中用中文注释出来。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</div><div class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></div><div class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>); <span class="comment">//构造了一个表示旧值的对象</span></div><div class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;<span class="comment">//根据传进来的值和策略产生一个新值</span></div><div class="line">    &#123;</div><div class="line">        AssociationsManager manager;<span class="comment">//这是管理关联的单例</span></div><div class="line">        AssociationsHashMap &amp;associations(manager.associations());<span class="comment">//这个单例里面有一个hashmap</span></div><div class="line">        disguised_ptr_t disguised_object = DISGUISE(object);<span class="comment">//DISGUISE是一个将对象指针转变的宏，这里暂且将disguised_object看做是传进来的对象经过转换产生的一个新对象</span></div><div class="line">        <span class="keyword">if</span> (new_value) &#123;<span class="comment">//如果这个传进来的值存在</span></div><div class="line">            <span class="comment">// break any existing association.</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);<span class="comment">//遍历单例中hashmap根据disguised_object 去找AssociationsHashMap类型的hashmap。由此可见，associations中存储着以disguised_object为key的多个hashmap</span></div><div class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;<span class="comment">//表示找到了以传进来的以disguised_object为key的hashmap，下面就是在找到的hashmap中找以传进来的key为key的键值对.</span></div><div class="line">                <span class="comment">// secondary table exists</span></div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;<span class="comment">//找到了跟传进来的key相同的键值对，将原来的键值得值赋值给刚开始初始化的old_association，然后将新值赋值给原来的键值对。</span></div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没有找到相同的key，则直接关联到遍历得到的hashmap上</span></div><div class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果找不到以disguised_object为key的hashmap，则创建新的hashmap给大的associations</span></div><div class="line">                <span class="comment">// create the new association (first time).</span></div><div class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</div><div class="line">                associations[disguised_object] = refs;</div><div class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</div><div class="line">                object-&gt;setHasAssociatedObjects();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果新值不存在，则会根据传进来的key抹去原来的在hashmap中的以key对应的键值对</span></div><div class="line">            <span class="comment">// setting the association to nil breaks the association.</span></div><div class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</div><div class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</div><div class="line">                ObjectAssociationMap *refs = i-&gt;second;</div><div class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</div><div class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</div><div class="line">                    old_association = j-&gt;second;</div><div class="line">                    refs-&gt;erase(j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// release the old value (outside of the lock).</span></div><div class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association)<span class="comment">//根据其原本绑定的策略，对删掉的值做一些善后处理</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过源码分析我们知道了苹果是怎么关联的属性的底层的实现，那么要取出来存进去的属性那就简单了，就是根据key和object对象进行遍历，我们看看objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)的底层实现:  </p>
<pre><code class="objc"><span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key) {
    <span class="keyword">id</span> value = <span class="literal">nil</span>;
    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);
        AssociationsHashMap::iterator i = associations.find(disguised_object);
        <span class="keyword">if</span> (i != associations.end()) {
            ObjectAssociationMap *refs = i-&gt;second;
            ObjectAssociationMap::iterator j = refs-&gt;find(key);
            <span class="keyword">if</span> (j != refs-&gt;end()) {
                ObjcAssociation &amp;entry = j-&gt;second;
                value = entry.value();
                policy = entry.policy();
                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) {
                    objc_retain(value);
                }
            }
        }
    }
    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {
        objc_autorelease(value);
    }
    <span class="keyword">return</span> value;
}
</code></pre>
<p>果不其然，苹果也是按照我们的猜想去做的这件事。  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据我们的猜想然后去分析苹果的源码，发现苹果为分类的属性建造了一个大的hashmap，这个大的hashmap的里面又根据对象划分了多个子hashmap，划分的依照object来划分。每个子hashmap中存放了各个分类添加的属性。注意：每个分类的属性使用对象关联去关联属性的时候千万要保证key值得唯一性，否则会出现后面的存储覆盖掉前面的存储的情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分析iOS对象关联的实现。&lt;br&gt;
    
    </summary>
    
      <category term="lixiaoqiang" scheme="http://xgfe.github.io/categories/lixiaoqiang/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="Catogery" scheme="http://xgfe.github.io/tags/Catogery/"/>
    
  </entry>
  
  <entry>
    <title>Android Zxing 扫码封装</title>
    <link href="http://xgfe.github.io/2018/03/20/Catherine/AndroidZxing%E6%89%AB%E7%A0%81%E5%B0%81%E8%A3%85/"/>
    <id>http://xgfe.github.io/2018/03/20/Catherine/AndroidZxing扫码封装/</id>
    <published>2018-03-20T02:49:30.000Z</published>
    <updated>2018-03-27T13:51:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Zxing 是一个开放源码的，用 Java 实现的多种格式的 1D/2D 条码图像处理库，它包含了联系到其他语言的端口。Zxing 可以实现使用手机的内置的摄像头完成条形码的扫描及解码。</p>
<a id="more"></a>
<h2 id="一、条码码型"><a href="#一、条码码型" class="headerlink" title="一、条码码型"></a>一、条码码型</h2><p>Zxing 目前支持扫描和解析以下码型：</p>
<table>
<thead>
<tr>
<th>码型</th>
<th>中文名</th>
<th>维度</th>
<th>字符类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>AZTEC</td>
<td>阿兹特克码</td>
<td>2D</td>
<td>ASCII</td>
</tr>
<tr>
<td>CODABAR</td>
<td>库德巴码</td>
<td>1D</td>
<td>数字、字母</td>
</tr>
<tr>
<td>CODE_39</td>
<td>39码</td>
<td>1D</td>
<td>(0-9)10个数字、“ABCD”四个字母和“$-:/.+”六个特殊字符</td>
</tr>
<tr>
<td>CODE_93</td>
<td>93码</td>
<td>1D</td>
<td>(0-9)10个数字、“ABCD”四个字母和“$-:/.+”六个特殊字符</td>
</tr>
<tr>
<td>CODE_128</td>
<td>128码</td>
<td>1D</td>
<td>ASCII</td>
</tr>
<tr>
<td>DATA_MATRIX</td>
<td>Matrix 25码</td>
<td>2D</td>
<td>任意字符</td>
</tr>
<tr>
<td>EAN_8</td>
<td>EAN商品码</td>
<td>1D</td>
<td>数字</td>
</tr>
<tr>
<td>EAN_13</td>
<td>EAN商品码</td>
<td>1D</td>
<td>数字</td>
</tr>
<tr>
<td>ITF</td>
<td>交插25码</td>
<td>1D</td>
<td>数字</td>
</tr>
<tr>
<td>MAXICODE</td>
<td>UPC快递码</td>
<td>2D</td>
<td>ASCII</td>
</tr>
<tr>
<td>PDF_417</td>
<td>PDF417</td>
<td>2D</td>
<td>扩展的字母数字压缩格式、二进制 、ASCII、数字压缩格式</td>
</tr>
<tr>
<td>QR_CODE</td>
<td>二维条码</td>
<td>2D</td>
<td>任意字符</td>
</tr>
<tr>
<td>RSS_14</td>
<td>RSS码</td>
<td>1D+2D</td>
<td>数字</td>
</tr>
<tr>
<td>RSS_EXPANDED</td>
<td>RSS码</td>
<td>1D+2D</td>
<td>数字</td>
</tr>
<tr>
<td>UPC_A</td>
<td>UPC美国码</td>
<td>1D</td>
<td>数字</td>
</tr>
<tr>
<td>UPC_E</td>
<td>UPC美国码</td>
<td>1D</td>
<td>数字</td>
</tr>
<tr>
<td>UPC_EAN_EXTENSION</td>
<td>EAN/UPC混合码</td>
<td>1D</td>
<td>数字</td>
</tr>
</tbody>
</table>
<p>在 <code>build.gradle</code> 中引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">implementation &quot;com.google.zxing:core:$&#123;zxingCoreVer&#125;&quot;</div><div class="line">implementation &quot;com.google.zxing:android-core:$&#123;zxingAndroidVer&#125;&quot;</div><div class="line">implementation &quot;com.google.zxing:android-integration:$&#123;zxingAndroidVer&#125;&quot;</div></pre></td></tr></table></figure>
<p>引入依赖后即可使用 Zxing 的解码库，对条形码或二维码进行解析，但是需要封装扫码界面、取图流程和解析后的数据返回，才能方便 Android 应用中使用。为此，我们封装了整个扫码和解析的组件库，使得 Android 应用中仅需关注布局的构建。</p>
<h2 id="二、CaptureActivity-界面部分封装"><a href="#二、CaptureActivity-界面部分封装" class="headerlink" title="二、CaptureActivity 界面部分封装"></a>二、CaptureActivity 界面部分封装</h2><p><code>CaptureActivity</code> 是一个抽象类，继承于 <code>AppCompatActivity</code> ，这个Activity不包含界面，所以其子类需要在 <code>onCreate()</code> 中设置布局。</p>
<p><code>CaptureActivity</code> 中有多个抽象方法：</p>
<ul>
<li>boolean getResult(Result, byte[]) : 每次扫码结束后会调用此方法，实现类可以从参数中获取扫码结果；</li>
<li>SurfaceView getScanPreview() : 子类 Activity 需要自定义布局，可实现此方法，返回自定义布局中的 <code>SurfaceView</code> 对象；</li>
<li>View getCropView() : 返回子类自定义布局中的扫码框 View，用于裁剪取图图片。</li>
</ul>
<p><code>CaptureActivity</code> 中封装了扫码的流程，包括：</p>
<ol>
<li>摄像头预览：通过 <code>SurfaceView</code> 和 <code>Camera</code> 的初始化，在界面中显示摄像头的预览画面；</li>
<li>自动取图：通过定时获取 <code>SurfaceView</code> 预览图片的方式，得到预览图的二进制数据，然后裁剪出扫码框中部分；</li>
<li>解析：通过 Zxing Core 解析图片的二进制数据，获取解析结果；</li>
<li>封装解析结果：结果包含一个字符串、一个图片二进制数组、条码位置数组，封装为 <code>Result</code> 对象；</li>
<li>界面接收结果：通过抽象方法 <code>boolean getResult(Result, byte[])</code> ，将结果返回给子类 Activity 。</li>
</ol>
<p>另外，此抽象类中还封装了扫码界面中常用闪光灯开关方法，并且封装了适配 Android 6.0 的动态权限申请。</p>
<h3 id="2-1-摄像头预览"><a href="#2-1-摄像头预览" class="headerlink" title="2.1 摄像头预览"></a>2.1 摄像头预览</h3><p>为了在界面中显示摄像头预览画面，需要子类 Activity 提供布局中的 <code>SurfaceView</code> 对象，即可在 Activity 生命周期中处理其初始化和销毁：</p>
<ul>
<li>完成 <code>SurfaceView</code> 的初始化后，打开 <code>Camera</code> 获取摄像头数据显示预览画面；</li>
<li>在 Activity 暂停时，停止预览，释放 <code>Camera</code> 资源；</li>
<li>在 Activity 重新显示时，重新初始化。</li>
</ul>
<h3 id="2-2-自动取图"><a href="#2-2-自动取图" class="headerlink" title="2.2 自动取图"></a>2.2 自动取图</h3><p>取图，即获取 <code>SurfaceView</code> 预览画面的一帧图片。为 <code>SurfaceView</code> 设置取图回调，即可在请求取图后，获取到此刻一帧图像的二进制数据。</p>
<p>自动取图的实现方式有很多种：</p>
<ol>
<li>自动对焦方式，启动摄像头的自动对焦功能，在每次对焦成功的回调中执行取图。这种取图方式依赖自动对焦，在极端情况下可能无法对焦，或者对焦时间较长，造成扫码速度降低。</li>
<li>定时取图方式，需要开启定时任务，每隔一定时间请求取图方法。这种取图方法的取图间隔是固定的，可以提高取图速度，但是在解析速度较慢的手机上可能出现解析未完成而再次取图的情况，造成混乱。</li>
<li>线性取图方式，即完成“取图——解析——取图”的线性操作，取图和解析都是由我们自己的代码请求的，这样可以完全控制整个操作流程，避免了定时取图的弊端；因为不需要在完成对焦后再取图，我们可以通过控制延迟时间控制取图速度。</li>
</ol>
<p>建议使用线性取图方式，以完全控制取图速度和取图过程，也可以在子类 Activity 获取到结果后，自由控制继续取图或暂停取图。</p>
<h3 id="2-3-解析图片"><a href="#2-3-解析图片" class="headerlink" title="2.3 解析图片"></a>2.3 解析图片</h3><p>解析取图数据的过程由 zxing:core 库完成。</p>
<p>具体解析原理代码较多，此处不详述，代码在 <code>com.google.zxing.MultiFormatReader</code> 中。</p>
<h3 id="2-4-结果封装"><a href="#2-4-结果封装" class="headerlink" title="2.4 结果封装"></a>2.4 结果封装</h3><p><code>com.google.zxing.Result</code> 类中定义了扫码结果。</p>
<ul>
<li>String text: 即上一步解析出来的字符串；</li>
<li>byte[] rawBytes: 图片的二进制数据；</li>
<li>ResultPoint[] resultPoints: 一个或多个关键点，可以用于在界面中标出条码位置；</li>
<li>BarcodeFormat format: 条码的码型；</li>
<li>long timestamp: 时间戳。</li>
</ul>
<p>以上数据，可以帮助我们获取扫码结果和展示友好的界面。</p>
<h2 id="三、预览和摄像头"><a href="#三、预览和摄像头" class="headerlink" title="三、预览和摄像头"></a>三、预览和摄像头</h2><p>我们将摄像头预览相关的操作，封装在 <code>camera</code> 包中，关键类有：</p>
<ul>
<li>CameraManager：控制摄像头的开启和关闭；</li>
<li>CameraConfigurationManager：设置摄像头和预览的参数；</li>
<li>AutoFocusManager：控制摄像头的自动对焦。</li>
</ul>
<h2 id="四、图片解析"><a href="#四、图片解析" class="headerlink" title="四、图片解析"></a>四、图片解析</h2><p>我们将图片解析相关的操作，封装在 <code>decode</code> 包中，关键类有：</p>
<ul>
<li>DecodeHandler: 从摄像头获取的原始二进制数据是 YUV 格式，我们在此类中将其转换为 <code>Bitmap</code> ，然后发送到 zxing:core 库解析；</li>
<li>DecodeThread: 解析图片是耗时操作，所以需要在非 UI 线程中进行。</li>
</ul>
<p>在 <code>DecodeThread</code> 类中，我们定义了多种码型组合，例如所有条形码、条形码与二维码、CODE128与二维码等，以满足不同业务场景。在 <code>CaptureActivity</code> 中定义了方法 <code>int getBarcodeMode()</code>，可以在子类中重写，即可定义应用需要的码型。</p>
<blockquote>
<p>注意：支持的码型数量越多，解析速度越慢；二维码的解析速度大大慢于一维码的解析速度。</p>
</blockquote>
<h2 id="五、App-中实现扫码界面"><a href="#五、App-中实现扫码界面" class="headerlink" title="五、App 中实现扫码界面"></a>五、App 中实现扫码界面</h2><p>在依赖以上组件库后，即可快速实现扫码功能，在 App 开发中仅需自定义界面即可。</p>
<p>我们首先继承 <code>CaptureActivity</code> ，创建 <code>MyScanActivity</code> 和布局文件 <code>activity_my_scan.xml</code></p>
<p>MyScanActivity.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScanActivity</span> <span class="keyword">extends</span> <span class="title">CaptureActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> SurfaceView mPreviewSv;</div><div class="line">    <span class="keyword">private</span> View mCropView;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_my_scan);</div><div class="line">        mPreviewSv = findViewById(R.id.scan_preview);</div><div class="line">        mCropView = findViewById(R.id.scan_crop);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取扫码结果</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> result 扫码结果</div><div class="line">     * <span class="doctag">@param</span> bytes  图片二进制数组</div><div class="line">     * <span class="doctag">@return</span> true - 继续扫描；false - 暂停扫描</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">getResult</span><span class="params">(Result result, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> || TextUtils.isEmpty(result.getText()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> SurfaceView <span class="title">getScanPreview</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mPreviewSv;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">getCropView</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mCropView;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>activity_my_scan.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">SurfaceView</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/scan_preview"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">View</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/scan_crop"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></div><div class="line">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></div><div class="line">        <span class="attr">android:background</span>=<span class="string">"#33ffffff"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>以上仅仅是实现扫码界面的最简单代码，如果需要更好的界面效果，还需要修改布局和获取结果后的逻辑。</p>
</blockquote>
<p>至此，我们就快速实现了扫码页面的功能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zxing 是一个开放源码的，用 Java 实现的多种格式的 1D/2D 条码图像处理库，它包含了联系到其他语言的端口。Zxing 可以实现使用手机的内置的摄像头完成条形码的扫描及解码。&lt;/p&gt;
    
    </summary>
    
      <category term="Catherine" scheme="http://xgfe.github.io/categories/Catherine/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="Zxing" scheme="http://xgfe.github.io/tags/Zxing/"/>
    
  </entry>
  
  <entry>
    <title>实现一个React 组件</title>
    <link href="http://xgfe.github.io/2018/03/04/zhouyinian/React-component/"/>
    <id>http://xgfe.github.io/2018/03/04/zhouyinian/React-component/</id>
    <published>2018-03-04T06:00:00.000Z</published>
    <updated>2018-03-20T03:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了如何在React中编写组件。<br><a id="more"></a></p>
<h3 id="项目的搭建"><a href="#项目的搭建" class="headerlink" title="项目的搭建"></a>项目的搭建</h3><p>为了加快演示，用react-create-app快速搭建项目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create-react-app react-learn-component</div><div class="line">cd react-learn-component</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run start</div></pre></td></tr></table></figure>
<p>浏览器会自动打开如下页面</p>
<p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp01hatymlj20y60hg75l.jpg"></p>
<p>更多关于react-create-app介绍：<a href="//github.com/facebook/create-react-app">传送门</a></p>
<h3 id="组件的介绍"><a href="#组件的介绍" class="headerlink" title="组件的介绍"></a>组件的介绍</h3><blockquote>
<p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p>
</blockquote>
<p>组件可以让你把UI切分成独立的、可复用的块去单独的考虑和开发。</p>
<h3 id="React中组件的分类"><a href="#React中组件的分类" class="headerlink" title="React中组件的分类"></a>React中组件的分类</h3><h4 id="展示型组件（presentational）"><a href="#展示型组件（presentational）" class="headerlink" title="展示型组件（presentational）"></a>展示型组件（presentational）</h4><p>展示型组件是用来展示样式的，他们对应用的其余部分没有依赖性，会通过props明确地接收数据，可以写成函数的形式。如下的BlogList组件只是接收一个<code>bolglist</code>数组，便能展示博客列表，相同的输入会有相同的输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import React from &quot;react&quot;;</div><div class="line">export const BlogList = bloglist =&gt; (  </div><div class="line">    &lt;ul&gt;</div><div class="line">        &#123;</div><div class="line">            bloglist.map((&#123; body,author,id &#125;) =&gt;      </div><div class="line">                &lt;li key=&#123;id&#125;&gt;&#123;body&#125;-&#123;author&#125;&lt;/li&gt; </div><div class="line">            )</div><div class="line">        &#125;     </div><div class="line">    &lt;/ul&gt;</div><div class="line">)</div></pre></td></tr></table></figure>
<h4 id="容器型组件-container"><a href="#容器型组件-container" class="headerlink" title="容器型组件(container)"></a>容器型组件(container)</h4><p>容器型组件关心组件如何工作，可以为展示组件或其他容器组件提供数据，通常是有状态的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import React,&#123;Component&#125; from &quot;react&quot;;</div><div class="line">import &#123;BlogList&#125; from &apos;../BlogList/BlogList&apos;</div><div class="line">class Blog extends Component &#123;</div><div class="line">    constructor(props)&#123;</div><div class="line">        super(props)</div><div class="line">        this.state = &#123;</div><div class="line">            blogList:[]</div><div class="line">        &#125;</div><div class="line">        this.showBlodList = this.showBlodList.bind(this)</div><div class="line">    &#125;</div><div class="line">    componentDidMount()&#123;</div><div class="line">        const blogList = [</div><div class="line">            &#123;</div><div class="line">                id:1,</div><div class="line">                author:&apos;zyn&apos;,</div><div class="line">                body:&apos;这是blog内容111&apos;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                id:2,</div><div class="line">                author:&apos;zyn&apos;,</div><div class="line">                body:&apos;这是blog内容222&apos;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">        this.setState(&#123;</div><div class="line">            blogList</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">    showBlodList()&#123;</div><div class="line">        console.log(this.state.blogList)</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        const &#123;blogList&#125; = this.state</div><div class="line">        return(</div><div class="line">            &lt;div&gt;</div><div class="line">                &#123;BlogList(blogList)&#125;</div><div class="line">                &lt;button type=&quot;button&quot; onClick=&#123;this.showBlodList&#125;&gt;点击我&lt;/button&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export default Blog</div></pre></td></tr></table></figure>
<p>显示效果如图</p>
<p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp020d7trzj21vi0okdl3.jpg"></p>
<h3 id="编写一个复选框组件"><a href="#编写一个复选框组件" class="headerlink" title="编写一个复选框组件"></a>编写一个复选框组件</h3><p>最近用了AngularJS 和 Vue, 在写表单的时候基于双向数据绑定，写起来是相当的happy，当然React的单向数据流也有着自己的优点。基于此我们可以对项目中常用的表单控件进行组件的封装，下面以复选框为例。</p>
<h4 id="第一步，创建文件"><a href="#第一步，创建文件" class="headerlink" title="第一步，创建文件"></a>第一步，创建文件</h4><p>首先我们在 components 文件夹下面创建Checkbox文件夹以及Checkbox.js 文件,先写一个无状态组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// CheckBox.js</div><div class="line"></div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">class CheckBox extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; /&gt;点击我&lt;/label&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export default CheckBox</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// App.js</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import logo from &apos;./logo.svg&apos;;</div><div class="line">import &apos;./App.css&apos;;</div><div class="line">import Blog from &apos;./components/Blog/Blog&apos;</div><div class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</div><div class="line">class App extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;App&quot;&gt;</div><div class="line">        &lt;header className=&quot;App-header&quot;&gt;</div><div class="line">          &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</div><div class="line">          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</div><div class="line">        &lt;/header&gt;</div><div class="line">        &lt;p className=&quot;App-intro&quot;&gt;</div><div class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</div><div class="line">        &lt;/p&gt;</div><div class="line">        &lt;Blog/&gt;</div><div class="line">        &lt;CheckBox/&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default App;</div></pre></td></tr></table></figure>
<p>如图，会出现一个<code>点击我</code>的复选框</p>
<p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp02g9zniej21aq0pedi9.jpg"></p>
<h4 id="第二步，实现label的可配置"><a href="#第二步，实现label的可配置" class="headerlink" title="第二步，实现label的可配置"></a>第二步，实现label的可配置</h4><p>我们会发现复选框的 <code>label</code> 的文字 <code>点击我</code> 是写死的，那么怎么让 <code>label</code> 的动态传入呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//Checkbox.js</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">class CheckBox extends Component &#123;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;label&gt;</div><div class="line">                &lt;input type=&quot;checkbox&quot; /&gt;</div><div class="line"></div><div class="line">                //这里由‘点击我’换成了如下代码</div><div class="line">                &#123;this.props.children !== undefined ? this.props.children : null&#125;</div><div class="line">            &lt;/label&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export default CheckBox</div></pre></td></tr></table></figure>
<p>这里要注意<code>this.props.children</code> 表示当前组件的所有子节点。<code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//App.js</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import logo from &apos;./logo.svg&apos;;</div><div class="line">import &apos;./App.css&apos;;</div><div class="line">import Blog from &apos;./components/Blog/Blog&apos;</div><div class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</div><div class="line">class App extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;App&quot;&gt;</div><div class="line">        &lt;header className=&quot;App-header&quot;&gt;</div><div class="line">          &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</div><div class="line">          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</div><div class="line">        &lt;/header&gt;</div><div class="line">        &lt;p className=&quot;App-intro&quot;&gt;</div><div class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</div><div class="line">        &lt;/p&gt;</div><div class="line">        &lt;Blog/&gt;</div><div class="line">        &lt;CheckBox&gt;按钮1&lt;/CheckBox&gt;</div><div class="line">        &lt;CheckBox&gt;按钮2&lt;/CheckBox&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default App;</div></pre></td></tr></table></figure>
<p>查看浏览器，可以看到按钮的label已经变成可以配置的了。</p>
<p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp02tjojipj21ai0mo0vb.jpg"></p>
<h4 id="第三步，实现可控组件及获值"><a href="#第三步，实现可控组件及获值" class="headerlink" title="第三步，实现可控组件及获值"></a>第三步，实现可控组件及获值</h4><p>现在的复选框的选中状态是由自身去控制的，也就是说现在还无法去动态控制复选框的选中状态。同时，在业务需求中，如果有多个复选框，我们希望可以获得选中的复选框的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// Checkbox.js</div><div class="line"></div><div class="line">import React from &quot;react&quot;;</div><div class="line">class CheckBox extends React.Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props)</div><div class="line">        this.checkCheckBox = this.checkCheckBox.bind(this);</div><div class="line">        this.state = &#123;</div><div class="line">            is_checked: props.checked || false,</div><div class="line">            value: props.value || &apos;&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    componentWillReceiveProps(nextProps)&#123;</div><div class="line">        if(&apos;checked&apos; in nextProps)&#123;</div><div class="line">            this.setState(&#123;</div><div class="line">                is_checked:nextProps.checked || false</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    checkCheckBox() &#123;</div><div class="line">        const onChange = this.props.onChange;</div><div class="line">        const value = this.props.value;</div><div class="line">        if (onChange) &#123;</div><div class="line">            onChange(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        let &#123; is_checked, value &#125; = this.state;</div><div class="line">        return (</div><div class="line">            &lt;label&gt;</div><div class="line">                &lt;input value=&#123;value&#125; type=&quot;checkbox&quot; onClick=&#123;this.checkCheckBox&#125; checked=&#123;is_checked&#125; /&gt;</div><div class="line">                &#123;this.props.children !== undefined ? this.props.children : null&#125;</div><div class="line">            &lt;/label&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export default CheckBox;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">//App.js</div><div class="line"></div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import logo from &apos;./logo.svg&apos;;</div><div class="line">import &apos;./App.css&apos;;</div><div class="line">import Blog from &apos;./components/Blog/Blog&apos;</div><div class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</div><div class="line">class App extends Component &#123;</div><div class="line">  state = &#123;</div><div class="line">    checkedList: []</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  changeCheckBox = (value) =&gt; &#123;</div><div class="line">    const valueIndex = this.state.checkedList.indexOf(value)</div><div class="line">    const checkedList = [...this.state.checkedList]</div><div class="line">    if (valueIndex === -1) &#123;</div><div class="line">      checkedList.push(value);</div><div class="line">    &#125; else &#123;</div><div class="line">      checkedList.splice(valueIndex, 1);</div><div class="line">    &#125;</div><div class="line">    this.setState(&#123;</div><div class="line">      checkedList</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getChecked = (value) =&gt; &#123;</div><div class="line">    const valueIndex = this.state.checkedList.indexOf(value)</div><div class="line">    if (valueIndex === -1) &#123;</div><div class="line">      return false</div><div class="line">    &#125;</div><div class="line">    return true</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    console.log(&apos;当前点击&apos;, this.state.checkedList)</div><div class="line">    console.log(&apos;当前点击&apos;, this.getChecked(&apos;按钮1&apos;))</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;App&quot;&gt;</div><div class="line">        &lt;header className=&quot;App-header&quot;&gt;</div><div class="line">          &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</div><div class="line">          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</div><div class="line">        &lt;/header&gt;</div><div class="line">        &lt;p className=&quot;App-intro&quot;&gt;</div><div class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</div><div class="line">        &lt;/p&gt;</div><div class="line">        &lt;Blog /&gt;</div><div class="line">        &lt;CheckBox key=&quot;1&quot; value=&quot;按钮1&quot; checked=&#123;this.getChecked(&apos;按钮1&apos;)&#125; onChange=&#123;this.changeCheckBox&#125;&gt;按钮1&lt;/CheckBox&gt;</div><div class="line">        &lt;CheckBox key=&quot;2&quot; value=&quot;按钮2&quot; checked=&#123;this.getChecked(&apos;按钮2&apos;)&#125; onChange=&#123;this.changeCheckBox&#125;&gt;按钮2&lt;/CheckBox&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default App;</div></pre></td></tr></table></figure>
<p><img src="http://ww1.sinaimg.cn/large/933205a1ly1fp03zn79w8j21m60osaea.jpg"><br>上述代码，复选框增加了自身的状态，初始的<code>state</code>默认从<code>props</code>中读取，再在<code>onChange</code>的时候，再把组件的<code>value</code> 值传上去，然后在父组件中获取，从而实现复选框的可控制，并且可以在控制台中获取到了我们想要的值。</p>
<h4 id="第四步，封装CheckBoxGroup组件"><a href="#第四步，封装CheckBoxGroup组件" class="headerlink" title="第四步，封装CheckBoxGroup组件"></a>第四步，封装CheckBoxGroup组件</h4><p>通过第三步，我们基本实现了我们的需求，但是App.js 文件里面操控复选框组件的逻辑代码太多了，影响了组件的简洁和使用。所以我们打算封装CheckBoxGroup 来包裹我们的复选框组件，把App.js中的逻辑抽离到CheckBoxGroup 组件上。</p>
<p>首先创建CheckBoxGroup.js 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// CheckBoxGroup.js</div><div class="line">import React from &quot;react&quot;</div><div class="line">import PropTypes from &apos;prop-types&apos;;</div><div class="line">class CheckBoxGroup extends React.Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props)</div><div class="line">        this.state = &#123;</div><div class="line">            value: props.value || props.defaultValue || [],</div><div class="line">        &#125;;</div><div class="line">        this.toggleOption = this.toggleOption.bind(this);</div><div class="line">    &#125;</div><div class="line">    componentWillReceiveProps(nextProps) &#123;</div><div class="line">        if (&apos;value&apos; in nextProps) &#123;</div><div class="line">            this.setState(&#123;</div><div class="line">                value: nextProps.value || [],</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    getChildContext() &#123;</div><div class="line">        return &#123;</div><div class="line">            checkboxGroup: &#123;</div><div class="line">                toggleOption: this.toggleOption,</div><div class="line">                value: this.state.value,</div><div class="line">            &#125;,</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    toggleOption(option) &#123;</div><div class="line">        const optionIndex = this.state.value.indexOf(option.value);</div><div class="line">        const value = [...this.state.value];</div><div class="line">        if (optionIndex === -1) &#123;</div><div class="line">            value.push(option.value);</div><div class="line">        &#125; else &#123;</div><div class="line">            value.splice(optionIndex, 1);</div><div class="line">        &#125;</div><div class="line">        if (!(&apos;value&apos; in this.props)) &#123;</div><div class="line">            this.setState(&#123; value &#125;);</div><div class="line">        &#125;</div><div class="line">        const onChange = this.props.onChange;</div><div class="line">        if (onChange) &#123;</div><div class="line">            onChange(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        const &#123; children, className &#125; = this.props</div><div class="line">        return (</div><div class="line">            &lt;div className=&#123;className&#125;&gt;</div><div class="line">                &#123;children&#125;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">CheckBoxGroup.childContextTypes = &#123;</div><div class="line">    checkboxGroup: PropTypes.any,</div><div class="line">&#125;;</div><div class="line">export default CheckBoxGroup</div></pre></td></tr></table></figure>
<p>代码分析：首先从<code>render</code> 开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">        const &#123; children, className &#125; = this.props</div><div class="line">        return (</div><div class="line">            &lt;div className=&#123;className&#125;&gt;</div><div class="line">                &#123;children&#125;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这块代码和上面<code>BlodList</code>那里一样，也是通过<code>this.props.children</code> 加载子节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getChildContext() &#123;</div><div class="line">       return &#123;</div><div class="line">           checkboxGroup: &#123;</div><div class="line">               toggleOption: this.toggleOption,</div><div class="line">               value: this.state.value,</div><div class="line">           &#125;,</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>子组件可以通过设置<code>contextTypes</code>类型后在<code>this.content</code>访问到父组件的<code>getChildContext</code>函数返回的对象属性，需要注意的是，getChildContext 指定的传递给子组件的属性需要先通过 childContextTypes 来指定，不然会产生错误。</p>
<p>同时，在子组件要把受控状态转移到<code>this.content</code>监听的对象中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">//CheckBox.js</div><div class="line">import React from &quot;react&quot;</div><div class="line">import PropTypes from &apos;prop-types&apos;;</div><div class="line">import CheckBoxGroup from &apos;../CheckBoxGroup/CheckBoxGroup&apos;</div><div class="line">class CheckBox extends React.Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props)</div><div class="line">        this.checkCheckBox = this.checkCheckBox.bind(this);</div><div class="line">        this.state = &#123;</div><div class="line">            is_checked: props.checked || false,</div><div class="line">            value: props.value || &apos;&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    checkCheckBox() &#123;</div><div class="line">        const &#123; checkboxGroup &#125; = this.context;</div><div class="line">        if (checkboxGroup) &#123;</div><div class="line">            checkboxGroup.toggleOption(&#123; label: this.props.children, value: this.props.value &#125;)</div><div class="line">        &#125; else &#123;</div><div class="line">            const onChange = this.props.onChange;</div><div class="line">            const value = this.props.value;</div><div class="line">            if (onChange) &#123;</div><div class="line">                onChange(value);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        let &#123; is_checked, value &#125; = this.state;</div><div class="line">        const &#123; checkboxGroup &#125; = this.context;</div><div class="line">        if (checkboxGroup) &#123;</div><div class="line">            is_checked = checkboxGroup.value.indexOf(this.props.value) !== -1;</div><div class="line">        &#125;</div><div class="line">        return (</div><div class="line">            &lt;label&gt;</div><div class="line">                &lt;input value=&#123;value&#125; type=&quot;checkbox&quot; checked=&#123;is_checked&#125;</div><div class="line">                    onClick=&#123;this.checkCheckBox&#125; /&gt;</div><div class="line">                &#123;this.props.children !== undefined ? this.props.children : null&#125;</div><div class="line">            &lt;/label&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">CheckBox.Group = CheckBoxGroup;</div><div class="line">CheckBox.contextTypes = &#123;</div><div class="line">    checkboxGroup: PropTypes.any,</div><div class="line">&#125;</div><div class="line">export default CheckBox;</div></pre></td></tr></table></figure>
<p>子组件在点击的时候，会先判断是否有包裹的<code>this.content.checkboxGroup</code> 属性。如果有，就把状态转移到包裹的组件去管理。<br><code>CheckBox.Group = CheckboxGroup</code> 这段代码方便外部调用组件，即想引用CheckBoxGroup组件可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</div><div class="line">const CheckBoxGroup = CheckBox.Group;</div></pre></td></tr></table></figure>
<p>然后在App.js 中引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//App.js</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import logo from &apos;./logo.svg&apos;;</div><div class="line">import &apos;./App.css&apos;;</div><div class="line">import Blog from &apos;./components/Blog/Blog&apos;</div><div class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</div><div class="line">const CheckBoxGroup = CheckBox.Group;</div><div class="line"></div><div class="line">class App extends Component &#123;</div><div class="line">  state=&#123;</div><div class="line">    checkList:[]</div><div class="line">  &#125;</div><div class="line">  selectCheckBtn=(values)=&gt;&#123;</div><div class="line">    console.log(values)</div><div class="line">    this.setState(&#123;</div><div class="line">      checkList:values</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">    render() &#123;</div><div class="line">    const &#123;checkList&#125; = this.state</div><div class="line">    return (</div><div class="line">      &lt;div className=&quot;App&quot;&gt;</div><div class="line">        &lt;header className=&quot;App-header&quot;&gt; </div><div class="line">         &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;  </div><div class="line">         &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</div><div class="line">        &lt;/header&gt; </div><div class="line">        &lt;p className=&quot;App-intro&quot;&gt;</div><div class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</div><div class="line">        &lt;/p&gt;</div><div class="line">        &lt;Blog/&gt;</div><div class="line">        &lt;CheckBoxGroup value=&#123;checkList&#125; onChange=&#123;this.selectCheckBtn&#125;&gt; </div><div class="line">          &lt;CheckBox value=&#123;&apos;1&apos;&#125;&gt;按钮1&lt;/CheckBox&gt;</div><div class="line">          &lt;CheckBox value=&#123;&apos;2&apos;&#125;&gt;按钮2&lt;/CheckBox&gt;</div><div class="line">          &lt;CheckBox value=&#123;&apos;3&apos;&#125;&gt;按钮3&lt;/CheckBox&gt;</div><div class="line">          &lt;CheckBox value=&#123;&apos;4&apos;&#125;&gt;按钮4&lt;/CheckBox&gt;</div><div class="line">        &lt;/CheckBoxGroup&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;&#125;</div><div class="line">export default App;</div></pre></td></tr></table></figure></p>
<p>最后在浏览器点击复选框</p>
<p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp04zmphioj21py0pygpy.jpg"></p>
<p>现在，我们就完成了一个复选框组件，可以给组件加上一些样式美化一下，然后在需要的时候直接引用就好了。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>写一个组件很容易，但是写好一个组件就不是那么容易的事了，React也有一些现在比较成熟的UI组件库，比如蚂蚁金服的Antd Design <a href="//github.com/ant-design/ant-design/">传送门</a> ，可以打开看看里面的源码学习一下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了如何在React中编写组件。&lt;br&gt;
    
    </summary>
    
      <category term="zhouyinian" scheme="http://xgfe.github.io/categories/zhouyinian/"/>
    
    
      <category term="React" scheme="http://xgfe.github.io/tags/React/"/>
    
      <category term="component" scheme="http://xgfe.github.io/tags/component/"/>
    
  </entry>
  
  <entry>
    <title>ListView源码分析</title>
    <link href="http://xgfe.github.io/2018/02/09/caominkang/ListView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xgfe.github.io/2018/02/09/caominkang/ListView源码分析/</id>
    <published>2018-02-09T05:12:00.000Z</published>
    <updated>2018-03-20T03:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是分析ListView源码，重点关注复用机制。</p>
<a id="more"></a>
<h1 id="ListView源码解析"><a href="#ListView源码解析" class="headerlink" title="ListView源码解析"></a>ListView源码解析</h1><p>&nbsp;&nbsp;本文分为三个部分，第一个部分提取出RecycleBin的相关代码，对RecyleBin做基本讲解；第二部分讲解ListView初始化时onLayout过程；第三部分讲解ListView如何在屏幕滑动中实现复用。</p>
<h2 id="一、RecycleBin"><a href="#一、RecycleBin" class="headerlink" title="一、RecycleBin"></a>一、RecycleBin</h2><p>&nbsp;&nbsp;RecycleBin是AbsListView的子类，也就是说只要是继承自AbsListView的，都可以使用这个机制，代码结构大概如下：</p>
<pre><code>class RecycleBin{
    private int mFirstPosition;
    private View[] mActiveViews = new View[0];
    private int mViewTypeCount;
    private ArrayList&lt;View&gt;[] mScrapViews;
    private ArrayList&lt;View&gt; mCurrentScrap;
    void fillActiveViews(int childCount,int firstActivePostion)
    void getActiveView(int position);
    void addScrapView(View scrap);
    View getSrapView(int position);
    public void setViewTypeCount(int viewTypeCount);
}
</code></pre><p>下面介绍字段和api：</p>
<ul>
<li>mFirstPosition指的是mActiveView[0]中存储的View在数据中的position。</li>
<li>mActiveViews缓存的是第一屏的数据，后面的讲解中会说明，主要是在ListView初始化中起作用</li>
<li>mViewTypeCount代表数据种类，值由setViewTypeCount方法设置。ListView可以处理不同种类的数据</li>
<li>mScrapViews用来缓存移出到屏幕外的view，因为ListView支持不同种类数据，所以mScrapViews是一个二维数组，对应不同种类数据，使用不同的ArrayList去缓存。</li>
<li>fillActiveViews是将屏幕上可以看到的view缓存到mActiveViews中</li>
<li>getActiveViews将指定的位置的view从mActiveViews中取出来，需要注意的是，取出后再次获取该位置view会返回空。</li>
<li>getScrapView用于从mScrapView中取出view，由于同种数据类型的view都是相同的，所以该方法只是返回该类型最后一个位置的view。</li>
</ul>
<p>也就是说RecycleBin有两种缓存view的模式：ActiveView和ScrapView.ListView在初始化过程中使用mActiveViews来缓存显示在屏幕中的view，在滚动过程中使用mScrapView缓存移除到屏幕外的数据，实现复用。下面我来具体看ListView是如何通过调用RecycleBin的方法来管理view的复用。</p>
<h2 id="二、ListView初始化过程"><a href="#二、ListView初始化过程" class="headerlink" title="二、ListView初始化过程"></a>二、ListView初始化过程</h2><p>&nbsp;&nbsp;重点关注ListView初始化过程中onLayout过程，因为与RecycleBin交互主要在这个过程。我们知道，android视图树的根节点是FrameLayout子类，而FrameLayout会让子view执行两次onLayout过程，ListView也不例外，也会有两次onLayout过程。</p>
<h3 id="1-第一次onLayout"><a href="#1-第一次onLayout" class="headerlink" title="1.第一次onLayout"></a>1.第一次onLayout</h3><p>&nbsp;&nbsp;ListView中没有复写父类AbsListView的onLayout方法，不过在父类onLayout中，做完数据判断后，直接调用了layoutChildren，并且注释有说明，子类不应该复写onLayout方法，而该复写layoutChildren。由于layoutChildren需要针对两次onLayout处理，所以判断和分支流程特别复杂，抽取出第一次调用的流程，大概如下：</p>
<pre><code> protected void layoutChildren(){
    int childCount = getChildCount();

    switch(mLayoutMode){

    }
    boolean dataChanged = mDataChanged;
    if(dataChanged){

    }else{
        recycleBin.fillActiveView(childCount,firstPosition);
    }
    detachAllViewsFromParent();
    switch (mLayoutMode){
        default:
            if(childCount==0)
                fillFromTop(childrenTop);
            else
                fillSpecific(0,childrenTop)

    }

}
</code></pre><p>&nbsp;&nbsp;以上是代码结构，省去了很多与分析流程无关的代码，可以看到，由于我们数据源没有变化，dataChanged等于false，进入fillActiveViews，但是此时ListView没有任何子view，childCount为0，这行代码没有任何作用，进入switch语句后，进入default分支，调用fillFromTop。我们进入该函数，发现主要调用了fillDown方法，完整代码如下</p>
<pre><code>private View fillDown(int pos, int nextTop) {
    View selectedView = null;
    int end = (getBottom() - getTop()) - mListPadding.bottom;
    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) {
        // is this the selected item?  
        boolean selected = pos == mSelectedPosition;
        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);
        nextTop = child.getBottom() + mDividerHeight;
        if (selected) {
            selectedView = child;
        }
        pos++;
    }
    return selectedView;
}
</code></pre><p>&nbsp;&nbsp;可以看到，循环调用makeAndAddView（）方法，终止条件是数据项加载完或者最后一个子view的top小于ListView的底部。实现从ListView顶部一直填充到ListView底部，那么makeAndAddView方法肯定是构建view并且填充view到ListView中，下面是相关代码：</p>
<pre><code> private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
                            boolean selected) {
    View child;
    if (!mDataChanged) {
        // Try to use an exsiting view for this position
        child = mRecycler.getActiveView(position);
        if (child != null) {
            // Found it -- we&apos;re using an existing child
            // This just needs to be positioned
            setupChild(child, position, y, flow, childrenLeft, selected, true);
            return child;
        }
    }
    // Make a new view for this position, or convert an unused view if possible
    child = obtainView(position, mIsScrap);
    // This needs to be positioned and measured
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);
    return child;
}
</code></pre><p>&nbsp;&nbsp;首先尝试通过recycler的getActiveView获取view，由于没有缓存过任何view，这里是获取不到的，再使用obtainView获取view。代码如下</p>
<pre><code>View obtainView(int position, boolean[] isScrap) {
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getScrapView(position);
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            dispatchFinishTemporaryDetach(child);
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    return child;
}
</code></pre><p>&nbsp;&nbsp;首先尝试从recyclerBin中获取scrapView，获取成功后作为参数传入Adapter.getView方法中，若获取失败，则将null传入Adapter.getView方法中。我们知道，在使用ListView时需要自定义Adapter，会复写getView方法，通常如下：</p>
<pre><code> public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
    Fruit fruit = getItem(position);
    View view;
    ViewHolder viewHolder;
    if (convertView == null) {
        view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);
        viewHolder = new ViewHolder();
        viewHolder.fruitImage = view.findViewById(R.id.fruit_image);
        viewHolder.fruitName = view.findViewById(R.id.fruit_name);
        view.setTag(viewHolder);

    } else {
        view = convertView;
        viewHolder = (ViewHolder) view.getTag();
    }
    viewHolder.fruitImage.setImageResource(fruit.getImageId());
    viewHolder.fruitName.setText(fruit.getName());
    if(position==0)
        view.setBackgroundColor(Color.RED);

    return view;

}
</code></pre><p>&nbsp;&nbsp;我们可以看到，convertView为空时会使用LayoutInflater加载布局，如果不为空的话，直接复用convertView。到这里obtainView逻辑已经清楚了，回到makeAndAddView中，会将obtainView得到的view传入到setUpChild方法中，然后会调用addViewInLayout将该view添加到ListView中。也就是说第一次onLayout 方法使用Inflater加载了刚好一屏幕数据，其他数据并没有加载。</p>
<p>###2.第二次onLayout<br>&nbsp;&nbsp;我们依然从layoutChild方法开始，代码结构如下：</p>
<pre><code>protected void layoutChildren(){
    int childCount = getChildCount();

    switch(mLayoutMode){

    }
    boolean dataChanged = mDataChanged;
    if(dataChanged){

    }else{
        recycleBin.fillActiveView(childCount,firstPosition);
    }
    detachAllViewsFromParent();
    switch (mLayoutMode){
        default:
            if(childCount==0)
                fillFromTop(childrenTop);
            else
                fillSpecific(0,childrenTop)

    }

}
</code></pre><p>&nbsp;&nbsp;这次我们可以看到由于childCount已经不是0，代码流程如下：</p>
<ul>
<li>recycleBin.fillActiveView():将屏幕中的view缓存到ActiveView[]中</li>
<li>detachAllViewsFromParent():将第一次onLayout加入到ListView中的所有view从ListView中detach</li>
<li>fillSpecific（0，childrenTop）将view加载到ListView中</li>
</ul>
<p>&nbsp;&nbsp;fillSpecific是第一次onLayout过程中没有用到的方法，这个方法逻辑和fillDown很相似，不过是先加载指定位置view再分别加载两边view，由于传入的position是0，效果上基本和fillDown一样。所有我们还是关注makeAndAddView:</p>
<pre><code> private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
                            boolean selected) {
    View child;
    if (!mDataChanged) {
        // Try to use an exsiting view for this position
        child = mRecycler.getActiveView(position);
        if (child != null) {
            // Found it -- we&apos;re using an existing child
            // This just needs to be positioned
            setupChild(child, position, y, flow, childrenLeft, selected, true);
            return child;
        }
    }
    // Make a new view for this position, or convert an unused view if possible
    child = obtainView(position, mIsScrap);
    // This needs to be positioned and measured
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);
    return child;
}
</code></pre><p>&nbsp;&nbsp;这次代码逻辑就很简单了，mRecycler.getActiveView从缓存中获取view后直接将view传入setUpChild中，不过与第一次调用该方法不同的是，最后一个参数传入的是true，标记该view是使用的缓存，根据该标记，setUpChild方法内会走到attachViewToParent,将该view attach到ListView中。两次onLayout总体来说是这样的：</p>
<ul>
<li>使用inflater加载第一屏数据</li>
<li>将第一屏数据加入到recycleBin的ActiveViews中，并将这些view从ListView中移除</li>
<li>将ActiveViews中的view取出，重新attach到ListView中</li>
</ul>
<p>&nbsp;&nbsp;也就是说，在onLayout阶段，ActiveView主要是缓存第一次加载的数据，以避免因为两次onLayout产生重复数据</p>
<h2 id="三、屏幕滑动"><a href="#三、屏幕滑动" class="headerlink" title="三、屏幕滑动"></a>三、屏幕滑动</h2><p>&nbsp;&nbsp;屏幕滑动的处理是写在AbsListView中，触摸监听函数是onTouchEvent（），该函数会针对不同类型的触摸事件进行处理，而在屏幕上滑动事件对应的是ACTION_MOVE,而该case又嵌套一个switch分支，针对TOUCH_MODE处理，我们直接看TOUCH_MODE_SRCOLL,对应手指在屏幕上滑动。在该case内，调用了trackMotionScroll方法，也就是说只要手指在屏幕上滑动，trackMotionScroll就会被调用，trackMotion中核心代码如下：</p>
<pre><code>final boolean down = incrementalDeltaY&lt;0;
 if(down)
{
    final int top = listPadding.top - incrementalDeltaY;
    for (int i = 0; i &lt; childCount; i++) {
        final View child = getChildAt(i);
        if (child.getBottom() &gt;= top) {
            break;
        } else {
            count++;
            int position = firstPosition + i;
            if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) {
                mRecycler.addScrapView(child);
            }
        }
    }
} else
{
    final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;
    for (int i = childCount - 1; i &gt;= 0; i--) {
        final View child = getChildAt(i);
        if (child.getTop() &lt;= bottom) {
            break;
        } else {
            start = i;
            count++;
            int position = firstPosition + i;
            if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) {
                mRecycler.addScrapView(child);
            }
        }
    }
}
</code></pre><p>&nbsp;&nbsp;incrementalDeltaY是上次触发event事件时手指在y方向的改变量，如果小于0说明在屏幕上下滑，进入down为true流程。从ListView第一个child开始判断，只要该view的bottom小于ListView的top，说明该view已经划出了屏幕，调用mRecycler.addScrapView将该view缓存到scrapViews中,用count记录下缓存的数量。这样滑出屏幕的view已经缓存下来了，继续看接下来代码:</p>
<pre><code>if (count &gt; 0) {
    detachViewsFromParent(start, count);
}
offsetChildrenTopAndBottom(incrementalDeltaY);  
if (down) {
    mFirstPosition += count;
}
invalidate();
final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);  
if (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) {
    fillGap(down);
}
</code></pre><p>代码流程如下：</p>
<ul>
<li>调用detachViewFromParent，将滑出屏幕的view从ListView中detach掉</li>
<li>调用offsetChildrenTopAndBottom按照便宜量平移剩下的子view，实现滑动效果</li>
<li>调用fillGap处理将要滑动到屏幕内的view</li>
</ul>
<p>那我们看fillGap如何处理将要移入屏幕的子view的：</p>
<pre><code>void fillGap(boolean down) {
    final int count = getChildCount();
    if (down) {
        final int startOffset = count &gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :
                getListPaddingTop();
        fillDown(mFirstPosition + count, startOffset);
        correctTooHigh(getChildCount());
    } else {
        final int startOffset = count &gt; 0 ? getChildAt(0).getTop() - mDividerHeight :
                getHeight() - getListPaddingBottom();
        fillUp(mFirstPosition - 1, startOffset);
        correctTooLow(getChildCount());
    }
}
</code></pre><p>&nbsp;&nbsp;我们可以看到，方法内部主要是调用了fillDown或者fillUp，我们来回顾下fillDown的逻辑</p>
<ul>
<li>从activeView中获取缓存的view</li>
<li>若第一步获取不成功，则调用obtainView获取view</li>
<li>obtainView会先尝试复用scrapView中的view</li>
<li>若上一步复用失败，则使用inflater加载布局来生成view</li>
<li>将得到的view传入setUpChild中以加入ListView中</li>
</ul>
<p>&nbsp;&nbsp;也就是说，在滑动屏幕时，每当有view从屏幕中移出，就先缓存到scrapViews中，再从ListView中移除该view，而每当有view要滑入屏幕中时，会从scrapViews中取出缓存的view,将其中的数据更新为相应位置的数据，再加入到ListView中，这样的循环使得ListView无论加载多少数据，都是固定数量的view在循环利用，内存都不会增加。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>&nbsp;&nbsp;ListView通过activeView解决两次onLayout过程中数据重复问题，通过scrapView解决滑动过程中view复用问题。无论是onLayout过程还是滑动过程，都是采用attach-detach-attach的操作思路，将两个阶段统一为一个抽象操作，以实现代码的复用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是分析ListView源码，重点关注复用机制。&lt;/p&gt;
    
    </summary>
    
      <category term="caominkang" scheme="http://xgfe.github.io/categories/caominkang/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="源码" scheme="http://xgfe.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="listview" scheme="http://xgfe.github.io/tags/listview/"/>
    
  </entry>
  
  <entry>
    <title>Less Vs Sass</title>
    <link href="http://xgfe.github.io/2018/01/26/zhoushiqi/Less-VS-Sass/"/>
    <id>http://xgfe.github.io/2018/01/26/zhoushiqi/Less-VS-Sass/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-03-20T03:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过一些对Less 和 Sass 的研究和学习,逐渐发现了它们一些共同特征（混入、参数混入、嵌套规则、运算、颜色功能、名字空间、作用域、JavaScript 赋值）和 不同之处，这里主要总结一些 Less 和 Sass <strong>用法不同之处</strong>。</p>
<a id="more"></a>
<h2 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h2><p>CSS 预处理器：用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS作为目标生成文件，开发者只需使用这种语言就可进行编码工作。</p>
<h2 id="简述-Less-amp-Sass"><a href="#简述-Less-amp-Sass" class="headerlink" title="简述 Less &amp; Sass"></a>简述 Less &amp; Sass</h2><table><tr><td>Less</td><td>Sass</td></tr><tr><td>Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。</td><td> Sass 是一门高于 CSS 的元语言，也是一门CSS预处理语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。 </td></tr></table>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote>
<ul>
<li>Less : npm install -g less</li>
<li>Sass : gem install sass</li>
</ul>
</blockquote>
<h2 id="Sass-amp-Less-对比"><a href="#Sass-amp-Less-对比" class="headerlink" title="Sass &amp; Less 对比"></a>Sass &amp; Less 对比</h2><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><ul>
<li>Sass的安装需要Ruby环境,是在服务端处理的</li>
<li>Less是需要引入less.js来处理Less代码输出css到浏览器，也可以在开发环节使用Less，然后编译乘css文件，直接放到项目中,也有Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译的。</li>
</ul>
<h3 id="引用-import"><a href="#引用-import" class="headerlink" title="引用 @import"></a>引用 @import</h3><ul>
<li>Less引用外部文件和css中的@import没什么差异。</li>
<li>scss引用的外部文件命名必须以<em> 开头,文件名如果以下划线</em> 开头的话,Sass会认为该文件是一个引用文件,不会将其编译为css文件。</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>Less的变量声明和调用 : 用@ </li>
<li>Sass的变量声明和调用 : 用$</li>
</ul>
<table><tr><td>Less</td><td>Sass</td></tr><tr><td><img width="300px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntwpg061yj30nw0cwq62.jpg"></td><td><img width="300px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntwo1ksgcj30p80cugo9.jpg"></td></tr></table>

<h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><p>Both : 定义全局变量（在选择器、函数、选择宏…的外面定义的变量为全局变量）</p>
<table><tr><td>Less</td><td>Sass</td></tr><tr><td><img width="300px" height="150px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntwzi2wicj30pm0f4whn.jpg"></td><td><img width="300px" height="150px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntwzh8h1zj30ps0fgq67.jpg"></td></tr></table>

<h3 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h3><ul>
<li>Sass有工具库Compass,简单说,Sass和Compass的关系有点像Javascript和jQuery的关系,Compass是Sass的工具库。在它的基础上,封装了一系列有用的模块和模板,补充强化了Sass的功能。</li>
<li>Less有UI组件库Bootstrap,Bootstrap是web前端开发中一个比较有名的前端UI组件库，Bootstrap的样式文件部分源码就是采用Less语法编写。</li>
</ul>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>1.在Less里你可以用递归函数通过数值来循环:</p>
<pre><code>.looper (@i) when (@i &gt; 0) {
  .image-class-@{i} {
    background: url(“../img/@{i}.png”) no-repeat;
  }
  .looper(@i – 1);
}
.looper(0);
.looper(3);
</code></pre><p>2.在Sass里你可以通过任何数据来迭代:</p>
<pre><code>@each $beer in stout, pilsner, lager {
  .#{$beer}-background {
    background: url(“../img/beers/#{$beer}.png”) no-repeat;
  }
}
</code></pre><h3 id="条件语句-LESS中称作引导"><a href="#条件语句-LESS中称作引导" class="headerlink" title="条件语句(LESS中称作引导)"></a>条件语句(LESS中称作引导)</h3><ul>
<li>Less : 可以通过 when 语句判断条件</li>
<li>Sass : 通过 @if 和 @else 的方式进行条件判断</li>
</ul>
<table><tr><td>Less</td><td>Sass</td></tr><tr><td rowspan="2"><img width="400px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fnty9d44q4j30pi0bcacy.jpg"></td><td><img width="300px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fnty9br31dj30p40iqdjj.jpg"></td></tr></table>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>Less的作用域是按照代码的从上至下的顺序进行的</li>
<li>Sass的作用域是按照最后一次定义影响全局的</li>
</ul>
<table><tr><td>Less</td><td>Sass</td></tr><tr><td><img width="150px" height="300px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntwsyxnt0j30fi0qqacf.jpg"></td><td><img width="150px" height="300px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntwsw1rouj30fg0qodi7.jpg"></td></tr></table>

<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><ul>
<li>LESS : 并没有输出设置，</li>
<li>Sass : 提供4中输出选项：nested, compact, compressed 和 expanded。</li>
</ul>
<h3 id="Mixins-混合宏"><a href="#Mixins-混合宏" class="headerlink" title="Mixins (混合宏)"></a>Mixins (混合宏)</h3><ul>
<li>Less : 支持带参数的混合以及有默认参数值的混合</li>
<li>Sass : 有明确的定义: @Mixin + 宏 调用 : @include + 宏</li>
</ul>
<table><tr><td>Less</td><td>Sass</td></tr><tr><td><img width="300px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntxaheqwoj30n00kin0g.jpg"></td><td><img width="300px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntxak5ku1j30my0ketcd.jpg"></td></tr></table>

<h3 id="Parametric-Mixins-参数混入"><a href="#Parametric-Mixins-参数混入" class="headerlink" title="Parametric-Mixins (参数混入)"></a>Parametric-Mixins (参数混入)</h3><p>混合宏使用中参数使用：</p>
<ul>
<li>Less : @</li>
<li>Sass : $ + @mixin + @include</li>
</ul>
<table><tr><td>Less</td><td>Sass</td></tr><tr><td><img width="300px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntxcz0u3aj30ng0dwq55.jpg"></td><td><img width="300px" height="100px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntxcz7mboj30nm0e0wgz.jpg"></td></tr></table>

<h3 id="Placeholder-占位符"><a href="#Placeholder-占位符" class="headerlink" title="Placeholder (占位符)"></a>Placeholder (占位符)</h3><ul>
<li>Less : Null</li>
<li>Sass : 可以使用 <strong>%</strong> 作为占位符</li>
</ul>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>Sass在数字上比Less更专业。它已经可以换算单位了。Sass可以处理无法识别的度量单位并将其输出。这个特性很明显是一个对未来的尝试——证明W3C作出的一些改变。</p>
<ul>
<li>Sass : 2in + 3cm + 2pc = 3.514in </li>
<li>Less : 2in + 3cm + 2pc = Error</li>
</ul>
<h3 id="选择器继承"><a href="#选择器继承" class="headerlink" title="选择器继承"></a>选择器继承</h3><ul>
<li>Sass定义的选择器可以通过继承的方式使用</li>
<li>Less没有这个功能</li>
</ul>
<table><tr><td>Less</td><td>Sass</td></tr><tr><td>Null</td><td><img width="300px" height="150px" src="https://ws1.sinaimg.cn/large/0073X7Nbly1fntxsqoiopj30p60kmn0e.jpg"></td></tr></table>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="开发中如何选择使用Less还是Sass"><a href="#开发中如何选择使用Less还是Sass" class="headerlink" title="开发中如何选择使用Less还是Sass?"></a>开发中如何选择使用Less还是Sass?</h3><ul>
<li><strong>相同点</strong>：两者都是CSS预处理器，都具有相同的功能，可以帮助我们快速编译代码，帮助我们更好的维护我们的样式代码或者说维护项目吧。</li>
<li><strong>不同点</strong>：Less相对清晰明了,易于上手,对编译环境要求比较宽松。Sass的功能比Less强大,是下一个层次的选择，适合稍微有经验的前端开发者的工具。</li>
<li>根据业务线需求、组内成员情况，进行约定</li>
<li>按需使用，随习惯所为！</li>
</ul>
<h3 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><blockquote>
<p><a href="http://lesscss.cn/" target="_blank" rel="external">http://lesscss.cn/</a> </p>
<p><a href="https://www.sass.hk/" target="_blank" rel="external">https://www.sass.hk/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过一些对Less 和 Sass 的研究和学习,逐渐发现了它们一些共同特征（混入、参数混入、嵌套规则、运算、颜色功能、名字空间、作用域、JavaScript 赋值）和 不同之处，这里主要总结一些 Less 和 Sass &lt;strong&gt;用法不同之处&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="zhoushiqi" scheme="http://xgfe.github.io/categories/zhoushiqi/"/>
    
    
      <category term="CSS" scheme="http://xgfe.github.io/tags/CSS/"/>
    
      <category term="Less" scheme="http://xgfe.github.io/tags/Less/"/>
    
      <category term="Sass" scheme="http://xgfe.github.io/tags/Sass/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式总结</title>
    <link href="http://xgfe.github.io/2018/01/22/liuhaifeng/Regular-Expression/"/>
    <id>http://xgfe.github.io/2018/01/22/liuhaifeng/Regular-Expression/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-03-20T03:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲解JavaScript语言中的正则表达式用法及匹配原理。</p>
<a id="more"></a>
<h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><blockquote>
<p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。  </p>
</blockquote>
<h3 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h3><p>模糊匹配有两个方向上的“模糊”： 横向模糊和纵向模糊。   </p>
<p><strong>横向模糊匹配：</strong> 指正则可匹配的字符串的长度不固定，或是匹配多种情况。</p>
<p>其主要实现方式是：使用量词。如：{m,n}   </p>
<p><strong>例</strong> ：<code>var regex = /ab{2,5}c/</code></p>
<p><strong>纵向模糊匹配：</strong> 指具体到一位字符时，他可以不是确定的字符，匹配多种可能。</p>
<p>其主要实现方式是：使用字符组。如：[abc]   </p>
<p><strong>例</strong> ：<code>var regex = /a[123]b/</code></p>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p><strong>常见写法</strong> ：<code>[abc]</code> </p>
<p><strong>范围表示法</strong> ： <code>[1-9] [a-z]</code> 等  <strong>// 注意：</strong> 要匹配<code>&quot;a&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;z&quot;</code>任意一字符，排除歧义写法即可。—&gt; 即不能写成 <code>[a-z]</code> ,而应形成 <code>[-az]</code> 或 <code>[az-]</code>。</p>
<p><strong>排除字符组</strong> ：<code>[^ab]</code>：表示除ab以外的任意字符，^(脱字符)</p>
<p><strong>常见简写形式</strong> ：</p>
<table>
<thead>
<tr>
<th>字符组</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>表示：一位数字，<code>[0-9]</code>。</td>
</tr>
<tr>
<td>\D</td>
<td>表示：非数字的任意字符，<code>[^0-9]</code> 。</td>
</tr>
<tr>
<td>\w</td>
<td>表示：数字、大小写字母和下划线，<code>[0-9a-zA-Z]</code>。</td>
</tr>
<tr>
<td>\W</td>
<td>表示：非数字、大小写字母和下划线，<code>[^0-9a-zA-Z]</code>。</td>
</tr>
<tr>
<td>\s</td>
<td>表示：空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符,<code>[\t\v\n\r\f]</code>。</td>
</tr>
<tr>
<td>\S</td>
<td>表示：非空白符，<code>[^\t\v\n\r\f]</code>。</td>
</tr>
<tr>
<td>.</td>
<td>表述：通配符，几乎任意字符。但不包括：换行符、回车符、行分隔符、段分隔符。<code>[^\n\r\u2028\u2029]</code>。</td>
</tr>
</tbody>
</table>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><table>
<thead>
<tr>
<th>量词</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>{m,}</td>
<td>至少出现m次。 </td>
</tr>
<tr>
<td>{m}</td>
<td>等价于{m,m}，表示出现m次。</td>
</tr>
<tr>
<td>?</td>
<td>等价于{0,1}表示出现或不出现。</td>
</tr>
<tr>
<td>+</td>
<td>等价于{1,}表示出现至少一次。</td>
</tr>
<tr>
<td>*</td>
<td>等价于{0,}表示出现任意次，或者不出现。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>惰性量词</th>
<th>贪婪量词</th>
</tr>
</thead>
<tbody>
<tr>
<td>{m,}?</td>
<td>{m,}</td>
</tr>
<tr>
<td>{m}?</td>
<td>{m}</td>
</tr>
<tr>
<td>??</td>
<td>？</td>
</tr>
<tr>
<td>+?</td>
<td>+</td>
</tr>
<tr>
<td>*?</td>
<td>*</td>
</tr>
</tbody>
</table>
<h3 id="多选分支"><a href="#多选分支" class="headerlink" title="多选分支"></a>多选分支</h3><p><strong>常见写法</strong> ： <code>/good|nice/</code>  <code>/(p1|p2|p3)ab/</code> , 其中 p1、p2、p3是子模式，用 |（管道符）分割 。</p>
<p><strong>注意</strong> ：分支结构是惰性的，即匹配了前边子模式后，就不再去尝试匹配了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var regex1 = /goodbye|good/g;</div><div class="line">var regex2 = /good|goodbye/g;</div><div class="line">var str = &quot;goodbye&quot;;</div><div class="line">console.log( str.match(regex1) ); // =&gt; [&quot;goodbye&quot;]</div><div class="line">console.log( str.match(regex2) ); // =&gt; [&quot;good&quot;]</div></pre></td></tr></table></figure>
<h2 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h2><blockquote>
<p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。</p>
</blockquote>
<h3 id="什么是位置？"><a href="#什么是位置？" class="headerlink" title="什么是位置？"></a>什么是位置？</h3><p>位置（锚）是相邻字符之间的位置（非字符的位置）。</p>
<p>如<code>&#39;good&#39;</code>字符串,它的位置有5个，用*表示位置即：*g*o*o*d* 。</p>
<p><strong>位置匹配：</strong></p>
<p>在ES5中，共有<strong>6个锚</strong>（用来定位的符号）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">\^</th>
<th style="text-align:left">\$</th>
<th style="text-align:left">\b</th>
<th style="text-align:left">\B</th>
<th style="text-align:left">(?=p)</th>
<th>(?!p)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">开头</td>
<td style="text-align:left">结尾</td>
<td style="text-align:left"><strong>单词边界</strong>。具体就是\w与\W之间的位置，也包括\w与\^和\w与\$之间的位置。如：<code>&quot;good\_nice&quot;</code>,对应为：<code>\*good\*_\*nice\*</code>。（*号位置即为单词边界）。</td>
<td style="text-align:left"><strong>非单词边界</strong>。具体就是\w与\w、\W与\W、\^与\W、\W与\$之间的位置。如：<code>&quot;[big\_go]&quot;</code>,对应为：<code>\*[b\*i\*g\_g\*o]\*</code>。（*号位置即为单词边界,注意<code>[</code>与<code>^</code>、<code>]</code>与<code>$</code>之间也是！）</td>
<td style="text-align:left"><strong>p 前边的位置</strong>（该位置后边的字符要匹配p，<em>其中p是一个子集</em>）。如：<code>console.log(&quot;hello&quot;.replace(/(?=l)/g,&#39;#&#39;))// =&gt; &quot;he#l#l0&quot;</code>。</td>
<td><strong>非p 前边的位置</strong>（该位置后边不能匹配p子集）。如：<code>console.log(&quot;hello&quot;.replace(/(?！l)/g,&#39;#&#39;))// =&gt; &quot;#h#ell#0#&quot;</code>。</td>
</tr>
</tbody>
</table>
<p>可以把位置理解成空字符串<code>&quot;&quot;</code>，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;hello&quot; == &quot;&quot; + &quot;h&quot; + &quot;&quot; + &quot;e&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;l&quot; + &quot;&quot; + &quot;o&quot;  + &quot;&quot; == &quot;&quot; + &quot;&quot; + &quot;h&quot;;</div></pre></td></tr></table></figure>
<h2 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h2><blockquote>
<p>并非仅是为了提高优先级！它的功能蛮强大的！</p>
</blockquote>
<h3 id="分组和分支结构"><a href="#分组和分支结构" class="headerlink" title="分组和分支结构"></a>分组和分支结构</h3><p><strong>分组</strong> ：匹配连续出现多个<code>&quot;ab&quot;</code>时，用<code>/(ab)+/</code>。(括号提供了分组功能，使量词+作用于<code>&quot;ab&quot;</code>这个整体)</p>
<p><strong>分支结构</strong> ：(p1|p2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var regex = /^I Love (JavaScript|CSS)$/;</div><div class="line">console.log( regex.test(&quot;I Love JavaScript&quot;) );</div><div class="line">console.log( regex.test(&quot;I Love CSS&quot;) );</div><div class="line">// =&gt; true </div><div class="line">// =&gt; true</div></pre></td></tr></table></figure>
<p>若去掉括号，即：<code>/^I Love JavaScript|CSS$/</code>，匹配的字符串便是<code>&quot;I Love JavaScript&quot;</code>和<code>&quot;CSS&quot;</code>。</p>
<h3 id="分组引用"><a href="#分组引用" class="headerlink" title="分组引用"></a>分组引用</h3><p>正则在匹配时，会把每个括号的部分分组编号，为每个分组开辟个空间来存储关于括号内的数据。</p>
<p>即：分组是可以捕获的，并且我们可以使用它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">var str = &quot;2018-01-12&quot;;</div><div class="line">console.log( str.match(regex) );</div><div class="line">// =&gt; [&quot;2018-01-12&quot;, &quot;2018&quot;, &quot;01&quot;, &quot;12&quot;, index: 0, input: &quot;2018-01-12&quot;]</div></pre></td></tr></table></figure>
<blockquote>
<p>NOTE : match返回的一个数组，第一个元素是整体匹配结果，然后是各个分组（括号里）匹配的内容，然后是匹配下标，最后是输入的文本。另外，正则表达式是否有修饰符g，match返回的数组格式是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g;</div><div class="line">&gt; var str = &quot;2018-01-12,2018-02-13&quot;;</div><div class="line">&gt; console.log( str.match(regex) );</div><div class="line">&gt; // =&gt; [&quot;2018-01-12&quot;, &quot;2018-02-13&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>正则有分组行为后，构造函数上对应的$1至$9属性就被赋予相应分组匹配的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">var str = &quot;2018-01-12&quot;;</div><div class="line">regex.test(str);</div><div class="line">//regex.exec(str);</div><div class="line">//str.match(regex);</div><div class="line">console.log(RegExp.$1);// =&gt; &quot;2018&quot;</div><div class="line">console.log(RegExp.$2);// =&gt; &quot;01&quot;</div><div class="line">console.log(RegExp.$3);// =&gt; &quot;12&quot;</div><div class="line">console.log(RegExp.$4);// =&gt; &quot;&quot; (没有被赋值)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">var str = &quot;2018-01-12&quot;;</div><div class="line">var result1 = str.replace(regex,&quot;$2/$3/$1&quot;);</div><div class="line">var result2 = str.replace(regex,function()&#123;</div><div class="line">  return RegExp.$2 + &quot;/&quot; + RegExp.$3 + &quot;/&quot; + RegExp.$1;</div><div class="line">&#125;);</div><div class="line">var result3 = str.replace(regex,function(match,year,month,day)&#123;</div><div class="line">  return month + &quot;/&quot; + day + &quot;/&quot; + year;</div><div class="line">&#125;);</div><div class="line">console.log(result1,result2,result3);// =&gt; &quot;01/12/2018&quot; &quot;01/12/2018&quot; &quot;01/12/2018&quot;</div></pre></td></tr></table></figure>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>上一小节通过使用相应API来引用分组，其实也可以在正则自身里引用分组。但只能引用之前出现的分组，即反向引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var regex = /\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/;</div><div class="line">var str1 = &quot;2018-01-12&quot;;</div><div class="line">var str2 = &quot;2018/01/12&quot;;</div><div class="line">var str3 = &quot;2018.01.12&quot;;</div><div class="line">var str4 = &quot;2018-01/12&quot;;</div><div class="line">console.log( regex.test(str1) ); //true</div><div class="line">console.log( regex.test(str2) ); //true</div><div class="line">console.log( regex.test(str3) ); //true</div><div class="line">console.log( regex.test(str4) ); //false</div></pre></td></tr></table></figure>
<p><strong>括号嵌套：</strong> 以左开括号为准！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var regex = /^((\d)(\d(\d)))\1\2\3\4$/;</div><div class="line">var str = &quot;1231231233&quot;;</div><div class="line">console.log( regex.test(str) );// true</div><div class="line">console.log( RegExp.$1 );// 123</div><div class="line">console.log( RegExp.$2 );// 1</div><div class="line">console.log( RegExp.$3 );// 23</div><div class="line">console.log( RegExp.$4 );// 3</div><div class="line">console.log( str.match(regex) );</div><div class="line">// =&gt; [&quot;1231231233&quot;, &quot;123&quot;, &quot;1&quot;, &quot;23&quot;, &quot;3&quot;, index: 0, input: &quot;1231231233&quot;]</div></pre></td></tr></table></figure>
<p><strong><code>\10</code> ：表示第10个分组</strong>（不是\1和0）。</p>
<p><strong>引用不存在的分组时：</strong> 不报错，匹配转义的字符。例如 \2，就匹配 \2。<code>&quot;\2&quot;</code>表示对<code>&quot;2&quot;</code>进行了转义。</p>
<p><strong>分组后边有量！：</strong> 捕获到的数据是最后一次的匹配。（<strong>反向引用也是如此！</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var regex = /(\d)+/;</div><div class="line">var str = &quot;12345&quot;;</div><div class="line">console.log( str.match(regex) ); // [&quot;12345&quot;, &quot;5&quot;, index: 0, input: &quot;12345&quot;]</div><div class="line">var regex2 = /(\d)+ \1/;</div><div class="line">console.log( regex2.test(&quot;12345 1&quot;) );// false</div><div class="line">console.log( regex2.test(&quot;12345 5&quot;) );// true</div></pre></td></tr></table></figure>
<h3 id="非捕获括号"><a href="#非捕获括号" class="headerlink" title="非捕获括号"></a>非捕获括号</h3><p>之前文中出现的括号，都会捕获它们匹配的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分支。<br>如果不想捕获，只想要括号的原始功能，即:既不在API里引用，也不在正则里引用。此时：</p>
<p>使用非捕获型括号<code>(?:p)</code>和<code>(?:p1|p2)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var regex1 = /(ab)+/;</div><div class="line">var regex2 = /(?:ab)+/;</div><div class="line">var str = &quot;ababa ccc&quot;;</div><div class="line">console.log( str.match(regex1) ); // [&quot;abab&quot;, &quot;ab&quot;, index: 0, input: &quot;ababa ccc&quot;]</div><div class="line">console.log( str.match(regex2) ); // [&quot;abab&quot;, index: 0, input: &quot;ababa ccc&quot;]</div></pre></td></tr></table></figure>
<h2 id="回溯法原理"><a href="#回溯法原理" class="headerlink" title="回溯法原理"></a>回溯法原理</h2><blockquote>
<p>回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。</p>
<p>个人理解：当正则匹配多种情况时，会对每种情况进行尝试，若第一次没有尝试成功，就会回退到可以发生其他情况的地方，再次尝试另一种匹配。</p>
</blockquote>
<h3 id="没有回溯的匹配"><a href="#没有回溯的匹配" class="headerlink" title="没有回溯的匹配"></a>没有回溯的匹配</h3><p>当<code>/ab{1,3}c/</code>去匹配<code>&quot;abbbc&quot;</code>时，过程如图：<img src="https://ws4.sinaimg.cn/large/006tKfTcly1fne19t4c22j30go0bydg0.jpg" alt=""></p>
<h3 id="有回溯的匹配"><a href="#有回溯的匹配" class="headerlink" title="有回溯的匹配"></a>有回溯的匹配</h3><p>当<code>/ab{1,3}c/</code>去匹配<code>&quot;abbc&quot;</code>时，中间就有回溯。过程如图：<img src="https://ws4.sinaimg.cn/large/006tKfTcly1fne0xzz5lej30go0ehwf3.jpg" alt=""></p>
<p>图中第5步有红颜色，表示匹配不成功。</p>
<p>图中的第6步，就是“回溯”。</p>
<p><strong>这里再看一个清晰的回溯，正则是：</strong> <code>/&quot;.*&quot;/</code></p>
<p>目标字符串是：<code>&quot;acd&quot;ef</code>，匹配过程是：<img src="https://ws3.sinaimg.cn/large/006tKfTcly1fne1fi1yi2j30go0g7jrl.jpg" alt=""></p>
<p>图中省略了尝试匹配双引号失败的过程。可以看出<code>.*</code>是非常影响效率的。</p>
<p>为了减少一些不必要的回溯，可以把正则修改为<code>/&quot;[^&quot;]*&quot;/</code>。</p>
<p><strong>贪婪量词</strong>  注意：当多个贪婪量词挨着存在，并相互有冲突时，先下手为强！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;12345&quot;;</div><div class="line">var regex = /(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/;</div><div class="line">console.log( string.match(regex) );</div><div class="line">// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;]</div></pre></td></tr></table></figure>
<p><strong>惰性量词</strong>  虽然不贪婪，但为了整体匹配成功，可能也会发生回溯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var string = &quot;12345&quot;;</div><div class="line">var regex = /^\d&#123;1,3&#125;?\d&#123;1,3&#125;$/;</div><div class="line">console.log( string.match(regex) );</div></pre></td></tr></table></figure>
<p>其匹配过程为：<img src="https://ws1.sinaimg.cn/large/006tKfTcly1fne1uulh11j30go0bldgo.jpg" alt=""></p>
<p><strong>分支结构</strong>  前面的子模式会形成局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。</p>
<h2 id="正则表达式的拆分"><a href="#正则表达式的拆分" class="headerlink" title="正则表达式的拆分"></a>正则表达式的拆分</h2><h3 id="结构和操作符"><a href="#结构和操作符" class="headerlink" title="结构和操作符"></a>结构和操作符</h3><p>编程语言一般都有操作符。有操作符，往往就需要语言本身定义好操作顺序，即所谓的优先级。</p>
<p><strong>JS正则表达式中的结构：</strong></p>
<blockquote>
<p>字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。</p>
</blockquote>
<table>
<thead>
<tr>
<th>结构</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>字面量</td>
<td>匹配一个具体字符，包括不用转义的和需要转义的。比如a匹配字符<code>&quot;a&quot;</code>，又比如<code>\n</code>匹配换行符，又比如<code>\.</code>匹配小数点。</td>
</tr>
<tr>
<td>字符组</td>
<td>匹配一个字符，可以是多种可能之一，比如<code>[0-9]</code>，表示匹配一个数字。也有<code>\d</code>的简写形式。另外还有反义字符组，表示可以是除了特定字符之外任何一个字符，比如<code>[^0-9]</code>，表示一个非数字字符，也有<code>\D</code>的简写形式。</td>
</tr>
<tr>
<td>量词</td>
<td>表示一个字符连续出现，比如<code>a{1,3}</code>表示<code>&quot;a&quot;</code>字符连续出现3次。另外还有常见的简写形式，比如<code>a+</code>表示<code>&quot;a&quot;</code>字符连续出现至少一次。</td>
</tr>
<tr>
<td>锚</td>
<td>匹配一个位置，而不是字符。比如^匹配字符串的开头，又比如<code>\b</code>匹配单词边界，又比如<code>(?=\d)</code>表示数字前面的位置。</td>
</tr>
<tr>
<td>分组</td>
<td>用括号表示一个整体，比如<code>(ab)+</code>，表示<code>&quot;ab&quot;</code>两个字符连续出现多次，也可以使用非捕获分组<code>(?:ab)+</code>。</td>
</tr>
<tr>
<td>分支</td>
<td>多个子表达式多选一</td>
</tr>
</tbody>
</table>
<p>其中涉及到的操作符有：</p>
<table>
<thead>
<tr>
<th>操作符描述</th>
<th>操作符</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>转义符</td>
<td><code>\</code></td>
<td>1</td>
</tr>
<tr>
<td>括号和方括号</td>
<td><code>(...)</code>、<code>(?:...)</code>、<code>(?=...)</code>、<code>(?!...)</code>、<code>[...]</code></td>
<td>2</td>
</tr>
<tr>
<td>量词限定符</td>
<td><code>{m}</code>、<code>{m,n}</code>、<code>{m,}</code>、<code>?</code>、<code>*</code>、<code>+</code></td>
<td>3</td>
</tr>
<tr>
<td>位置和序列</td>
<td><code>^</code> 、<code>$</code>、<code>\</code>元字符、 一般字符</td>
<td>4</td>
</tr>
<tr>
<td>管道符</td>
<td>（竖杠）</td>
<td>5</td>
</tr>
</tbody>
</table>
<p><strong>分析一个正则：</strong></p>
<p><code>/ab?(c|de*)+|fg/</code></p>
<ol>
<li>由于括号的存在，所以，<code>(c|de*)</code>是一个整体结构。</li>
<li>在<code>(c|de*)</code>中，注意其中的量词<code>*</code>，因此<code>e*</code>是一个整体结构。</li>
<li>又因为分支结构<code>&quot;|&quot;</code>优先级最低，因此<code>c</code>是一个整体、而<code>de*</code>是另一个整体。</li>
<li>同理，整个正则分成了 <code>a</code>、<code>b?</code>、<code>(...)+</code>、<code>f</code>、<code>g</code>。而由于分支的原因，又可以分成<code>ab?(c|de*)+</code>和<code>fg</code>这两部分。</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p><strong>1. 量词连缀问题：</strong></p>
<p>假设，要匹配这样的字符串：</p>
<blockquote>
<ol>
<li>每个字符为a、b、c任选其一</li>
<li>字符串的长度是3的倍数</li>
</ol>
</blockquote>
<p>此时正则不能想当然地写成<code>/^[abc]{3}+$/</code>，这样会报错，说<code>+</code>前面没什么可重复的</p>
<p>此时要修改成：<code>/^([abc]{3})+$/</code></p>
<p><strong>2. 元字符转义问题</strong></p>
<p>所谓元字符，就是正则中有特殊含义的字符。</p>
<p>所有结构里，用到的元字符总结如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">^ &amp; . * + ? | \ / ( ) [ ] &#123; &#125; = ! : - ,</div></pre></td></tr></table></figure>
<p>当匹配上面的字符本身时，可以一律转义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</div><div class="line">var regex = /\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,/;</div><div class="line">console.log( regex.test(string) ); </div><div class="line">// =&gt; true</div></pre></td></tr></table></figure>
<p>其中<code>string</code>中的<code>\</code>字符也要转义的。</p>
<p>另外，在<code>string</code>中，也可以把每个字符转义，当然，转义后的结果仍是本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</div><div class="line">var string2 = &quot;\^\$\.\*\+\?\|\\\/\[\]\&#123;\&#125;\=\!\:\-\,&quot;;</div><div class="line">console.log( string == string2 ); </div><div class="line">// =&gt; true</div></pre></td></tr></table></figure>
<p>现在的问题是，是不是每个字符都需要转义呢？否，看情况。</p>
<p><strong>3. 字符组中的元字符</strong></p>
<p>跟字符组相关的元字符有<code>[]</code>、<code>^</code>、<code>-</code>。因此在会引起歧义的地方进行转义。例如开头的<code>^</code>必须转义，不然会把整个字符组，看成反义字符组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;^$.*+?|\\/[]&#123;&#125;=!:-,&quot;;</div><div class="line">var regex = /[\^$.*+?|\\/\[\]&#123;&#125;=!:\-,]/g;</div><div class="line">console.log( string.match(regex) );</div><div class="line">// =&gt; [&quot;^&quot;, &quot;$&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;|&quot;, &quot;\&quot;, &quot;/&quot;, &quot;[&quot;, &quot;]&quot;, &quot;&#123;&quot;, &quot;&#125;&quot;, &quot;=&quot;, &quot;!&quot;, &quot;:&quot;, &quot;-&quot;, &quot;,&quot;]</div></pre></td></tr></table></figure>
<p><strong>4. 匹配<code>&quot;[abc]&quot;</code>和<code>&quot;{3,5}&quot;</code></strong></p>
<p>我们知道<code>[abc]</code>，是个字符组。如果要匹配字符串<code>&quot;[abc]&quot;</code>时，该怎么办？</p>
<p>可以写成<code>/\[abc\]/</code>，也可以写成<code>/\[abc]/</code>，测试如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;[abc]&quot;;</div><div class="line">var regex = /\[abc]/g;</div><div class="line">console.log( string.match(regex)[0] ); </div><div class="line">// =&gt; &quot;[abc]&quot;</div></pre></td></tr></table></figure>
<p>只需要在第一个方括号转义即可，因为后面的方括号构不成字符组，正则不会引发歧义，自然不需要转义。</p>
<p>同理，要匹配字符串<code>&quot;{3,5}&quot;</code>，只需要把正则写成<code>/\{3,5}/</code>即可。</p>
<p>另外，我们知道量词有简写形式<code>{m,}</code>，却没有<code>{,n}</code>的情况。虽然后者不构成量词的形式，但此时并不会报错。当然，匹配的字符串也是<code>&quot;{,n}&quot;</code>，测试如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;&#123;,3&#125;&quot;;</div><div class="line">var regex = /&#123;,3&#125;/g;</div><div class="line">console.log( string.match(regex)[0] ); </div><div class="line">// =&gt; &quot;&#123;,3&#125;&quot;</div></pre></td></tr></table></figure>
<p><strong>5. 其余情况</strong></p>
<p>比如<code>=</code> <code>!</code> <code>:</code> <code>-</code> <code>,</code>等符号，只要不在特殊结构中，也不需要转义。</p>
<p>但是，括号需要前后都转义的，如<code>/\(123\)/</code>。</p>
<p>至于剩下的<code>^</code> <code>$</code> <code>.</code> <code>*</code> <code>+</code> <code>?</code> <code>|</code> <code>\</code> <code>/</code>等字符，只要不在字符组内，都需要转义的。</p>
<h2 id="正则表达式的构建"><a href="#正则表达式的构建" class="headerlink" title="正则表达式的构建"></a>正则表达式的构建</h2><blockquote>
<p>针对每种情形，分别写出正则，然用分支把他们合并在一起，再提取分支公共部分，就能得到准确的正则。</p>
</blockquote>
<h3 id="平衡法则"><a href="#平衡法则" class="headerlink" title="平衡法则"></a>平衡法则</h3><p>构建正则有一点非常重要，需要做到下面几点的平衡：</p>
<ol>
<li>匹配预期的字符串</li>
<li>不匹配非预期的字符串</li>
<li>可读性和可维护性</li>
<li>效率</li>
</ol>
<h3 id="构建正则前提"><a href="#构建正则前提" class="headerlink" title="构建正则前提"></a>构建正则前提</h3><p><strong>1. 是否能使用正则:</strong>  如匹配这样的字符串：1010010001….。虽然很有规律，但是只靠正则就是无能为力。</p>
<p><strong>2. 是否有必要使用正则:</strong>  能用字符串API解决的简单问题，就不该正则出马。</p>
<p> 比如，从日期中提取出年月日:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var string = &quot;2017-07-01&quot;;</div><div class="line">var regex = /^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">console.log( string.match(regex) );</div><div class="line">// =&gt; [&quot;2017-07-01&quot;, &quot;2017&quot;, &quot;07&quot;, &quot;01&quot;, index: 0, input: &quot;2017-07-01&quot;]</div><div class="line">var result = string.split(&quot;-&quot;); // 优先用法</div><div class="line">console.log( result );</div><div class="line">// =&gt; [&quot;2017&quot;, &quot;07&quot;, &quot;01&quot;]</div></pre></td></tr></table></figure>
<p> 比如，判断是否有问号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var string = &quot;?id=xx&amp;act=search&quot;;</div><div class="line">console.log( string.search(/\?/) );// =&gt; 0</div><div class="line">console.log( string.indexOf(&quot;?&quot;) );// =&gt; 0  优先用法</div></pre></td></tr></table></figure>
<p> 比如获取子串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var string = &quot;JavaScript&quot;;</div><div class="line">console.log( string.match(/.&#123;4&#125;(.+)/)[1] );// =&gt; Script</div><div class="line">console.log( string.substring(4) );// =&gt; Script</div></pre></td></tr></table></figure>
<p><strong>3. 是否有必要构建一个复杂的正则：</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/</div></pre></td></tr></table></figure>
<p>上边正则可以使用多个小正则来做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/;</div><div class="line">var regex2 = /^[0-9]&#123;6,12&#125;$/;</div><div class="line">var regex3 = /^[A-Z]&#123;6,12&#125;$/;</div><div class="line">var regex4 = /^[a-z]&#123;6,12&#125;$/;</div><div class="line">function checkPassword(string) &#123;</div><div class="line">	if (!regex1.test(string)) return false;</div><div class="line">	if (regex2.test(string)) return false;</div><div class="line">	if (regex3.test(string)) return false;</div><div class="line">	if (regex4.test(string)) return false;</div><div class="line">	return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h3><p>所谓准确性，就是能匹配预期的目标，并且不匹配非预期的目标。</p>
<p>这里提到了“预期”二字，那么我们就需要知道目标的组成规则。</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>保证了准确性后，才需要是否要考虑要优化。大多数情形是不需要优化的，除非运行的非常慢。什么情形正则表达式运行才慢呢？我们需要考察正则表达式的运行过程（原理）。</p>
<p>正则表达式的运行分为如下的阶段：</p>
<ol>
<li>编译</li>
<li>设定起始位置</li>
<li>尝试匹配</li>
<li>匹配失败的话，从下一位开始继续第3步</li>
<li>最终结果：匹配成功或失败</li>
</ol>
<p><strong>1. 使用具体型字符组来代替通配符，来消除回溯</strong></p>
<p>例如，匹配双引用号之间的字符。如，匹配字符串<code>123&quot;abc&quot;456</code>中的<code>&quot;abc&quot;</code>。</p>
<p>如果正则用的是：<code>/&quot;.*&quot;/</code>，，会在第3阶段产生4次回溯</p>
<p>如果正则用的是：<code>/&quot;.*?&quot;/</code>，会产生2次回溯</p>
<p>因为回溯的存在，需要引擎保存多种可能中未尝试过的状态，以便后续回溯时使用。注定要占用一定的内存。</p>
<p>此时要使用具体化的字符组，来代替通配符<code>.</code>，以便消除不必要的字符，此时使用正则<code>/&quot;[^&quot;]*&quot;/</code>，即可。</p>
<p><strong>2. 使用非捕获型分组</strong></p>
<p>因为括号的作用之一是，可以捕获分组和分支里的数据。那么就需要内存来保存它们。</p>
<p>当我们不需要使用分组引用和反向引用时，此时可以使用非捕获分组。例如：</p>
<p><code>/^[+-]?(\d+\.\d+|\d+|\.\d+)$/</code></p>
<p>可以修改成：</p>
<p><code>/^[+-]?(?:\d+\.\d+|\d+|\.\d+)$/</code></p>
<p><strong>3. 独立出确定字符</strong></p>
<p>例如<code>/a+/</code>，可以修改成<code>/aa*/</code>。</p>
<p><strong>4. 提取分支公共部分</strong></p>
<p>比如/<code>^abc|^def/</code>，修改成<code>/^(?:abc|def)/</code>。</p>
<p>又比如<code>/this|that/</code>，修改成<code>/th(?:is|at)/</code>。</p>
<p><strong>5. 减少分支的数量，缩小它们的范围</strong></p>
<p><code>/red|read/</code>，可以修改成<code>/rea?d/</code>。此时分支和量词产生的回溯的成本是不一样的。但这样优化后，可读性会降低的。</p>
<h2 id="正则表达式编程"><a href="#正则表达式编程" class="headerlink" title="正则表达式编程"></a>正则表达式编程</h2><blockquote>
<p>什么叫知识，能指导我们实践的东西才叫知识。</p>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<h3 id="正则表达式的四种操作"><a href="#正则表达式的四种操作" class="headerlink" title="正则表达式的四种操作"></a>正则表达式的四种操作</h3><blockquote>
<p>验证、切分、提取、替换。</p>
</blockquote>
<p><strong>1. 验证</strong> </p>
<p>所谓匹配，就是看目标字符串里是否有满足匹配的子串。因此，“匹配”的本质就是“查找”。</p>
<p>有没有匹配，是不是匹配上，判断是否的操作，即称为“验证”。</p>
<p>比如，判断一个字符串中是否有数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var regex= /\d/;</div><div class="line">var string = &quot;abc123&quot;;</div><div class="line">console.log( !!~string.search(regex) );// =&gt; true</div><div class="line">// (~ 是按位非运算符，简单理解就是，改变运算数的符号并减去1(好处是，它可以把NaN转化为-1,将-1转化为0)。</div><div class="line">console.log( regex.test(string) );// =&gt; true</div><div class="line">console.log( !!string.match(regex) );// =&gt; true</div><div class="line">console.log( !!regex.exec(string) );// =&gt; true</div></pre></td></tr></table></figure>
<p><strong>2. 切分</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var regex = /,/;</div><div class="line">var string = &quot;html,css,javascript&quot;;</div><div class="line">console.log( string.split(regex) );</div><div class="line">// =&gt; [&quot;html&quot;, &quot;css&quot;, &quot;javascript&quot;]</div></pre></td></tr></table></figure>
<p><strong>3. 提取</strong> </p>
<p>虽然整体匹配上了，但有时需要提取部分匹配的数据。</p>
<p>此时正则通常要使用分组引用（分组捕获）功能，还需要配合使用相关API。</p>
<p>这里，还是以日期为例，提取出年月日。注意下面正则中的括号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</div><div class="line">var string = &quot;2017-06-26&quot;;</div><div class="line"></div><div class="line">console.log( string.match(regex) );</div><div class="line">// =&gt;[&quot;2017-06-26&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;26&quot;, index: 0, input: &quot;2017-06-26&quot;]</div><div class="line"></div><div class="line">console.log( regex.exec(string) );</div><div class="line">// =&gt;[&quot;2017-06-26&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;26&quot;, index: 0, input: &quot;2017-06-26&quot;]</div><div class="line"></div><div class="line">regex.test(string);</div><div class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</div><div class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</div><div class="line"></div><div class="line">string.search(regex);</div><div class="line">console.log( RegExp.$1, RegExp.$2, RegExp.$3 );</div><div class="line">// =&gt; &quot;2017&quot; &quot;06&quot; &quot;26&quot;</div><div class="line"></div><div class="line">var date = [];</div><div class="line">string.replace(regex, function(match, year, month, day) &#123;</div><div class="line">	date.push(year, month, day);</div><div class="line">&#125;);</div><div class="line">console.log(date);</div><div class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;26&quot;]</div></pre></td></tr></table></figure>
<p>其中，最常用的是<code>match</code>。</p>
<p><strong>4. 替换</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var string = &quot;2017-06-26&quot;;</div><div class="line">var today = new Date( string.replace(/-/g, &quot;/&quot;) );</div><div class="line">console.log( today );</div><div class="line">// =&gt; Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)</div></pre></td></tr></table></figure>
<h3 id="相关API注意要点"><a href="#相关API注意要点" class="headerlink" title="相关API注意要点"></a>相关API注意要点</h3><p>从上面可以看出用于正则操作的方法，共有6个，字符串实例4个，正则实例2个：</p>
<blockquote>
<p>String#search</p>
<p>String#split</p>
<p>String#match</p>
<p>String#replace</p>
<p>RegExp#test</p>
<p>RegExp#exec</p>
</blockquote>
<p>方法使用细节，可参考《JavaScript权威指南》的第三部分</p>
<p><strong>1. search和match的参数问题</strong></p>
<p>我们知道字符串实例的那4个方法参数都支持正则和字符串。</p>
<p>但<code>search</code>和<code>match</code>，会把字符串转换为正则的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var string = &quot;2017.06.27&quot;;</div><div class="line"></div><div class="line">console.log( string.search(&quot;.&quot;) );</div><div class="line">// =&gt; 0</div><div class="line">//需要修改成下列形式之一</div><div class="line">console.log( string.search(&quot;\\.&quot;) );</div><div class="line">console.log( string.search(/\./) );</div><div class="line">// =&gt; 4</div><div class="line">// =&gt; 4</div><div class="line"></div><div class="line">console.log( string.match(&quot;.&quot;) );</div><div class="line">// =&gt; [&quot;2&quot;, index: 0, input: &quot;2017.06.27&quot;]</div><div class="line">//需要修改成下列形式之一</div><div class="line">console.log( string.match(&quot;\\.&quot;) );</div><div class="line">console.log( string.match(/\./) );</div><div class="line">// =&gt; [&quot;.&quot;, index: 4, input: &quot;2017.06.27&quot;]</div><div class="line">// =&gt; [&quot;.&quot;, index: 4, input: &quot;2017.06.27&quot;]</div><div class="line"></div><div class="line">console.log( string.split(&quot;.&quot;) );</div><div class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;]</div><div class="line"></div><div class="line">console.log( string.replace(&quot;.&quot;, &quot;/&quot;) );</div><div class="line">// =&gt; &quot;2017/06.27&quot;</div></pre></td></tr></table></figure>
<p><strong>2. match返回结果的格式问题</strong></p>
<p><code>match</code>返回结果的格式，与正则对象是否有修饰符<code>g</code>有关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var string = &quot;2017.06.27&quot;;</div><div class="line">var regex1 = /\b(\d+)\b/;</div><div class="line">var regex2 = /\b(\d+)\b/g;</div><div class="line">console.log( string.match(regex1) );</div><div class="line">console.log( string.match(regex2) );</div><div class="line">// =&gt; [&quot;2017&quot;, &quot;2017&quot;, index: 0, input: &quot;2017.06.27&quot;]</div><div class="line">// =&gt; [&quot;2017&quot;, &quot;06&quot;, &quot;27&quot;]</div></pre></td></tr></table></figure>
<p>没有<code>g</code>，返回的是标准匹配格式，即，数组的第一个元素是整体匹配的内容，接下来是分组捕获的内容，然后是整体匹配的第一个下标，最后是输入的目标字符串。</p>
<p>有<code>g</code>，返回的是所有匹配的内容。</p>
<p>当没有匹配时，不管有无<code>g</code>，都返回<code>null</code>。</p>
<p><strong>3.  exec方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var string = &quot;2018.01.15&quot;;</div><div class="line">var regex2 = /\b(\d+)\b/g;</div><div class="line">console.log( regex2.exec(string) ); // =&gt; [&quot;2018&quot;, &quot;2018&quot;, index: 0, input: &quot;2018.01.15&quot;]</div><div class="line">console.log( regex2.lastIndex); // =&gt; 4</div><div class="line">console.log( regex2.exec(string) ); // =&gt; [&quot;01&quot;, &quot;01&quot;, index: 5, input: &quot;2018.01.15&quot;]</div><div class="line">console.log( regex2.lastIndex); // =&gt; 7</div><div class="line">console.log( regex2.exec(string) ); // =&gt; [&quot;15&quot;, &quot;15&quot;, index: 8, input: &quot;2018.01.15&quot;]</div><div class="line">console.log( regex2.lastIndex); // =&gt; 10</div><div class="line">console.log( regex2.exec(string) ); // =&gt; null</div><div class="line">console.log( regex2.lastIndex); // =&gt; 0</div></pre></td></tr></table></figure>
<p>其中正则实例<code>lastIndex</code>属性，表示下一次匹配开始的位置。</p>
<p>比如第一次匹配了<code>“2018”</code>，开始下标是0，共4个字符，因此这次匹配结束的位置是3，下一次开始匹配的位置是4。</p>
<p>从上述代码看出，在使用<code>exec</code>时，经常需要配合使用<code>while</code>循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var string = &quot;2018.01.15&quot;;</div><div class="line">var regex2 = /\b(\d+)\b/g;</div><div class="line">var result;</div><div class="line">while ( result = regex2.exec(string) ) &#123;</div><div class="line">	console.log( result, regex2.lastIndex );</div><div class="line">&#125;</div><div class="line">// =&gt; [&quot;2018&quot;, &quot;2018&quot;, index: 0, input: &quot;2018.01.15&quot;] 4</div><div class="line">// =&gt; [&quot;01&quot;, &quot;01&quot;, index: 5, input: &quot;2018.01.15&quot;] 7</div><div class="line">// =&gt; [&quot;15&quot;, &quot;15&quot;, index: 8, input: &quot;2018.01.15&quot;] 10</div></pre></td></tr></table></figure>
<p><strong>4. 修饰符g，对exex和test的影响</strong></p>
<p>上面提到了正则实例的<code>lastIndex</code>属性，表示尝试匹配时，从字符串的<code>lastIndex</code>位开始去匹配。</p>
<p>字符串的四个方法，每次匹配时，都是从0开始的，即<code>lastIndex</code>属性始终不变。</p>
<p>而正则实例的两个方法<code>exec</code>、<code>test</code>，当正则是全局匹配时，每一次匹配完成后，都会修改<code>lastIndex</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var regex = /a/g;</div><div class="line">console.log( regex.test(&quot;a&quot;), regex.lastIndex );</div><div class="line">console.log( regex.test(&quot;aba&quot;), regex.lastIndex );</div><div class="line">console.log( regex.test(&quot;ababc&quot;), regex.lastIndex );</div><div class="line">// =&gt; true 1</div><div class="line">// =&gt; true 3</div><div class="line">// =&gt; false 0</div></pre></td></tr></table></figure>
<p>注意上面代码中的第三次调用<code>test</code>，因为这一次尝试匹配，开始从下标<code>lastIndex</code>即3位置处开始查找，自然就找不到了。</p>
<p>如果没有<code>g</code>，自然都是从字符串第0个字符处开始尝试匹配。</p>
<p><strong>5. split方法</strong></p>
<ol>
<li><p>它可以有第二个参数，表示结果数组的最大长度。</p>
</li>
<li><p>正则使用分组时，结果数组中是包含分隔符的。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var string = &quot;good,nice,well&quot;;</div><div class="line">console.log( string.split(/,/, 2) ); // =&gt;[&quot;good&quot;, &quot;nice&quot;]</div><div class="line">console.log( string.split(/(,)/) ); // =&gt;[&quot;good&quot;, &quot;,&quot;, &quot;nice&quot;, &quot;,&quot;, &quot;well&quot;]</div></pre></td></tr></table></figure>
<p><strong>6. replace方法</strong></p>
<p><code>replace</code>有两种使用形式，这是因为它的第二个参数，可以是字符串，也可以是函数。</p>
<p>当第二个参数是字符串时，如下的字符有特殊的含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$1,$2,...,$99 匹配第1~99个分组里捕获的文本   </div><div class="line">$&amp; 匹配到的子串文本</div><div class="line">$` 匹配到的子串的左边文本 </div><div class="line">$&apos; 匹配到的子串的右边文本</div><div class="line">$$ 美元符号</div></pre></td></tr></table></figure>
<p>例如，把<code>&quot;2,3,5&quot;</code>，变成<code>&quot;5=2+3&quot;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var result = &quot;2,3,5&quot;.replace(/(\d+),(\d+),(\d+)/, &quot;$3=$1+$2&quot;);</div><div class="line">console.log(result);</div><div class="line">// =&gt; &quot;5=2+3&quot;</div></pre></td></tr></table></figure>
<p>又例如，把<code>&quot;2,3,5&quot;</code>，变成<code>&quot;222,333,555&quot;</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var result = &quot;2,3,5&quot;.replace(/(\d+)/g, &quot;$&amp;$&amp;$&amp;&quot;);</div><div class="line">console.log(result);</div><div class="line">// =&gt; &quot;222,333,555&quot;</div></pre></td></tr></table></figure>
<p>再例如，把<code>&quot;2+3=5&quot;</code>，变成<code>&quot;2+3=2+3=5=5&quot;</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var result = &quot;2+3=5&quot;.replace(/=/, &quot;$&amp;$`$&amp;$&apos;$&amp;&quot;);</div><div class="line">console.log(result);</div><div class="line">// =&gt; &quot;2+3=2+3=5=5&quot;</div></pre></td></tr></table></figure>
<p>当第二个参数是函数时，我们需要注意该回调函数的参数具体是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;1234 2345 3456&quot;.replace(/(\d)\d&#123;2&#125;(\d)/g, function(match, $1, $2, index, input) &#123;</div><div class="line">	console.log([match, $1, $2, index, input]);</div><div class="line">&#125;);</div><div class="line">// =&gt; [&quot;1234&quot;, &quot;1&quot;, &quot;4&quot;, 0, &quot;1234 2345 3456&quot;]</div><div class="line">// =&gt; [&quot;2345&quot;, &quot;2&quot;, &quot;5&quot;, 5, &quot;1234 2345 3456&quot;]</div><div class="line">// =&gt; [&quot;3456&quot;, &quot;3&quot;, &quot;6&quot;, 10, &quot;1234 2345 3456&quot;]</div></pre></td></tr></table></figure>
<p><strong>7. 使用构造函数需要注意的问题</strong></p>
<p>一般不推荐使用构造函数生成正则，而应该优先使用字面量。因为用构造函数会多写很多<code>\</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var string = &quot;2017-06-27 2017.06.27 2017/06/27&quot;;</div><div class="line">var regex = /\d&#123;4&#125;(-|\.|\/)\d&#123;2&#125;\1\d&#123;2&#125;/g;</div><div class="line">console.log( string.match(regex) );</div><div class="line">// =&gt; [&quot;2017-06-27&quot;, &quot;2017.06.27&quot;, &quot;2017/06/27&quot;]</div><div class="line"></div><div class="line">regex = new RegExp(&quot;\\d&#123;4&#125;(-|\\.|\\/)\\d&#123;2&#125;\\1\\d&#123;2&#125;&quot;, &quot;g&quot;);</div><div class="line">console.log( string.match(regex) );</div><div class="line">// =&gt; [&quot;2017-06-27&quot;, &quot;2017.06.27&quot;, &quot;2017/06/27&quot;]</div></pre></td></tr></table></figure>
<p><strong>8. 修饰符</strong></p>
<p>ES5中修饰符，共3个：</p>
<blockquote>
<p><code>g</code> 全局匹配，即找到所有匹配的，单词是global</p>
<p><code>i</code> 忽略字母大小写，单词ingoreCase</p>
<p><code>m</code> 多行匹配，只影响<code>^</code>和<code>$</code>，二者变成行的概念，即行开头和行结尾。单词是multiline</p>
</blockquote>
<p>当然正则对象也有相应的只读属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var regex = /\w/img;</div><div class="line">console.log( regex.global );</div><div class="line">console.log( regex.ignoreCase );</div><div class="line">console.log( regex.multiline );</div><div class="line">// =&gt; true</div><div class="line">// =&gt; true</div><div class="line">// =&gt; true</div></pre></td></tr></table></figure>
<p><strong>9. source属性</strong></p>
<p>正则实例对象属性，除了<code>global</code>、<code>ingnoreCase</code>、<code>multiline</code>、<code>lastIndex</code>属性之外，还有一个<code>source</code>属性。可以通过查看该属性，来确认构建出的正则到底是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var className = &quot;high&quot;;</div><div class="line">var regex = new RegExp(&quot;(^|\\s)&quot; + className + &quot;(\\s|$)&quot;);</div><div class="line">console.log( regex.source )</div><div class="line">// =&gt; (^|\s)high(\s|$) 即字符串&quot;(^|\\s)high(\\s|$)&quot;</div></pre></td></tr></table></figure>
<p><strong>10. 构造函数属性</strong></p>
<p>构造函数的静态属性基于所执行的最近一次正则操作而变化。除了是<code>$1,...,$9</code>之外，还有几个不太常用的属性（有兼容性问题）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RegExp.input 最近一次目标字符串，简写成RegExp[&quot;$_&quot;]</div><div class="line">RegExp.lastMatch 最近一次匹配的文本，简写成RegExp[&quot;$&amp;&quot;]</div><div class="line">RegExp.lastParen 最近一次捕获的文本，简写成RegExp[&quot;$+&quot;]</div><div class="line">RegExp.leftContext 目标字符串中`lastMatch`之前的文本，简写成RegExp[&quot;$`&quot;]</div><div class="line">RegExp.rightContext目标字符串中`lastMatch`之后的文本，简写成RegExp[&quot;$&apos;&quot;]</div></pre></td></tr></table></figure>
<p><strong>总结自：老姚的《正则表达式迷你书》。</strong></p>
<p>推荐通读：<a href="https://juejin.im/post/5965943ff265da6c30653879" target="_blank" rel="external">JS正则表达式完整教程</a></p>
<p>作者推荐阅读： 《JavaScript权威指南》、《精通正则表达式》、《正则表达式必知必会》、《正则指引》、《正则表达式入门》、《正则表达式经典实例》、《JavaScript Regular Expressions》、《高性能JavaScript 》、《JavaScript忍者秘籍》、《JavaScript高级程序设计》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要讲解JavaScript语言中的正则表达式用法及匹配原理。&lt;/p&gt;
    
    </summary>
    
      <category term="liuhaifeng" scheme="http://xgfe.github.io/categories/liuhaifeng/"/>
    
    
      <category term="正则表达式" scheme="http://xgfe.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Regular Expression" scheme="http://xgfe.github.io/tags/Regular-Expression/"/>
    
  </entry>
  
  <entry>
    <title>移动端基于vue-router的滚动位置记录(keep-alive)</title>
    <link href="http://xgfe.github.io/2018/01/19/lulutia/keep-alive/"/>
    <id>http://xgfe.github.io/2018/01/19/lulutia/keep-alive/</id>
    <published>2018-01-19T02:57:00.000Z</published>
    <updated>2018-01-19T03:40:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对于如何在基于vue的移动端实现滚动位置记录进行了探讨。</p>
<a id="more"></a>
<p>在日常开发中，我们经常的会遇见与滚动位置记录相关的需求。多见于从列表页进入详情页，然后进行回退。对这种情况提炼出一套解决方案是相当有必要的。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在日常开发中，我们经常的会遇见与滚动位置记录相关的需求。多见于从列表页进入详情页，然后进行回退。原因如下：</p>
<ul>
<li>在移动开发中，列表多是由无限滚动进行加载的，因此如果回退后又从头进行加载实际上用户体验是相当不好的</li>
<li>如果列表页的展现对实时性要求不高甚至长期不变，则回退后又进行的重新加载实际上是性能的浪费<br>针对上面，在实际操作时更理想的情况是，对于实时性不高的列表，从列表页进入详情页又回退后，列表页会保存之前的位置。<br>在基于vue-router的项目中，为了实现上述效果可以使用其提供的keep-alive功能与scrollBehavior进行配合。</li>
</ul>
<h4 id="keep-alive与scrollBehavior"><a href="#keep-alive与scrollBehavior" class="headerlink" title="keep-alive与scrollBehavior"></a>keep-alive与scrollBehavior</h4><ul>
<li>keep-alive: keep-alive是Vue内置的一个抽象组件，它自身不会渲染DOM元素也不会出现在父组件链中，它只是在包裹动态组件时会缓存不活动的组件实例，而不是销毁它们。<a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="external">更多使用方法详见Vue官方文档</a>。</li>
<li>scrollBehavior: scrollBehavior是由vue-router中Router实例提供的方法，它接受三个参数，分别为(to, from, savedPosition)，其中to和from是路由对象，而savedPosition是当 popstate导航(通过浏览器的 前进/后退 按钮触发)时记录的位置信息。<ul>
<li>scrollBehavior返回滚动位置的对象信息，如{ x: number, y: number}，如果返回的是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy" target="_blank" rel="external">falsy</a>或者空对象则不会发生滚动。</li>
<li>注意scrollBehavior只在HTML5 history模式下可用。</li>
</ul>
</li>
</ul>
<h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><ul>
<li>使用router-view配合keep-alive: 在入口文件通过v-if进行对特定页面的缓存。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"page-group"</span>&gt;</div><div class="line">  &lt;keep-alive&gt;</div><div class="line">    &lt;router-view class="view" v-if="$route.meta.keep_alive"&gt;&lt;/router-view&gt;</div><div class="line">  &lt;/keep-alive&gt;</div><div class="line">  &lt;router-view class="view" v-if="!$route.meta.keep_alive"&gt;&lt;/router-view&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<ul>
<li>对路由进行配置，开启HTML5 history模式并配置scrollBehavior：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">		<span class="attr">mode</span>: <span class="string">'history'</span>,</div><div class="line">		<span class="attr">scrollBehavior</span>: scrollBehavior,</div><div class="line">		routes</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li><p>对路由进行配置，定制scrollBehavior方法，在这里会遇见以下几个问题：        </p>
<ul>
<li><p>如何判断页面是否需要保留位置信息: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  <span class="attr">name</span>: constants.NAME,</div><div class="line">  <span class="attr">path</span>: constants.PATH,</div><div class="line">  <span class="attr">component</span>: <span class="built_in">module</span>,</div><div class="line">  <span class="attr">meta</span>: &#123;</div><div class="line">    <span class="attr">title</span>: constants.TITLE,</div><div class="line">    <span class="attr">val_cid</span>: constants.VAL_CID,</div><div class="line">    <span class="attr">requireAuth</span>: constants.REQUIRE_AUTH,</div><div class="line">    <span class="attr">keep_alive</span>: <span class="literal">true</span></div><div class="line">  &#125;,</div><div class="line">  constants</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们通过在路由上添加了一个参数keep_alive来声明当前路由是否要启动keep_alive的功能。</p>
</li>
<li><p>如何根据需要刷新页面，重新获取数据: 假如我们有三个页面，通过A进入B，通过B进入C。那么其中通过A进入B是需要进行数据刷新的；而从B进入C，再从C返回B则不需要进行数据刷新。因此针对同一个页面我们需要使用一种机制来判断多久需要数据刷新。<br>基本我们可以提炼出：通过<strong>跳转</strong>的是需要进行数据刷新的；而通过默认浏览器行为的是不需要进行浏览器刷新的。<br>看vue-router的源码中我们会发现下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</div><div class="line">	.......</div><div class="line">    	this.transitionTo(location, route =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (supportsScroll) &#123;</div><div class="line">        handleScroll(router, route, current, <span class="literal">true</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">push (location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span>) &#123;</div><div class="line">  ...</div><div class="line">  this.transitionTo(location, route =&gt; &#123;</div><div class="line">    ...</div><div class="line">    handleScroll(<span class="keyword">this</span>.router, route, fromRoute, <span class="literal">false</span>)</div><div class="line">    ...</div><div class="line">  &#125;, onAbort)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码在处理popstate时调用的handleScroll方法传入的最后一个参数是true，但是自己重写的push、replace等函数调用handleScroll时传入的最后一个参数都是false。<br>而在scroll.js中，我们可以看到handleScroll函数的最后一个参数就是用来区分浏览器默认行为，和router-link的行为的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">const behavior = router.options.scrollBehavior</div><div class="line">......</div><div class="line">router.app.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">   <span class="keyword">const</span> position = getScrollPosition()</div><div class="line">   <span class="keyword">const</span> shouldScroll = behavior.call(router, to, <span class="keyword">from</span>, isPop ? position : <span class="literal">null</span>)</div><div class="line">......</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面一段代码中，我们可以看到，对于浏览器默认行为，调用自定义的scrollBehavior函数后传参的savedPosition为保存的position，对于跳转这种则传参的savedPosition为null。<br><strong>通过上面，我们已经能区分什么时候需要进行数据刷新了</strong>。之后，我们需要修改两部分的代码，一部分是scrollBehavior，修改它来根据不同的情况返回不同的滚动值；另外一部分是实际keep-alive的页面的渲染逻辑，它需要根据不同的情况来选择是否进行数据获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> scrollBehavior = <span class="function">(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">t</span> =&gt;</span> t.meta.keep_alive)) &#123;</div><div class="line">  	to.meta.saved_position = savedPosition; <span class="comment">// 传递这个值到具体页面来判断是否进行数据刷新</span></div><div class="line">    <span class="keyword">let</span> back = savedPosition ? savedPosition : &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">return</span> back;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">beforeRouteEnter: <span class="function"><span class="keyword">function</span>(<span class="params">to ,from, next</span>)</span>&#123;</div><div class="line">     next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</div><div class="line">     	<span class="comment">// 通过对null的判断决定是否进行数据刷新</span></div><div class="line">       <span class="keyword">if</span> (to.meta.saved_position === <span class="literal">null</span>) &#123;</div><div class="line">         vm.initAll();</div><div class="line">       &#125;</div><div class="line">     &#125;)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里需要注意必须要在beforeRouteEnter的next里面进行调用，因为一般的生命周期钩子比如mounted等都会被keep-alive给吃掉。</p>
</li>
</ul>
</li>
</ul>
<h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><p>在实际使用中，其实上面这种做法会有问题。我们会发现，在A页面进行刷新，然后第一次从A进入B，又从B返回A的时候，并没有滚动到特定的位置。它滚动到了顶部。通过代码调试，我们可以看到，这一次返回的savedPosition为undefined，因此在判断back的时候会赋值{x: 0, y: 0}。</p>
<p>为了解决这个问题，我们需要手动记录一下滚动的位置。</p>
<p>在路由跳转的时候，如果from的是keep-alive的页面，则记录它的位置，并保存在路由上。之后通过浏览器行为进入这个页面的时候对位置进行判定，如果有就取这个值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> scrollBehavior = <span class="function">(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">t</span> =&gt;</span> t.meta.keep_alive)) &#123;</div><div class="line">    <span class="keyword">if</span> (savedPosition === <span class="literal">null</span>) &#123;</div><div class="line">      to.meta.saved_position = <span class="literal">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      savedPosition = to.meta.saved_position;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> back = savedPosition ? savedPosition : &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">return</span> back;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</div><div class="line">	...</div><div class="line">	if (<span class="keyword">from</span>.meta.keep_alive) &#123;</div><div class="line">    <span class="keyword">from</span>.meta.saved_position = &#123;<span class="attr">x</span>: <span class="built_in">window</span>.pageXOffset, <span class="attr">y</span>: <span class="built_in">window</span>.pageXOffset&#125;;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>自此，可以解决这个问题。<br>那么我们接下来看下，为啥会出现undefined。在vue-router的代码中，有下面几段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> router.app.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">   <span class="keyword">const</span> position = getScrollPosition()</div><div class="line">   <span class="keyword">const</span> shouldScroll = behavior.call(router, to, <span class="keyword">from</span>, isPop ? position : <span class="literal">null</span>)</div><div class="line">......</div><div class="line"> &#125;)</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getScrollPosition</span> (<span class="params"></span>): ?<span class="title">Object</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> key = getStateKey()</div><div class="line">  <span class="keyword">if</span> (key) &#123;</div><div class="line">    <span class="keyword">return</span> positionStore[key]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，如果在调用getScrollPosition方法时，如果在positionStore里面没有找到对应当前key的数据，则会返回undefined。</p>
<p>那么为什么会没找到当前的key呢，因为刷新后，也就是当router进行初始化时，当前的路由状态并没有在history上进行注册，即window.history.state为null。此时，当在当前页面A进行滑动后跳转到其他页面B时，会将位置信息存储到positionStore上面，key为初始化的window.performance.now().toFixed(3)。此时，点击回退按钮，会触发popstate来获取A的信息。但是因为A的history state并没有注册。所以无法找到匹配的位置信息。</p>
<p>不过好的是现在这个问题已经被修复了，在<a href="https://github.com/vuejs/vue-router/releases/tag/v2.8.0" target="_blank" rel="external">2.8.0及其以上版本</a>中可以看到。修复思路就是在路由进行初始化的时候调用window.history.replaceState({ key: getStateKey() }, ‘’)来进行一个注册。具体见<a href="https://github.com/vuejs/vue-router/issues/1585" target="_blank" rel="external">链接</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.jianshu.com/p/fe238d8e7c6d" target="_blank" rel="external">vue-router 中使用 keep-alive 控制 ajax 请求的缓存策略(二)</a></li>
<li><a href="https://github.com/vuejs/vue-router/blob/dev/src/util/scroll.js" target="_blank" rel="external">vue-router dev分支源码</a></li>
<li><a href="https://github.com/vuejs/vue-router/issues/772" target="_blank" rel="external">scrollBehavior doesn’t store a scrolling position on the first page #772</a></li>
<li><a href="https://github.com/vuejs/vue-router/issues/1585" target="_blank" rel="external">scrollBehavior doesn’t work for initial route in Firefox #1585</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要对于如何在基于vue的移动端实现滚动位置记录进行了探讨。&lt;/p&gt;
    
    </summary>
    
      <category term="lulutia" scheme="http://xgfe.github.io/categories/lulutia/"/>
    
    
      <category term="Vue" scheme="http://xgfe.github.io/tags/Vue/"/>
    
      <category term="keep-alive" scheme="http://xgfe.github.io/tags/keep-alive/"/>
    
      <category term="vue-router" scheme="http://xgfe.github.io/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>Node学习系列(1) -- Node实现爬虫</title>
    <link href="http://xgfe.github.io/2018/01/05/hardhpp/node_crawler/"/>
    <id>http://xgfe.github.io/2018/01/05/hardhpp/node_crawler/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-01-16T03:23:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Node学习系列(1) – 使用Node实现爬虫，介绍了如何实现一个简单的爬虫程序、多页面的爬虫程序、如何保存爬虫的结果等内容。</p>
<a id="more"></a>
<p><strong>前提</strong>：已安装Node.js和npm<br><strong>开发环境</strong>：推荐Visual Studio Code<br><strong>使用到的模块</strong>：http cheerio fs (说明：Node中的原生模块之外的其他模块，需要使用<code>npm install &lt;package&gt;</code>进行安装)</p>
<p><strong>blog背景</strong>：现在需要获取xgfe博客(<a href="http://xgfe.github.io/">http://xgfe.github.io/</a>) 中所有博客的相关数据，数据包括：博客的题目、链接地址、创建时间、作者以及关键字。</p>
<h2 id="Step1：确定要爬取的网页"><a href="#Step1：确定要爬取的网页" class="headerlink" title="Step1：确定要爬取的网页"></a>Step1：确定要爬取的网页</h2><p>在开始爬虫程序开始之前，我们应该先明确需要爬取的网页以及内容。  </p>
<p>本文要爬取的网页是：<a href="http://xgfe.github.io/">http://xgfe.github.io/</a>   </p>
<p>爬取网页全部数据，程序如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// app01.js</div><div class="line">var http = require(&apos;http&apos;)</div><div class="line">var url = &apos;http://xgfe.github.io/&apos;</div><div class="line"></div><div class="line">http.get(url,function(res)&#123;</div><div class="line">    var html = &apos;&apos;;</div><div class="line"></div><div class="line">    res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">        html+=data;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    res.on(&apos;end&apos;,function()&#123;</div><div class="line">        console.log(html);</div><div class="line">    &#125;)</div><div class="line">&#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">    console.log(&apos;获取数据出错&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>运行结果：输出网页的源代码（图略）<br>本步骤获取到页面的所有信息，为之后获取指定信息做铺垫。</p>
<h3 id="http模块简单介绍"><a href="#http模块简单介绍" class="headerlink" title="http模块简单介绍"></a>http模块简单介绍</h3><p>http模块是Node中的原生模块，该部分在Node进程启动时，就被直接加载进内存中，不需要再次安装。<br>Node的http模块包含对HTTP处理的封装。http服务继承自TCP服务器，能够与多个客户端保持连接，采用事件驱动的形式，低内存占用，高并发。   </p>
<p>引入http模块： <code>require(&#39;http&#39;)</code></p>
<ul>
<li><p>HTTP服务器</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// http_createServer.js</div><div class="line">var http = require(&apos;http&apos;);</div><div class="line"></div><div class="line">http.createServer(function(req, res)&#123;</div><div class="line">    res.writeHead(200, &#123;&apos;Content-type&apos; : &apos;text/html&apos;&#125;);</div><div class="line">    res.write(&apos;&lt;h1&gt;Node&lt;/h1&gt;&apos;);</div><div class="line">    res.end(&apos;&lt;p&gt;Hello World&lt;/p&gt;&apos;);</div><div class="line">&#125;).listen(3000);</div></pre></td></tr></table></figure>
<p>  运行代码，在浏览器访问<code>http://localhost:3000</code></p>
</li>
<li><p>HTTP客户端(http模块提供了两个函数http.request和http.get，功能是客户端向服务器端发送请求)</p>
<ol>
<li><p>http.request(options,callback)用于发起http请求，接收两个参数，options是一个类似关联数组的对象，里面包含一些请求的参数，callback表示请求后的回调。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// http_request.js</div><div class="line">var http = require(&apos;http&apos;)</div><div class="line">var querystring = require(&apos;querystring&apos;)   // querystring模块需要使用npm安装</div><div class="line"></div><div class="line">var postData = querystring.stringify(&#123;</div><div class="line">    &apos;msg&apos;: Hello World!&apos;</div><div class="line"> &#125;);</div><div class="line">  </div><div class="line">var options = &#123;</div><div class="line">    hostname: &apos;www.baidu.com&apos;,</div><div class="line">    port: null,</div><div class="line">    path: &apos;/&apos;,</div><div class="line">    method: &apos;POST&apos;,</div><div class="line">    headers: &#123;</div><div class="line">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;,</div><div class="line">        &apos;Content-Length&apos;: Buffer.byteLength(postData)</div><div class="line">    &#125;</div><div class="line">&#125;;		</div><div class="line"></div><div class="line">var req = http.request(options, function (res) &#123;</div><div class="line">    var html = &apos;&apos;</div><div class="line"></div><div class="line">    console.log(&apos;状态码:&apos; + res.statusCode);</div><div class="line">    console.log(&apos;头部信息:&apos; + JSON.stringify(res.headers));</div><div class="line">    res.setEncoding(&apos;utf8&apos;);</div><div class="line">    res.on(&apos;data&apos;, function (chunk) &#123;</div><div class="line">        html += chunk;</div><div class="line">    &#125;)</div><div class="line">    res.on(&apos;end&apos;, function () &#123;</div><div class="line">        console.log(html);</div><div class="line">    &#125;);</div><div class="line">&#125;).on(&apos;error&apos;, function (e) &#123;</div><div class="line">   	console.error(&apos;请求出错了！&apos;);	</div><div class="line">&#125;);</div><div class="line">  </div><div class="line">// write data to request body</div><div class="line">req.write(postData);</div><div class="line">req.end();</div></pre></td></tr></table></figure>
</li>
<li><p>http.get(options,callback)，用来更简单的处理GET方式的请求，它是http.request的简化版本，唯一的区别在于http.get自动将请求方法设为GET请求，同时不需要手动调用req.end()。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// http_get.js</div><div class="line">var http = require(&apos;http&apos;)</div><div class="line">	</div><div class="line">http.get(&apos;http://www.baidu.com&apos;,function (res) &#123;</div><div class="line">    var html = &apos;&apos;;</div><div class="line">    </div><div class="line">    console.log(&apos;状态码:&apos; + res.statusCode);</div><div class="line">    res.on(&apos;data&apos;, function (data) &#123;</div><div class="line">        html += data</div><div class="line">    &#125;)</div><div class="line">    res.on(&apos;end&apos;, function ()&#123;</div><div class="line">        console.log(html)</div><div class="line">    &#125;)</div><div class="line">&#125;).on(&apos;error&apos;, function () &#123;</div><div class="line">    console.log(&apos;获取数据出错&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="Step2：分析网页结构，确定数据的结构"><a href="#Step2：分析网页结构，确定数据的结构" class="headerlink" title="Step2：分析网页结构，确定数据的结构"></a>Step2：分析网页结构，确定数据的结构</h2><p>分析网页结构如下：</p>
<p><img src="https://github.com/hardhpp/Node/blob/master/crawler/picture/picture1.png?raw=true" alt=""></p>
<p>可以看出，图中方框内显示的数据，是最终应该获取的数据。</p>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><p>根据最终的需求以及网页的结构，我们可以定义数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[&#123;</div><div class="line">    blogTitle: blogTitle,       // 博客名称</div><div class="line">    blogHref: blogHref,         // 博客链接</div><div class="line">    blogTime: blogTime,	         // 博客创建时间</div><div class="line">    blogAuthor: blogAuthor,     // 博客作者</div><div class="line">    blogKeywords: [],           // 博客关键词</div><div class="line">    blogAbstract: blogAbstract  // 博客简介</div><div class="line">&#125;]</div></pre></td></tr></table></figure>
<p>xgfe博客的数据与页面的对应如下：</p>
<p><img src="https://github.com/hardhpp/Node/blob/master/crawler/picture/picture2.png?raw=true" alt=""></p>
<p>引入chreeio模块(chreeio模块需要使用<code>npm</code>进行安装)，使得可以更方便的访问html的结点，方便查找所需数据。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">// app02.js</div><div class="line">var http = require(&apos;http&apos;)</div><div class="line">var cheerio = require(&apos;cheerio&apos;)</div><div class="line">var url = &apos;http://xgfe.github.io/&apos;</div><div class="line"></div><div class="line">var urlArr = url.split(&apos;&apos;)</div><div class="line">urlArr.splice(-1)</div><div class="line">var rootUrl = urlArr.join(&apos;&apos;)</div><div class="line"></div><div class="line">var index =0 </div><div class="line"></div><div class="line">// 获取内容</div><div class="line">function filterBlogInfo(html) &#123;</div><div class="line"></div><div class="line">    var $ = cheerio.load(html)</div><div class="line">    var blogContent = $(&apos;#content .post&apos;)</div><div class="line">    var blogInfo =  []</div><div class="line">    var root</div><div class="line"></div><div class="line">    blogContent.each(function (index,item) &#123;</div><div class="line">        var blogItemHeader = $(this).find(&apos;.post-header&apos;)</div><div class="line">        var blogItemBody = $(this).find(&apos;.post-body&apos;)</div><div class="line">        var blogArticleInfo = &#123;&#125;</div><div class="line">        var blogTitle = blogItemHeader.find(&apos;.post-title-link&apos;).text().trim()</div><div class="line">        var blogHref = rootUrl + blogItemHeader.find(&apos;.post-title-link&apos;).attr(&apos;href&apos;)</div><div class="line">        var blogTime = blogItemHeader.find(&apos;.post-time time&apos;).text().trim()</div><div class="line">        var blogAuthor = blogItemHeader.find(&apos;.post-category a&apos;).text().trim()</div><div class="line">        var blogKeywords = []</div><div class="line">        blogItemHeader.find(&apos;.post-tags a&apos;).each(function (tagItem) &#123;</div><div class="line">            blogKeywords.push($(this).text().trim())</div><div class="line">        &#125;)</div><div class="line">        var blogAbstract = blogItemBody.find(&apos;p&apos;).text().trim()</div><div class="line"></div><div class="line">        blogArticleInfo.blogTitle = blogTitle</div><div class="line">        blogArticleInfo.blogHref = blogHref</div><div class="line">        blogArticleInfo.blogTime = blogTime</div><div class="line">        blogArticleInfo.blogAuthor = blogAuthor</div><div class="line">        blogArticleInfo.blogKeywords = blogKeywords</div><div class="line">        blogArticleInfo.blogAbstract = blogAbstract</div><div class="line"></div><div class="line">        blogInfo.push(blogArticleInfo)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    return blogInfo</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 打印数据</div><div class="line">function printBlogInfo (blogInfo) &#123;</div><div class="line"></div><div class="line">    blogInfo.forEach(function (item) &#123;</div><div class="line">        console.log(index++)</div><div class="line">        console.log(&apos;题目： &apos; + item.blogTitle)</div><div class="line">        console.log(&apos;链接： &apos; + item.blogHref)</div><div class="line">        console.log(&apos;时间： &apos; + item.blogTime)</div><div class="line">        console.log(&apos;作者： &apos; + item.blogAuthor)</div><div class="line">        console.log(&apos;关键字： &apos;)</div><div class="line">        item.blogKeywords.forEach( function (tagItem) &#123;</div><div class="line">            console.log(tagItem)</div><div class="line">        &#125;)</div><div class="line">        console.log(&quot;简介： &quot; + item.blogAbstract +&apos;\n&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取网页源代码</div><div class="line">http.get(url,function(res)&#123;</div><div class="line">    var html = &apos;&apos;;</div><div class="line"></div><div class="line">    res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">        html+=data;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    res.on(&apos;end&apos;,function()&#123;</div><div class="line">        var data = filterBlogInfo(html)</div><div class="line">        printBlogInfo(data)</div><div class="line">    &#125;)</div><div class="line">&#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">    console.log(&apos;获取数据出错&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>运行结果如图：<br><img src="https://github.com/hardhpp/Node/blob/master/crawler/picture/picture3.png?raw=true" alt=""></p>
<h3 id="cheerio模块简单介绍"><a href="#cheerio模块简单介绍" class="headerlink" title="cheerio模块简单介绍"></a>cheerio模块简单介绍</h3><p>cheerio模块不是Node的原生模块，需要安装<br>安装：<code>npm install cheerio</code>    </p>
<p>cheerio模块是为服务器特别定制的，快速、灵活、实施的jQuery核心实现。  </p>
<ol>
<li><strong>相似的语法:</strong> Cheerio 包括了 jQuery 核心的子集。Cheerio  从jQuery库中去除了所有 DOM不一致性和浏览器尴尬的部分，揭示了它真正优雅的API。</li>
<li><strong>闪电般的块:</strong> Cheerio 工作在一个非常简单，一致的DOM模型之上。解析，操作，呈送都变得难以置信的高效。基础的端到端的基准测试显示Cheerio 大约比JSDOM快八倍(8x)。 </li>
<li><strong>巨灵活:</strong> Cheerio 封装了兼容的htmlparser。Cheerio 几乎能够解析任何的 HTML 和 XML document。</li>
</ol>
<p>使用：<br>step1: 需要加载HTML    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var html = &apos;&lt;ul id=&quot;fruits&quot;&gt;...&lt;/ul&gt;&apos;</div><div class="line">var $ = cheerio.load(html)</div></pre></td></tr></table></figure>
<p>step2: 使用选择器，选择需要处理的元素  <code>$(selectior,[context],[root])</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 选择器在 Context 范围内搜索，Context又在Root范围内搜索</div><div class="line">$(&apos;.apple&apos;, &apos;#fruits&apos;)</div><div class="line">// selector 和 context可以是一个字符串表达式</div><div class="line">$(&apos;#fruits .apple&apos;)</div><div class="line"></div><div class="line">// 使用find()</div><div class="line">$(&apos;#fruits&apos;).find(&apos;.apple&apos;)</div><div class="line">// 使用parent()</div><div class="line">$(&apos;.apple&apos;).parent()</div></pre></td></tr></table></figure>
<p>step3: 获得和修改相应的属性     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&apos;.apple&apos;, &apos;#fruits&apos;).val([value])</div><div class="line">$(&apos;#fruits .apple&apos;).text([textString])</div><div class="line">$(&apos;#fruits .apple&apos;).attr(name,value)</div><div class="line">$(&apos;#fruits .apple&apos;).addClass(&apos;.red&apos;)</div></pre></td></tr></table></figure>
<h2 id="Step3：多页面爬虫"><a href="#Step3：多页面爬虫" class="headerlink" title="Step3：多页面爬虫"></a>Step3：多页面爬虫</h2><p>在Step2中，我们已经可以爬取最终所需要的数据，不过，现在爬取的数据仅仅是第一页的数据，我们还需要爬取其他页的数据。</p>
<p>现在，为了获取其他页面的数据，我们需要获取其他页面的url。</p>
<p>为此，我们可以分析页面：<br><img src="https://github.com/hardhpp/Node/blob/master/crawler/picture/picture4.png?raw=true" alt=""></p>
<p>观察页面可得，我们可以通过拼接url，获取每个页面的url。</p>
<p>具体程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">// app03.js</div><div class="line">var http = require(&apos;http&apos;)</div><div class="line">var cheerio = require(&apos;cheerio&apos;)</div><div class="line">var url = &apos;http://xgfe.github.io/&apos;</div><div class="line"></div><div class="line">var urlArr = url.split(&apos;&apos;)</div><div class="line">urlArr.splice(-1)</div><div class="line">var rootUrl = urlArr.join(&apos;&apos;)</div><div class="line"></div><div class="line">// 获取分页的url</div><div class="line">function fetchPageUrl(html) &#123;</div><div class="line"></div><div class="line">    var $ = cheerio.load(html)</div><div class="line">    var blogPageTotal = $(&apos;#content .pagination .page-number&apos;).eq(2)</div><div class="line">    var blogPageHref = blogPageTotal.attr(&apos;href&apos;).split(&apos;&apos;)</div><div class="line">    blogPageHref.splice(-2)</div><div class="line">    var blogPageTotalNumber = parseInt(blogPageTotal.text()) </div><div class="line">    var pageUrl =  [url]</div><div class="line"></div><div class="line">    for(var i=2; i &lt;= blogPageTotalNumber; i++)&#123;</div><div class="line">        pageUrl.push(rootUrl + blogPageHref.join(&apos;&apos;)+i+&apos;/&apos;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return pageUrl</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 打印数据</div><div class="line">function printPageUrl(pageUrl) &#123;</div><div class="line"></div><div class="line">    pageUrl.forEach(function (item, index) &#123;</div><div class="line">        console.log(item)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取页面源代码</div><div class="line">http.get(url,function(res)&#123;</div><div class="line">    var html = &apos;&apos;;</div><div class="line"></div><div class="line">    res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">        html+=data;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    res.on(&apos;end&apos;,function()&#123;</div><div class="line">        var data = fetchPageUrl(html)</div><div class="line">        printPageUrl(data)</div><div class="line">    &#125;)</div><div class="line">&#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">    console.log(&apos;获取数据出错&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>运行结果：<br><img src="https://github.com/hardhpp/Node/blob/master/crawler/picture/picture5.png?raw=true" alt=""></p>
<p>所以，在获取到所有的url之后，可以按照Step2进行获取数据。<br>此时，<strong>出现一个问题！</strong></p>
<p>我们需要访问完一个页面之后，再去访问另外一个，此时，需要用到回调，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">// 第一层：获取所有页面的url</div><div class="line">http.get(url1,function(res)&#123;</div><div class="line">    var html = &apos;&apos;;</div><div class="line"></div><div class="line">    res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">        html+=data;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    res.on(&apos;end&apos;,function()&#123;</div><div class="line">        var data1 = filterPageUrl(html)</div><div class="line">        printPageUrl(data1)</div><div class="line">        </div><div class="line">        // 第二层： 获取第一个页面的源代码并处理</div><div class="line">        http.get(url2,function(res)&#123;</div><div class="line">            var html = &apos;&apos;;</div><div class="line">        </div><div class="line">            res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">                html+=data;</div><div class="line">            &#125;)</div><div class="line">            </div><div class="line">            res.on(&apos;end&apos;,function()&#123;</div><div class="line">                var data2 = filterBlogInfo(html)</div><div class="line">                printBlogInfo(data2)</div><div class="line">                // 第三层： 获取第二个页面的源代码并处理</div><div class="line">                http.get(url3,function(res)&#123;</div><div class="line">                    var html = &apos;&apos;;</div><div class="line">                </div><div class="line">                    res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">                        html+=data;</div><div class="line">                    &#125;)</div><div class="line">                    res.on(&apos;end&apos;,function()&#123;</div><div class="line">                        var data3 = filterBlogInfo(html)</div><div class="line">                        printBlogInfo(data3)</div><div class="line">                        </div><div class="line">                        </div><div class="line">                        // **** 此处省略了6次回调 ****</div><div class="line">                        </div><div class="line">                        </div><div class="line">                    &#125;)</div><div class="line">                &#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">                    console.log(&apos;获取数据出错&apos;);</div><div class="line">                &#125;)</div><div class="line">            &#125;)</div><div class="line">        &#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">            console.log(&apos;获取数据出错&apos;);</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">    console.log(&apos;获取数据出错&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>问题：</strong> 单纯的使用回调，会形成回调地狱，此时，我们应该采用其他的方式进行优化。</p>
<p><strong>解决方法：采用promise</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">// app04.js</div><div class="line">var http = require(&apos;http&apos;)</div><div class="line">var cheerio = require(&apos;cheerio&apos;)</div><div class="line">var url = &apos;http://xgfe.github.io/&apos;</div><div class="line"></div><div class="line">var urlArr = url.split(&apos;&apos;)</div><div class="line">urlArr.splice(-1)</div><div class="line">var rootUrl = urlArr.join(&apos;&apos;)</div><div class="line"></div><div class="line">var index = 0</div><div class="line"></div><div class="line">// 获取分页的url</div><div class="line">function fetchPageUrl(html) &#123;</div><div class="line">    // 此处省略，与之前示例相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取内容</div><div class="line">function filterBlogInfo(html) &#123;</div><div class="line">    // 此处省略，与之前示例相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 打印数据</div><div class="line">function printBlogInfo (blogInfo) &#123;</div><div class="line">    // 此处省略，与之前示例相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getUrlAsync(url) &#123;</div><div class="line">    return new Promise(function (resolve, reject)&#123;</div><div class="line">        console.log(&apos;正在爬取： &apos; + url)</div><div class="line">        http.get(url, function(res)&#123;</div><div class="line">            var html = &apos;&apos;</div><div class="line">            res.on(&apos;data&apos;,function (data) &#123;</div><div class="line">                html += data</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">            res.on(&apos;end&apos;,function ()&#123;</div><div class="line">                resolve(html)</div><div class="line">            &#125;)</div><div class="line">        &#125;).on(&apos;error&apos;, function () &#123;</div><div class="line">            reject(e)</div><div class="line">            console.log(&apos;获取&apos; + url + &apos;页面数据出错!&apos;)</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取页面源代码</div><div class="line">http.get(url,function(res)&#123;</div><div class="line">    var html = &apos;&apos;;</div><div class="line"></div><div class="line">    res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">        html+=data;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    res.on(&apos;end&apos;,function()&#123;</div><div class="line">        var URLs = fetchPageUrl(html)</div><div class="line">        </div><div class="line">        var fetchPageDataArray = []</div><div class="line"></div><div class="line">        URLs.forEach(function (url) &#123;</div><div class="line">            fetchPageDataArray.push(getUrlAsync(url))</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        // 执行promise </div><div class="line">        Promise</div><div class="line">            .all(fetchPageDataArray)</div><div class="line">            .then(function (pages) &#123;</div><div class="line">                pages.forEach( function (pageItem)&#123;</div><div class="line">                    printBlogInfo(filterBlogInfo(pageItem))</div><div class="line">                &#125;)</div><div class="line">            &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">    console.log(&apos;获取数据出错&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>运行结果：与Step2相似，获取了全部的数据。（图略）</p>
<h3 id="promise简单介绍"><a href="#promise简单介绍" class="headerlink" title="promise简单介绍"></a>promise简单介绍</h3><p>先来回顾一下promise的基本概念：</p>
<ul>
<li>promise只有三种状态，未完成，完成(fulfilled)和失败(rejected)。</li>
<li>promise的状态可以由未完成转换成完成，或者未完成转换成失败。</li>
<li>promise的状态转换只发生一次</li>
</ul>
<p>方法：<br>1.Promise.then 接受3个函数作为参数。前两个函数对应promise的两种状态fulfilled, rejected的回调函数。第三个函数用于处理进度信息。 </p>
<p>2.Promise.all 接收一个 promise对象的数组作为参数，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用 .then 方法。</p>
<p>使用promise的好处：</p>
<ul>
<li>链式处理，方便之后的代码维护</li>
<li>在Promise.all中进行并发处理，避免阻塞</li>
</ul>
<h2 id="Step4：保存为文件"><a href="#Step4：保存为文件" class="headerlink" title="Step4：保存为文件"></a>Step4：保存为文件</h2><p>在Step3中，运行之后，会输出特别多的信息，这样，不仅不容易观察最终数据，也不利于后期的再处理（例如：哪个作者发表的文章最多、哪个类型的文章发表最多之类的统计）。所以，我们可以将最终输出的结果保存在文件中。</p>
<p>在node中，fs模块负责文件的操作。</p>
<p>现在，我们引入fs模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">// app05.js</div><div class="line">var http = require(&apos;http&apos;)</div><div class="line">var cheerio = require(&apos;cheerio&apos;)</div><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line">var url = &apos;http://xgfe.github.io/&apos;</div><div class="line"></div><div class="line">var urlArr = url.split(&apos;&apos;)</div><div class="line">urlArr.splice(-1)</div><div class="line">var rootUrl = urlArr.join(&apos;&apos;)</div><div class="line"></div><div class="line">var index = 0</div><div class="line">var dataStr = &quot;&quot;</div><div class="line"></div><div class="line">// 获取分页的url</div><div class="line">function fetchPageUrl(html) &#123;</div><div class="line">    // 此处省略，与之前示例相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取内容</div><div class="line">function filterBlogInfo(html) &#123;</div><div class="line">    // 此处省略，与之前示例相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 打印数据</div><div class="line">function printBlogInfo (blogInfo) &#123;</div><div class="line"></div><div class="line">    var blogInfoStr = &apos;&apos;</div><div class="line">    blogInfo.forEach(function (item) &#123;</div><div class="line">        blogInfoStr += (index++) + &apos;\n&apos;</div><div class="line">        blogInfoStr += &apos;题目： &apos; + item.blogTitle + &apos;\n&apos;</div><div class="line">        blogInfoStr += &apos;链接： &apos; + item.blogHref + &apos;\n&apos;</div><div class="line">        blogInfoStr += &apos;时间： &apos; + item.blogTime + &apos;\n&apos;</div><div class="line">        blogInfoStr += &apos;作者： &apos; + item.blogAuthor + &apos;\n&apos;</div><div class="line">        blogInfoStr += &apos;关键字： &apos;</div><div class="line">        item.blogKeywords.forEach( function (tagItem) &#123;</div><div class="line">            blogInfoStr += tagItem + &apos; &apos;</div><div class="line">        &#125;)</div><div class="line">        blogInfoStr += &quot;\n简介：&quot; + item.blogAbstract +&apos;\n\n&apos;</div><div class="line">    &#125;)</div><div class="line">    return blogInfoStr</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getUrlAsync(url) &#123;</div><div class="line">	// 此处省略，与之前示例相同</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取页面源代码</div><div class="line">http.get(url,function(res)&#123;</div><div class="line">    var html = &apos;&apos;;</div><div class="line"></div><div class="line">    res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">        html+=data;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    res.on(&apos;end&apos;,function()&#123;</div><div class="line">        var URLs = fetchPageUrl(html)</div><div class="line">        </div><div class="line">        var fetchPageDataArray = []</div><div class="line"></div><div class="line">        URLs.forEach(function (url) &#123;</div><div class="line">            fetchPageDataArray.push(getUrlAsync(url))</div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        // 执行promise</div><div class="line">        Promise</div><div class="line">            .all(fetchPageDataArray)</div><div class="line">            .then(function (pages) &#123;</div><div class="line">                pages.forEach( function (pageItem)&#123;</div><div class="line">                    dataStr += printBlogInfo(filterBlogInfo(pageItem))</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">                // 写入文件</div><div class="line">                fs.writeFile(&apos;data.txt&apos;, dataStr, function (err) &#123;</div><div class="line">                    if (err) console.log(&apos;write error&apos;)</div><div class="line">                    console.log(&apos;file saved!&apos;)</div><div class="line">                &#125;)</div><div class="line">            &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">    console.log(&apos;获取数据出错&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="fs模块简单介绍"><a href="#fs模块简单介绍" class="headerlink" title="fs模块简单介绍"></a>fs模块简单介绍</h3><p>fs模块用于对系统文件及目录进行读写操作。</p>
<p><strong>读文件</strong> </p>
<p>1.异步读文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">fs.readFile(&apos;simple.txt&apos;, &apos;utf-8&apos;, function (err, data)&#123; </div><div class="line">    if (err) &#123;</div><div class="line">        // 出错了</div><div class="line">    &#125; else &#123;</div><div class="line">        // 处理文件数据</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>异步读取文件时，传入的回调函数接收两个参数。<br>1) 当正常读取时，err参数为null，data参数为读取到的String;<br>2) 当读取发生错误时，err参数代表一个错误对象，data为undefined。<br>当读取二进制文件时，不传入文件编码，回调函数的data参数将返回一个Buffer对象。</p>
<p><strong>扩展：Buffer对象与String对象转换：</strong><br>Buffer对象 -&gt; String对象: <code>var str = buf.toString(&#39;utf-8&#39;)</code><br>String对象 -&gt; Buffer对象: <code>var buf = Buffer.from(str, &#39;utf-8&#39;)</code></p>
<p>2.同步读文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line">var data = fs.readFileSync(&apos;simple.txt&apos;, &apos;utf-8&apos;)</div></pre></td></tr></table></figure>
<p>同步读文件时，读取到的数据被直接返回,需要使用<strong>try…catch</strong>捕获错误。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    var data = fs.readFileSync(&apos;simple.txt&apos;, &apos;utf-8&apos;)</div><div class="line">&#125; catch (err) &#123;</div><div class="line">    // 出错了</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>写文件</strong><br>1.异步写文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">var data = &apos;write something.&apos;</div><div class="line">fs.writeFile(&apos;output.txt&apos;, data, function (err)&#123;</div><div class="line">    if (err) &#123;</div><div class="line">        // 出错了</div><div class="line">    &#125; else&#123;</div><div class="line">        // 写文件成功</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>writeFile()</code>的参数依次为文件名、数据和回调函数。<br>如果传入的数据是String,默认按<code>UTF-8</code>编码写入文件；<br>如果传入的参数是Buffer,则写入的是二进制文件。</p>
<p>2.同步写文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)  </div><div class="line"></div><div class="line">var data = &apos;write something again.&apos;  </div><div class="line">fs.writeFileSync(&apos;output.txt&apos;, data)</div></pre></td></tr></table></figure>
<p><strong>获取文件信息</strong></p>
<p>Stats对象：包含文件或目录的详细信息，例如：文件大小、创建时间等信息。<br>Stats对象具有的属性和方法：<br><code>size                        // 文件大小</code><br><code>birthtime                   // 文件的创建时间，Date对象</code><br><code>mtime                       // 文件的修改时间，Date对象</code><br><code>isFile()                    // 如果是文件返回true，否则返回false</code><br><code>isDirectory()               // 如果是目录返回true，否则返回false</code>    </p>
<p>1.异步获取文件信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">fs.stat(&apos;simple.txt&apos;, function (err, stat) &#123;</div><div class="line">    if (err) &#123;</div><div class="line">        // 出错了</div><div class="line">    &#125; else &#123;</div><div class="line">        // 获取文件信息</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>2.同步获取文件信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">var stat = fs.statSync(&apos;simple.txt&apos;)</div></pre></td></tr></table></figure>
<p><strong>异步or同步</strong><br>绝大部分需要再服务器运行期反复执行业务逻辑的代码，必须使用<strong>异步代码</strong>，避免同步代码在执行期间，服务器停止响应，因为JavaScript只有一个执行线程。<br>服务器启动时如果需要读取配置文件，或结束时需要写入到状态文件时，可以使用<strong>同步代码</strong>，因为这些代码只在启动和结束时执行一次，不影响服务器正常运行时的异步执行。  </p>
<p><strong>从文件流读取文件</strong><br><strong>关于流</strong><br>在Node.js中，流是一个对象，拥有以下事件：<br>data事件 表示流的数据已经可以读取；<br>end事件 表示这个流已经到末尾，没有数据可以读取；<br>error事件 表示出错了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;</div><div class="line"></div><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">// 打开一个流</div><div class="line">var rs = fs.createReadStream(&apos;sample.txt&apos;, &apos;utf-8&apos;)</div><div class="line"></div><div class="line">rs.on(&apos;data&apos;,function (chunk) &#123;</div><div class="line">    // 数据已经可以读取</div><div class="line">&#125;)</div><div class="line"></div><div class="line">rs.on(&apos;end&apos;, function () &#123;</div><div class="line">    // 数据已经读取到末尾，没有数据可以读取</div><div class="line">&#125;)</div><div class="line"></div><div class="line">rs.on(&apos;error&apos;, function (err) &#123;</div><div class="line">    // 读取数据发生错误</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>data事件可能会有很多次，每次传递的chunk是流的一部分数据。</p>
<p><strong>以流的形式写入文件</strong></p>
<p><strong>注意：</strong>以流的形式写入文件，可以不断调用write()方法，最后以end()结束。</p>
<ol>
<li>写入文本数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;</div><div class="line"></div><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">var ws1 = fs.createWriteStream(&apos;output1.txt&apos;, &apos;utf-8&apos;)</div><div class="line">ws1.write(&apos;使用Stream写入文本数据...\n&apos;)</div><div class="line">ws1.write(&apos;END.&apos;)</div><div class="line">ws1.end()</div></pre></td></tr></table></figure>
<ol>
<li>写入二进制数据</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">‘use strict’</div><div class="line"></div><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">var ws2 = fs.createWriteStream(&apos;output2.txt&apos;)</div><div class="line">ws2.write(new Buffer(&apos;使用Stream写入二进制数据...\n&apos;, &apos;utf-8&apos;))</div><div class="line">ws2.write(new Buffer(&apos;END.&apos;, &apos;UTF-8&apos;))</div><div class="line">ws2.end()</div></pre></td></tr></table></figure>
<p>所有可以读取数据的流都继承自stream.Readable，所有可以写入的流都继承自stream.Writable。</p>
<p><strong>复制文件pipe</strong><br>一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。<br>在Node.js中，Readable流有一个pipe()方法，pipe()把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;</div><div class="line"></div><div class="line">var fs = require(&apos;fs&apos;)</div><div class="line"></div><div class="line">var rs = fs.createReadStream(&apos;sample.txt&apos;)</div><div class="line">var ws = fs.createWriteStream(&apos;copied.txt&apos;)</div><div class="line"></div><div class="line">rs.pipe(ws)</div></pre></td></tr></table></figure>
<p>默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数:<code>readable.pipe(writable, { end: false });</code></p>
<h2 id="Step5：完整的爬虫程序"><a href="#Step5：完整的爬虫程序" class="headerlink" title="Step5：完整的爬虫程序"></a>Step5：完整的爬虫程序</h2><p><a href="https://github.com/hardhpp/Node/tree/master/crawler" target="_blank" rel="external">程序示例</a></p>
<blockquote>
<p>相关参考<br><a href="http://www.imooc.com/learn/348" target="_blank" rel="external">慕课视频</a><br><a href="http://blog.csdn.net/hard_hpp/article/details/77181681" target="_blank" rel="external">Node.js 实现爬虫（1） —— 简单的爬虫程序</a><br><a href="http://blog.csdn.net/hard_hpp/article/details/77247326" target="_blank" rel="external">Node.js 实现爬虫（2） —— 多页面的爬虫程序</a><br><a href="http://blog.csdn.net/hard_hpp/article/details/77248298" target="_blank" rel="external">Node.js 实现爬虫（3） —— 保存爬取的数据</a><br><a href="http://cnodejs.org/topic/5203a71844e76d216a727d2e" target="_blank" rel="external">cheerio API</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node学习系列(1) – 使用Node实现爬虫，介绍了如何实现一个简单的爬虫程序、多页面的爬虫程序、如何保存爬虫的结果等内容。&lt;/p&gt;
    
    </summary>
    
      <category term="hardhpp" scheme="http://xgfe.github.io/categories/hardhpp/"/>
    
    
      <category term="Node" scheme="http://xgfe.github.io/tags/Node/"/>
    
      <category term="爬虫" scheme="http://xgfe.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Epoxy：构建复杂页面的框架（一）</title>
    <link href="http://xgfe.github.io/2018/01/04/lwp/Epoxy_RecyclerView_1/"/>
    <id>http://xgfe.github.io/2018/01/04/lwp/Epoxy_RecyclerView_1/</id>
    <published>2018-01-04T06:13:36.000Z</published>
    <updated>2018-03-20T03:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅从宏观上介绍了 Epoxy 的特色和优势，并说明了基本使用步骤。</p>
<p>Epoxy 是由 Airbnb 团队开发的 ，以简化使用 <code>RecyclerView</code> 的过程，并添加了必要的缺失功能。Airbnb 在他们的应用中的大部分页面上使用 Epoxy ，这大大提高了开发人员的经验。</p>
<a id="more"></a>
<p>Epoxy（环氧树脂）是一个Android库，用于在 <code>RecyclerView</code> 中构建复杂的页面。界面模型是通过自定义视图、数据绑定布局或 Litho 组件通过注释处理自动生成的。这些模型会在 <code>EpoxyController</code> 中用于声明在 <code>RecyclerView</code> 中显示哪些项目。</p>
<p>这将抽象化 <code>ViewHolder</code> 的样板，区分项目和绑定有效负载变化，项目类型，项目ID，跨度计数等等，以简化具有多种视图类型的构建屏幕。此外，Epoxy 增加了对保存视图状态和自动比较项目变化的支持。</p>
<h2 id="Epoxy-的特点"><a href="#Epoxy-的特点" class="headerlink" title="Epoxy 的特点"></a>Epoxy 的特点</h2><p>Android 中的 RecyclerView 是一个显示列表的强大工具，但是它的用法比较琐碎。显示复杂度高的列表是我们团队的一个常用需求，比如具有多种视图类型，分页功能，支持平板和 item 动画的列表。我们发现自己总是不断的重复相同的设置。所以 Airbnb 开发了 Epoxy 来减轻这个趋势，以简化基于列表的视图的创建，加载静态或者动态的内容。</p>
<p>Epoxy 采用可组合的方式来创建列表。列表中的每个 item 由一个 Model 代表，Model 定义了 item 的布局，id 以及 span。Model 还负责处理数据到视图的绑定，在视图被回收的时候释放资源。如果要显示这些 Model 则把它们添加到 Epoxy 的 Adapter 中，Adapter 为你处理复杂的显示问题。</p>
<h3 id="追踪-Item-变化"><a href="#追踪-Item-变化" class="headerlink" title="追踪 Item 变化"></a>追踪 Item 变化</h3><p>Epoxy 通过在 Models 中使用一种 Diffing 算法帮你解决了这个问题。只要你改变了 Model 的设置，Epoxy 就会找到变化然后通知 RecyclerView。这简化了你的 Adapter ，提高了性能，还顺便提供了 Item Change 动画。</p>
<p>这个 Diffing 算法依赖于每个 Model 实现了 HashCode，这样当一个 Model 发生变化的时候就可以被检测到。Epoxy 提供了一个注解处理器，这样你的 Model 就可以为那些能代表 Model 状态的成员添加注解。一个生成的 subclass 可以为你实现正确的 HashCode 方法，同时为每个成员变量生成getter &amp; setter 方法。</p>
<p>你还会注意到这个 Model 实现了getDefaultLayout() 来返回一个布局资源。这个资源用于 inflate 传递给 model bind 方法的 view，bind 方法中把数据设置到 view 上。另外，在 Adapter 中 layout（资源id）还被用作这个 item 的 view type id。</p>
<h3 id="Stable-IDs-By-Default"><a href="#Stable-IDs-By-Default" class="headerlink" title="Stable IDs By Default"></a>Stable IDs By Default</h3><p>为了让功能正常工作，Epoxy默认启用了RecyclerView的stable id（要了解什么是stable id，参见RecyclerView Adapter的setHasStableIds(boolean hasStableIds)方法）。</p>
<p>这使得diffing，item动画以及状态保存成为可能，每个model负责定义它的id,我们为动态生成的model手动设置id。比如每个neighborhood carousel model用网络请求中的neighborhood对象提供的id设置。</p>
<p>静态视图比如header就要复杂点。它没有一个固有的id与之关联，因此我们需要制作一个。Epoxy为每个新创建的model自动生成一个id。这个id可以保证在app生命周期中不会和其他生成的model id重复，而负id被用来避免和手动设置的id重复。</p>
<h3 id="保存-View-的状态"><a href="#保存-View-的状态" class="headerlink" title="保存 View 的状态"></a>保存 View 的状态</h3><p>Epoxy还添加了对保存视图状态的支持，这是默认的RecyclerView所缺乏的。比如，上面search设计中的carousels是可以横向滑动的，为了更好的用户体验我们想保存这个carousel的滚动位置。如果用户向下滚动之后再回到这里时他们应该看到carousel保持了原来的状态。类似的，如果他们旋转手机或者切换app之后再回来，尽管activity发生了重建，我们还是应该呈现出相同的状态。</p>
<p>如果使用普通的RecyclerView adapter这就难以实现了。Epoxy支持保存任意model的view状态，为了做到这点，它是用了stable ids把view的状态和model id联系起来。</p>
<p>要保存view的状态只需再model中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> shouldSaveViewState &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Epoxy将在它离开屏幕的时候保存自己的状态，并在返回的时候恢复。默认这个设置为false，这样内存和滚动的性能就不会因为保存了不必要的视图状态而受影响。</p>
<h3 id="Epoxy在静态内容中的应用"><a href="#Epoxy在静态内容中的应用" class="headerlink" title="Epoxy在静态内容中的应用"></a>Epoxy在静态内容中的应用</h3><p>RecyclerView通常用于显示从远程数据（比如网络或者数据库）加载的动态内容，否则使用scrollview要简单些。但是Epoxy可以让RecyclerView的使用和ScrollView一样简单，我们的详情界面就是这样做的。</p>
<p>这种效果使用ScrollView来实现可能是最简单的。但是我们使用Epoxy配合RecyclerView可以得到更快的加载速度，也更容易实现动画。</p>
<p>性能对我们来说至关重要，这个页面通常在用户搜索的时候展示，用户点击一个搜索结果的图片，然后使用共享元素动画切换到详情页面，为了让搜索体验良好，动画必须流畅，因此details view的加载必须非常快。</p>
<p>让我们仔细看看这个view了解为什么它们会影响性能。首先，最顶上的图片实际是一个横向的RecyclerView，这样用户就能滑动查看房间的图片。在中间我们有一张静态的地图显示房源的位置，而在底部我们还有另一个RecyclerView，显示该地区的类似房源。而在这三个比较大的视图中间还穿插着一些文字信息和小图片。</p>
<p>这些加在一起就得到了一个带有很多位图的非常复杂的结构。这使得测量和布局的过程要花更长的时间，同时还需要更多的内存来加载图片。</p>
<p>另外，我们还从不同的渠道加载数据－databases, in-memory caches, 以及多个网络请求。这对为用户显示即时数据有好处，但是如果处理不好也会增加更多的时间开销。</p>
<p>庞大的视图结构，多个bitmap，多个view刷新，这些要求使得我们有足够的理由去关注性能问题。多亏了Epoxy我们可以在兼顾这些考虑的情况下也能提供很棒的用户体验。这是因为：</p>
<p>因为我们使用的是RecyclerView，当用户首次打开这个屏幕的时候只有一小部分视图被加载。避免了过早的加载map图片，底部的画廊以及它们之间的所有视图。这就使得布局更快，内存使用更小，过度动画更流畅。</p>
<p>当新数据被加载的时候我们无需反复的刷新view，减小了丢帧的概率。如果遇到类似的列表请求，而那个carousel不在屏幕上，我们什么夜不用做。如果价格发生了变换，Epoxy只是更新价格标签。这增加了进入动画的流畅度，同时防止用户滚动的时候丢帧。</p>
<p>自带Item change动画。当数据发生变化的时候我们可以以相应的动画显示，隐藏或者更新view。比如，点击翻译按钮可以插入一个加载器，当加载完成再过渡到翻译后的text，这避免了突兀的变化。</p>
<h2 id="项目中引入-Epoxy"><a href="#项目中引入-Epoxy" class="headerlink" title="项目中引入 Epoxy"></a>项目中引入 Epoxy</h2><p>使用 gradle 依赖 Epoxy 和 Annotation Processor，目前最新版本为 2.8.0 。 <a href="https://github.com/airbnb/epoxy/releases/latest" target="_blank" rel="external">查看最新版本</a></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">  implementation <span class="string">'com.airbnb.android:epoxy:2.8.0'</span></div><div class="line">  <span class="comment">// 依赖 Epoxy 的注解处理工具</span></div><div class="line">  annotationProcessor <span class="string">'com.airbnb.android:epoxy-processor:2.8.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><p>Epoxy 有两个主要的组件，各司其职：</p>
<ol>
<li><code>EpoxyModel</code>：负责列表项的样式和数据；</li>
<li><code>EpoxyController</code>：负责列表中如何排列各种类型的 <code>EpoxyModel</code> 来显示列表项和数据。</li>
</ol>
<h3 id="1-创建-EpoxyModel"><a href="#1-创建-EpoxyModel" class="headerlink" title="1. 创建 EpoxyModel"></a>1. 创建 EpoxyModel</h3><p>Epoxy 根据你设置的自定义控件或布局文件来构造一个 Model 类，这个自动生成的类使用 <code>_</code> 作为类名的后缀，在 <code>EpoxyController</code> 中应该使用这个自动生成的类。</p>
<p>下面是创建 <code>EpoxyModel</code> 类的三种方法：</p>
<h4 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h4><p>通过自定义控件创建 <code>EpoxyModel</code> 的步骤如下：</p>
<ul>
<li>首先按照普通的自定义控件的方法创建一个 View 的子类；</li>
<li>然后在类名上添加注解 <code>@ModelView</code> ；</li>
<li>在需要作为 <code>EpoxyModel</code> 的属性的 setter 方法上添加 “prop” 注解（<code>@TextProp</code>、<code>@ModelProp</code>、<code>@CallbackProp</code>）。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ModelView</span>(autoLayout = Size.MATCH_WIDTH_WRAP_HEIGHT)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</div><div class="line"></div><div class="line">  ... <span class="comment">// Initialization omitted</span></div><div class="line"></div><div class="line">  <span class="meta">@TextProp</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(CharSequence text)</span> </span>&#123;</div><div class="line">    titleView.setText(text);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>项目 Rebuild 后，将会生成类 <code>HeaderViewModel_</code>，包名与 <code>HeaderView</code> 相同。</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>如果使用了 Android 的 DataBinding，你可以使用类似下面的简单方法创建布局：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">type</span>=<span class="string">"String"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"120dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"40dp"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"@&#123;title&#125;"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后, 在任意合适的包中创建 <code>package-info.java</code> 文件，并添加注解 <code>@EpoxyDataBindingLayouts</code> 指定以上布局.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EpoxyDataBindingLayouts</span>(&#123;R.layout.header_view, ... <span class="comment">// other layouts &#125;)</span></div><div class="line"><span class="keyword">package</span> com.airbnb.epoxy.sample;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.airbnb.epoxy.EpoxyDataBindingLayouts;</div><div class="line"><span class="keyword">import</span> com.airbnb.epoxy.R;</div></pre></td></tr></table></figure>
<p>项目 Rebuild 后，将会生成类 <code>HeaderViewBindingModel_</code>。</p>
<h4 id="ViewHolder-方式"><a href="#ViewHolder-方式" class="headerlink" title="ViewHolder 方式"></a>ViewHolder 方式</h4><p>使用 xml 布局来创建 <code>EpoxyModel</code> ，可以继承 <code>EpoxyModelWithHolder</code> 创建一个抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EpoxyModelClass</span>(layout = R.layout.header_view)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderModel</span> <span class="keyword">extends</span> <span class="title">EpoxyModelWithHolder</span>&lt;<span class="title">Holder</span>&gt; </span>&#123;</div><div class="line">  <span class="meta">@EpoxyAttribute</span> String title;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Holder holder)</span> </span>&#123;</div><div class="line">    holder.header.setText(title);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> <span class="keyword">extends</span> <span class="title">BaseEpoxyHolder</span> </span>&#123;</div><div class="line">    <span class="meta">@BindView</span>(R.id.text) TextView header;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>项目 Rebuild 后，会生成类 <code>HeaderModel_</code>，继承了抽象类 <code>HeaderModel</code> 并实现了其抽象方法。<code>HeaderModel</code> 中标注了 <code>@EpoxyAttribute</code> 注解的成员变量，会在 <code>HeaderModel_</code> 中生成 getter &amp; setter 方法。</p>
<h3 id="2-创建-EpoxyController"><a href="#2-创建-EpoxyController" class="headerlink" title="2. 创建 EpoxyController"></a>2. 创建 EpoxyController</h3><p>Epoxy 的控制器可以指定列表显示的项目类型、数量和顺序，同时指定每个项目的数据。</p>
<p>在最重要的 <code>buildModels</code> 方法中，我们可以添加每一项 model ，这个方法会在我们每次调用 <code>requestModelBuild</code> 方法更新数据后被触发，Epoxy 跟踪模型中的变化，并自动绑定和更新视图。</p>
<p>下面的例子中，列表有一个头部，大量的照片列表项，最后是加载更多条。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoController</span> <span class="keyword">extends</span> <span class="title">Typed2EpoxyController</span>&lt;<span class="title">List</span>&lt;<span class="title">Photo</span>&gt;, <span class="title">Boolean</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@AutoModel</span> HeaderModel_ headerModel;</div><div class="line">    <span class="meta">@AutoModel</span> LoaderModel_ loaderModel;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">buildModels</span><span class="params">(List&lt;Photo&gt; photos, Boolean loadingMore)</span> </span>&#123;</div><div class="line">      headerModel</div><div class="line">          .title(<span class="string">"My Photos"</span>)</div><div class="line">          .description(<span class="string">"My album description!"</span>)</div><div class="line">          .addTo(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (Photo photo : photos) &#123;</div><div class="line">        <span class="keyword">new</span> PhotoModel()</div><div class="line">           .id(photo.id())</div><div class="line">           .url(photo.url())</div><div class="line">           .addTo(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      loaderModel</div><div class="line">          .addIf(loadingMore, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="3-整合到-RecyclerView"><a href="#3-整合到-RecyclerView" class="headerlink" title="3. 整合到 RecyclerView"></a>3. 整合到 RecyclerView</h3><p>列表控件既可以使用 Android Support Library 中的 <code>RecyclerView</code>，也可以使用 Epoxy 提供的 <code>EpoxyRecyclerView</code>。推荐使用后者，更加简便。</p>
<h4 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MyController controller = <span class="keyword">new</span> MyController();</div><div class="line">recyclerView.setAdapter(controller.getAdapter());</div><div class="line"></div><div class="line"><span class="comment">// Request a model build whenever your data changes</span></div><div class="line">controller.requestModelBuild();</div><div class="line"></div><div class="line"><span class="comment">// Or if you are using a TypedEpoxyController</span></div><div class="line">controller.setData(myData);</div></pre></td></tr></table></figure>
<h4 id="EpoxyRecyclerView"><a href="#EpoxyRecyclerView" class="headerlink" title="EpoxyRecyclerView"></a>EpoxyRecyclerView</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">epoxyRecyclerView.setControllerAndBuildModels(<span class="keyword">new</span> MyController());</div><div class="line"></div><div class="line"><span class="comment">// Request a model build on the recyclerview when data changes</span></div><div class="line">epoxyRecyclerView.requestModelBuild();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>非常感谢 Airbnb 和其他开发者对此开源项目的贡献，让我们得以体验到全新的列表开发方式，并享受到了 Epoxy 的注解处理器、Diffing 算法以及通用工具带给我们的方便。</p>
<p>本文仅从宏观上介绍了 Epoxy 的基本使用步骤，敬请期待后续文章，介绍 Epoxy 的更多细节。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/airbnb/epoxy" target="_blank" rel="external">GitHub - Airbnb/Epoxy</a></li>
<li><a href="https://github.com/airbnb/epoxy/wiki" target="_blank" rel="external">Epoxy Wiki</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文仅从宏观上介绍了 Epoxy 的特色和优势，并说明了基本使用步骤。&lt;/p&gt;
&lt;p&gt;Epoxy 是由 Airbnb 团队开发的 ，以简化使用 &lt;code&gt;RecyclerView&lt;/code&gt; 的过程，并添加了必要的缺失功能。Airbnb 在他们的应用中的大部分页面上使用 Epoxy ，这大大提高了开发人员的经验。&lt;/p&gt;
    
    </summary>
    
      <category term="lwp" scheme="http://xgfe.github.io/categories/lwp/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="Epoxy" scheme="http://xgfe.github.io/tags/Epoxy/"/>
    
  </entry>
  
  <entry>
    <title>AbViewUtil屏幕适配方法</title>
    <link href="http://xgfe.github.io/2017/11/30/lwp/AbViewUtil/"/>
    <id>http://xgfe.github.io/2017/11/30/lwp/AbViewUtil/</id>
    <published>2017-11-30T06:34:30.000Z</published>
    <updated>2018-01-16T03:04:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>抛弃 google 提供的 dip 理论与多套图片与布局方案，采用与 UI 设计师通用的 px 作为标准单位，原理是将 UI 设计师的设计图与当前查看的手机或其他设备的屏幕像素尺寸进行换算，得到缩放比例，在 Activity 中装载布局时将所有布局的 px 尺寸进行缩放后设置给布局，就实现了一套尺寸在不同大小的设备上能够按照合理的比例进行缩放，达到万能适配的目的。</p>
<a id="more"></a>
<h1 id="AbViewUtil-实现屏幕适配"><a href="#AbViewUtil-实现屏幕适配" class="headerlink" title="AbViewUtil 实现屏幕适配"></a>AbViewUtil 实现屏幕适配</h1><p>AndroidBase 框架中有个 AbViewUtil 类，可以实现屏幕适配。</p>
<h2 id="一、适配原理"><a href="#一、适配原理" class="headerlink" title="一、适配原理"></a>一、适配原理</h2><p>Android 推荐使用 dp 作为长度单位，sp 作为字体大小单位，App 运行时会根据屏幕像素密度自动适配。但是这种适配并不适用于平板（大尺寸、小密度）和其他特殊尺寸的屏幕，所以为了适配它们就需要添加额外的布局和尺寸文件。</p>
<p>为了实现一套布局自动适配所有屏幕的目的，可以使用下面的方法。</p>
<h3 id="1-设计图尺寸"><a href="#1-设计图尺寸" class="headerlink" title="1. 设计图尺寸"></a>1. 设计图尺寸</h3><p>根据设计图尺寸，获取布局的基准宽、高。两者使用统一的单位 <code>px</code>。</p>
<h3 id="2-布局单位-px"><a href="#2-布局单位-px" class="headerlink" title="2. 布局单位 px"></a>2. 布局单位 px</h3><p>布局文件中各控件的长度单位和 TextView 的字体大小均采用设计图标注的 <code>px</code> 作为单位。</p>
<h3 id="3-加载布局"><a href="#3-加载布局" class="headerlink" title="3. 加载布局"></a>3. 加载布局</h3><ul>
<li>将设计图基准尺寸与当前手机屏幕的像素尺寸进行换算，得到缩放比例；</li>
<li>在装载布局时，将所有控件的 px 尺寸进行缩放后设置给布局；</li>
<li>如果是 TextView 及其子类，还会设置缩放后的字体大小；</li>
<li>这样就实现了按照合理的比例进行缩放，达到万能适配的目的。</li>
</ul>
<h3 id="4-适用场景"><a href="#4-适用场景" class="headerlink" title="4. 适用场景"></a>4. 适用场景</h3><ul>
<li>Activity</li>
<li>Fragment</li>
<li>Dialog</li>
<li>PopupWindow</li>
</ul>
<h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><p>下面介绍代码方面的使用方法。</p>
<h3 id="1-自定义设计图的屏幕尺寸"><a href="#1-自定义设计图的屏幕尺寸" class="headerlink" title="1. 自定义设计图的屏幕尺寸"></a>1. 自定义设计图的屏幕尺寸</h3><p>例如设计图为 720×1280，则修改 AbViewUtil 类中常量如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * UI设计的基准宽度.</div><div class="line"> */</div><div class="line">public static int UI_WIDTH = 720;</div><div class="line"></div><div class="line">/**</div><div class="line"> * UI设计的基准高度.</div><div class="line"> */</div><div class="line">public static int UI_HEIGHT = 1280;</div></pre></td></tr></table></figure>
<h3 id="2-Activity"><a href="#2-Activity" class="headerlink" title="2. Activity"></a>2. Activity</h3><p>需要在 Activity 的 <code>onCreate()</code> 方法中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">setContentView(R.layout.activity_main);</div><div class="line">//根据屏幕分辨率和屏幕密度自定缩放</div><div class="line">AbViewUtil.scaleCompat(</div><div class="line">    (LinearLayout) findViewById(R.id.act_main_root_layout)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>如果使用了 BaseActivity ，可以重写以下方法，实现子类 Activity 调用 setContentView() 方法时自动缩放布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 使用 &#123;@link AbViewUtil&#125; 处理</div><div class="line"> *</div><div class="line"> * @param layoutResID</div><div class="line"> * @see android.app.Activity#setContentView(int)</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</div><div class="line">    LayoutInflater inflater = LayoutInflater.from(this);</div><div class="line">    View root = inflater.inflate(layoutResID, null);</div><div class="line">    setContentView(root);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 使用 &#123;@link AbViewUtil&#125; 处理</div><div class="line"> *</div><div class="line"> * @param view</div><div class="line"> * @see android.app.Activity#setContentView(View)</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void setContentView(@NonNull View view) &#123;</div><div class="line">    super.setContentView(view);</div><div class="line">    AbViewUtil.scaleCompat(view);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 使用 &#123;@link AbViewUtil&#125; 处理</div><div class="line"> *</div><div class="line"> * @param view</div><div class="line"> * @param params</div><div class="line"> * @see android.app.Activity#setContentView(View, ViewGroup.LayoutParams)</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void setContentView(@NonNull View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">    super.setContentView(view, params);</div><div class="line">    AbViewUtil.scaleCompat(view);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 使用 &#123;@link AbViewUtil&#125; 处理</div><div class="line"> *</div><div class="line"> * @param view</div><div class="line"> * @param params</div><div class="line"> * @see android.app.Activity#addContentView(View, ViewGroup.LayoutParams)</div><div class="line"> */</div><div class="line">@Override</div><div class="line">public void addContentView(@NonNull View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">    super.addContentView(view, params);</div><div class="line">    AbViewUtil.scaleCompat(view);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Fragment"><a href="#3-Fragment" class="headerlink" title="3. Fragment"></a>3. Fragment</h3><p>在Fragment的 <code>onCreateView()</code> 方法中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inflater = LayoutInflater.from(getActivity());</div><div class="line">rootView = inflater.inflate(R.layout.fragment_function, container, false);</div><div class="line">AbViewUtil.scaleCompat(rootView);</div></pre></td></tr></table></figure>
<p>也可以在 <code>BaseFragment</code> 中添加如下方法，在子类Fragment的  <code>onCreateView()</code> 中调用以获取缩放后的 View：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 使用 &#123;@link AbViewUtil&#125; 处理</div><div class="line"> *</div><div class="line"> * @param inflater</div><div class="line"> * @param container</div><div class="line"> * @param layoutId</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">protected View getContentView(LayoutInflater inflater, @Nullable ViewGroup container, int layoutId) &#123;</div><div class="line">    View view = inflater.inflate(layoutId, container, false);</div><div class="line">    AbViewUtil.scaleCompat(view);</div><div class="line">    return view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-Dialog-amp-PopupWindow-等"><a href="#4-Dialog-amp-PopupWindow-等" class="headerlink" title="4. Dialog &amp; PopupWindow 等"></a>4. Dialog &amp; PopupWindow 等</h3><p>类似 Dialog 需要传入自定义 View 作为布局的，可以参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">View view = View.inflate(mContext, layoutResID, null);</div><div class="line">AbViewUtil.scaleCompat(view);</div><div class="line">dialog.setContentView(view);</div></pre></td></tr></table></figure>
<p>如果有 BaseDialog ，可以重写下列方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void setContentView(int layoutResID) &#123;</div><div class="line">    View view = View.inflate(mContext, layoutResID, null);</div><div class="line">    setContentView(view);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void setContentView(@NonNull View view) &#123;</div><div class="line">    super.setContentView(view);</div><div class="line">    AbViewUtil.scaleCompat(view);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public void setContentView(@NonNull View view, ViewGroup.LayoutParams params) &#123;</div><div class="line">    super.setContentView(view, params);</div><div class="line">    AbViewUtil.scaleCompat(view);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-注意"><a href="#5-注意" class="headerlink" title="5. 注意"></a>5. 注意</h3><p>布局文件中的宽高和文字大小都统一使用设计图提供的尺寸值，单位统一使用 <code>px</code> 。</p>
<p>至此，一个Activity的屏幕适配就完成了。</p>
<h2 id="二、源码"><a href="#二、源码" class="headerlink" title="二、源码"></a>二、源码</h2><p>最新源码请点击：<a href="https://github.com/leowing/commonUtils/blob/master/utils/src/main/java/com/github/leowing/utils/AbViewUtil.java" target="_blank" rel="external">AbViewUtil</a></p>
<p>示例项目：<a href="https://github.com/leowing/commonUtils/tree/master/example" target="_blank" rel="external">Example</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抛弃 google 提供的 dip 理论与多套图片与布局方案，采用与 UI 设计师通用的 px 作为标准单位，原理是将 UI 设计师的设计图与当前查看的手机或其他设备的屏幕像素尺寸进行换算，得到缩放比例，在 Activity 中装载布局时将所有布局的 px 尺寸进行缩放后设置给布局，就实现了一套尺寸在不同大小的设备上能够按照合理的比例进行缩放，达到万能适配的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="lwp" scheme="http://xgfe.github.io/categories/lwp/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="适配" scheme="http://xgfe.github.io/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>this：我们不一样！</title>
    <link href="http://xgfe.github.io/2017/11/16/wangyue/this/"/>
    <id>http://xgfe.github.io/2017/11/16/wangyue/this/</id>
    <published>2017-11-15T16:00:00.000Z</published>
    <updated>2018-01-16T03:04:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了JS中的词法作用域及this的特殊性和一个小彩蛋。</p>
<a id="more"></a>
<p>我们知道，JS中变量的作用域是「词法作用域」。所谓词法作用域是指作用域在词法解析阶段既确定了，不会改变(这也是闭包成立的基础)。与之对应的是动态作用域，动态作用域是在运行时确定的，其作用域链基于运行时的调用栈。如果想了解更多关于词法作用域的事情，<a href="http://www.jianshu.com/p/70b38c7ab69c" target="_blank" rel="external">点击这里</a>。</p>
<h5 id="不一样的this"><a href="#不一样的this" class="headerlink" title="不一样的this"></a>不一样的<code>this</code></h5><p>显然，<code>this</code>是不符合词法作用域的，<code>this</code>的指向并不能在函数声明时确定，而与函数运行时的调用栈密切相关。</p>
<h5 id="this指向的一般规律"><a href="#this指向的一般规律" class="headerlink" title="this指向的一般规律"></a>this指向的一般规律</h5><p>一句话说完，JS函数中this指向函数的直接调用者。<br>这里有两个默认的约定</p>
<ul>
<li>原生的dom事件绑定的函数，直接调用者为该dom节点</li>
<li>直接执行一个函数，在非严格模式下，直接调用者为window(浏览器下)，严格模式下，直接调用者为<code>undefined</code></li>
</ul>
<h5 id="this指向的例外情况"><a href="#this指向的例外情况" class="headerlink" title="this指向的例外情况"></a>this指向的例外情况</h5><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="external"><code>call</code></a>/<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="external"><code>apply</code></a><br><code>fun.call(thisArg, arg1, arg2, ...)</code>以指定的<code>this</code>值来调用函数</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external"><code>bind</code></a>：<br><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code>  方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在实参之前提供一个给定的参数序列。</p>
</li>
<li><p>数组迭代方法中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="external"><code>thisArg</code></a><br><code>array.forEach(callback[, thisArg])</code> <code>thisArg</code>为<code>callback</code>中的<code>this</code>值。</p>
</li>
</ul>
<h5 id="在声明函数时确定this的指向"><a href="#在声明函数时确定this的指向" class="headerlink" title="在声明函数时确定this的指向"></a>在声明函数时确定<code>this</code>的指向</h5><p>  我们可以通过<code>fun = fun.bind(this)</code>来使函数中的this指向固定。<br>  React中经常会这么做：<img src="http://p0.meituan.net/xgfe/ab34cfa7f56368b1a1f5cdc10f8ca0aa457647.png" alt="React 中通常会在constructor里绑定this"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>普通变量：词法作用域 | 例外：<code>this</code></li>
<li><code>this</code>指向的规律：指向直接调用者(dom/strict mode)  </li>
<li><code>this</code>指向的例外：<code>bind</code>、<code>apply/call</code>、数组遍历方法<code>thisArg</code></li>
<li>通过例外的例外使例外符合一般规律：<code>this.fn = this.fn.bind(this)</code></li>
</ul>
<h4 id="one-more-thing"><a href="#one-more-thing" class="headerlink" title="one more thing"></a>one more thing</h4><p>  在验证<code>this</code>指向的例外情况时，我试了下<code>with</code>会不会影响<code>this</code>的指向，结果是不会。不过，倒是发现了一点其他奇怪的情况，放个图大家看吧：<img src="http://p0.meituan.net/xgfe/ff3cb88b203bcfbd8e432d5b67365ade127542.png" alt="with的奇怪情况"><br>  究其原因，<code>null</code>是一个字面量，不可被赋值。<code>undefined</code>是一个特殊的预定义的全局变量，可以被赋值，不过正常情况下赋值会静默失败。而<code>let</code>根本就不是关键字，是合法的变量名。但是即使<code>let</code>被赋值，也不会影响它正常工作（<code>let</code>居然不是关键字！！！）。<img src="http://p1.meituan.net/xgfe/8fedaea7d3fbd2b0770cc5f390824ee679269.png" alt=""><br>  另一个彩蛋：<br>  <img src="http://vfile.meituan.net/xgfe/054512edd6754ca9011615ea9e854b7d92301.png" alt="undefined ?"><br>  因为刚才说过<code>undefined</code>是一个预定义的全局变量，给它赋值在非严格模式下会静默失败。但是在函数作用域中，我们可以重新声明一个叫undefined的变量，它和全局预定义的那个<code>undefined</code>并不是同一个变量，是可以被正常赋值的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了JS中的词法作用域及this的特殊性和一个小彩蛋。&lt;/p&gt;
    
    </summary>
    
      <category term="wangyue" scheme="http://xgfe.github.io/categories/wangyue/"/>
    
    
      <category term="this" scheme="http://xgfe.github.io/tags/this/"/>
    
      <category term="词法作用域" scheme="http://xgfe.github.io/tags/%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="关键字" scheme="http://xgfe.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>Vue生命周期总结</title>
    <link href="http://xgfe.github.io/2017/10/31/lulutia/vue-lifecycle/"/>
    <id>http://xgfe.github.io/2017/10/31/lulutia/vue-lifecycle/</id>
    <published>2017-10-31T07:04:00.000Z</published>
    <updated>2017-10-31T07:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了vue中涉及到的生命周期，并且通过实际尝试得出了其执行顺序。</p>
<a id="more"></a>
<p>在进行Vue项目开发的过程中，会不可避免的接触它的生命周期。了解每个生命周期的特性及其使用场景对于快速进行项目开发相当重要。</p>
<h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>一般基于Vue全家桶进行开发的项目都会采用vue-router来进行路由处理。在这种情况下，全局路由钩子将会是我们接触的生命周期第一站。这块主要涉及到以下两个方法：</p>
<ul>
<li><p>使用router.beforeEach注册一个全局前置守卫。直白的说就是当一个导航触发时，会按照顺序执行完毕此方法里的内容后再进行跳转[resolve后]。因此，在这个周期内特别适合做<strong>全局拦截</strong>，比如判断登陆状态。这个方法接受三个参数(from, to, next)，并且以调用next方法来作为resolve的标志。next方法可以传入以下几种参数：</p>
<ul>
<li>不传参数如next()：进行管道中的下一个钩子，执行完后成为resolve状态，进行正常跳转</li>
<li>传入具体的路径如next(‘/‘): 直接跳转到传入的地址，当前导航会被中断，进行新的导航</li>
<li>传入false如next(false): 中断当前导航，保持在当前的页面</li>
<li>传入error如next(error): error是一个Error实例，导航会被终止且该错误会被传递给router.onError()注册过的回调</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'router.beforeEach'</span>)</div><div class="line">  next()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li>使用router.afterEach注册一个全局后置钩子，接受两个参数(from, to)。不接受next，也不改变导航状态</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">router.afterEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'router.afterEach'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h3><p>按照正常思维来思考，当路由确定后就涉及到具体页面的渲染。因此这部分涉及到以下几个实例的生命周期：</p>
<ul>
<li>beforeCreate：这个阶段主要执行初始化。可以访问实例本身，但是因为实例的配置还没完成，因此<strong>访问data或者method都是没用的</strong>。</li>
<li>created：这个阶段已经进行了实例的配置，因此可以访问data、method和computed等了。但是因为挂载还没完成，所以<strong>直接访问this.$el是没用的</strong></li>
<li>beforeMount：这个阶段是在挂载开始之前执行，之后就会走正常的渲染逻辑</li>
<li>mounted：在这个阶段挂载已经完成，所以<strong>访问this.$el已经能够拿到元素了</strong></li>
<li>beforeDestroy：这个阶段在实例销毁之前调用，因为是之前，所以在这个阶段还能够访问实例本身</li>
<li>destroyed：这个阶段表示实例已经被销毁完成了。因此所有自己本身及其子组件的绑定，监听都会销毁</li>
</ul>
<p>上面是一个最基本的流程。加上前面的全局路由。我们可以看见其执行先后顺序如下：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline1.png" alt=""></p>
<p>通过上面的展示，我们得到注意点，在从A页面跳转到B页面时，<strong>A页面的beforeDestroy和destroyed方法是比全局路由的beforeEach和afterEach执行的晚的</strong>。</p>
<p>除了上面一个最基本的流程外，还有一个很重要的环节就是<strong>更新</strong>。关于这个，有下面两个生命周期阶段：</p>
<ul>
<li>beforeUpdate：数据更新时调用，发生在virtual dom进行对比和渲染之前。因此在这个阶段继续更改数据不会触发重新的渲染。但是这里有几个需要注意的地方如下：<ul>
<li>如果只是单纯的数据变化，而这个变化并没有在template里面使用，则这个函数也不会触发。</li>
<li>在beforeUpdate里面进行的数据更新，如果与之前的一样，则virtual dom对比结果为一样，此时不会重新触发beforeUpdate和updated；如果不一样，则会触发beforeUpdate和updated，但实际updated时更新的数据为后面的，证明在这个阶段继续更改数据不会触发重新的渲染；但是如果这个阶段的数据更新是异步的，比如延迟一秒更新，实际updated会触发两次并且数据不一样，表明触发了新的绘制</li>
<li>在beforeUpdate里面重复修改同一个数据可能导致beforeUpdate函数的无限循环，应尽量避免</li>
</ul>
</li>
<li>updated：virtual dom重新渲染和打补丁之后调用。所以如果在这个阶段再进行数据的更改会又重新触发beforeUpdate，恰巧如果beforeUpdate里面有同一数据的修改则很容易导致无限循环，所以最好避免这种事情发生。这个环节后，可以使用更新后的dom。</li>
</ul>
<p>在添加了上面两个方法后，现在我们可以看其执行顺序如下：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline02.png" alt=""></p>
<h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><p>根组件的基本生命周期探讨到一阶段了，因为现在都是组件化的思维，因此现在很自然的就会想到子组件的生命周期在全局是处于何种位置的。<br>与根组件一样，子组件也拥有beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed这几个生命阶段。现在我们来看在<strong>不执行更新操作</strong>时的执行顺序：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline03.png" alt=""></p>
<p>由上可知:</p>
<ul>
<li>子组件的初始化晚于根组件，但是其挂载早于根组件，即当子组件都mounted后，根组件才会mounted。具体子组件的beforeCreated时间是在根组件的beforeMount之后</li>
<li>子组件的销毁开始时间也晚于根组件，但是只有当子组件都destroyed后，根组件才destroyed了</li>
</ul>
<p>那加上更新操作时会怎样呢？我们构造了一个子组件，将根组件的msg作为props传入进去，然后根据这个prop构造一个计算属性，来作为子组件的template中的一个参数。注意这里一定要使用计算属性，如果直接使用data的话，是不会更新的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;smallcomponent :msg="msg"/&gt;</div><div class="line">..........HelloWorld.vue.........</div><div class="line"> &lt;template&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1&gt;&#123;&#123;componentInfo&#125;&#125;&lt;/h1&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">...</div><div class="line"> props: &#123;</div><div class="line">      msg: &#123;</div><div class="line">        type: String</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">      componentInfo () &#123;</div><div class="line">        return this.msg</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">..........Time.vue........</div></pre></td></tr></table></figure>
<p>在上面这种情况下，我们可以得出其生命周期如下，很明显，根组件是在子组件更新完毕后才更新完毕的：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/time04.png" alt=""></p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>除了上面所说的子组件，根组件里面可能还会有指令存在，总的来说指令也会有其对应的生命周期，如下来自<a href="https://cn.vuejs.org/v2/guide/custom-directive.html#main" target="_blank" rel="external">vue官方文档</a>：</p>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作</li>
<li>inserted：被绑定元素插入父节点时调用 (父节点存在即可调用，不必存在于 document 中)</li>
<li>update：所在组件的VNode更新时调用，但是可能发生在其孩子的VNode更新之前</li>
<li>componentUpdated：所在组件的VNode及其孩子的VNode全部更新时调用</li>
<li>unbind：只调用一次，指令与元素解绑时调用</li>
</ul>
<p>我们实现了一个指令，将根组件的msg作为值传入指令中，在最基本的状态下，他们的生命周期流程如下：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline05.png" alt=""></p>
<p>看来指令和子组件的状态十分类似，也是在根组件beforeMount后进行bind与inserted，然后根组件才执行mounted；在解绑时，也是在根组件beforeDestroy后执行，执行完后根组件才可能执行destroyed</p>
<p>同样，如果这时，加上更新操作，其生命流程会如下所示，很明显，根组件是在指令更新完毕后才更新完毕的：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline06.png" alt=""></p>
<p>之前我们单独的讨论了子组件和指令，那么如果它们在一起时生命周期的顺序又是怎样呢？通过实际实验，我们得出其顺序如下，当我们在根组件里先引入子组件再引入指令时其顺序如下左图，当我们先引人指令再引人子组件时其顺序如下右图：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline09.png" alt=""></p>
<p>很明显，这个顺序是和引人组件或者指令的先后顺序有关～</p>
<ul>
<li>销毁阶段谁先引入谁先销毁</li>
<li>更新阶段，都是指令的更新靠前</li>
<li>创建阶段，谁先引入谁先进行初始化，但总的来说挂载都在初始化之后[无论谁的初始化]</li>
</ul>
<h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><p>在前面我们已经讨论过全局守卫、根组件、子组件和指令了。但实际上对于组件而言，它还存在组件内的守卫，<a href="https://router.vuejs.org/zh-cn/advanced/navigation-guards.html" target="_blank" rel="external">如下</a>：</p>
<ul>
<li>beforeRouteEnter：在渲染该组件的对应路由被 confirm 前调用，<strong>不能</strong>获取组件实例 this，因为当守卫执行前，组件实例还没被创建</li>
<li>beforeRouteUpdate：在当前路由改变，但是该组件被复用时调用，可以访问组件实例this</li>
<li>beforeRouteLeave：导航离开该组件的对应路由时调用，可以访问组件实例this</li>
</ul>
<p>我们在根组件添加了以上几个方法，可以看见整个生命周期如下所示：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline10.png" alt=""></p>
<p>由上可知，beforeRouteEnter是在全局守卫之后调用，而beforeRouteLeave是在全局守卫之前调用。上面我们说到在beforeRouteEnter阶段是没法访问到this的，为了解决这个问题，可以通过传一个回调给next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'beforeRouteEnter'</span>)</div><div class="line">    next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'beforeRouteEnter的next'</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div></pre></td></tr></table></figure>
<p>那么这个的触发又是在生命周期的那一环呢？</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline11.png" alt=""></p>
<p>很明显它会在完成mounted后马上触发。所以虽然beforeRouteEnter的执行时间很早，但是它的回调执行的时间比较晚，算是最接近dom渲染的一个周期了</p>
<h3 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h3><p>除了上面我们讨论的全局守卫和组件内的守卫，实际还有一个路由独享的守卫，即可以在路由配置上直接定义beforeEnter守卫。具体使用如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</div><div class="line">  <span class="attr">routes</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">      <span class="attr">name</span>: <span class="string">'Hello'</span>,</div><div class="line">      <span class="attr">component</span>: HelloWorld,</div><div class="line">      <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Exclusive beforeEnter'</span>)</div><div class="line">        next()</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">path</span>: <span class="string">'/world'</span>,</div><div class="line">      <span class="attr">name</span>: <span class="string">'World'</span>,</div><div class="line">      <span class="attr">component</span>: Page2</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>通过实际情况我们可以得知，这个方法的调用会在全局守卫的beforeEach之后，而在组件内守卫的beforeRouteEnter之前，如下：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline12.png" alt=""></p>
<h3 id="Vue-nextTick-amp-vm-nextTick"><a href="#Vue-nextTick-amp-vm-nextTick" class="headerlink" title="Vue.nextTick &amp; vm.$nextTick"></a>Vue.nextTick &amp; vm.$nextTick</h3><p>除了上面讨论的，还有两个和生命周期有关系的方法，如下：</p>
<ul>
<li><a href="https://cn.vuejs.org/v2/api/index.html#Vue-nextTick" target="_blank" rel="external">Vue.nextTick</a>：这是个全局API，在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM</li>
<li><a href="https://cn.vuejs.org/v2/api/index.html#vm-nextTick" target="_blank" rel="external">vm.$nextTick</a>: 将回调延迟到下次DOM更新循环之后执行。在修改数据之后立即使用它，然后等待DOM更新。它跟全局方法Vue.nextTick一样，不同的是回调的this自动绑定到调用它的实例上</li>
</ul>
<p>我们将这部分加上去，得到整个这篇文章探讨的生命周期过程如下：</p>
<p><img src="http://okzzg7ifm.bkt.clouddn.com/timeline13.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://cn.vuejs.org/" target="_blank" rel="external">Vue.js官方文档</a></li>
<li><a href="https://router.vuejs.org/zh-cn/index.html" target="_blank" rel="external">vue-router官方文档</a></li>
<li><a href="https://segmentfault.com/a/1190000008879966" target="_blank" rel="external">vue生命周期探究（一）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了vue中涉及到的生命周期，并且通过实际尝试得出了其执行顺序。&lt;/p&gt;
    
    </summary>
    
      <category term="lulutia" scheme="http://xgfe.github.io/categories/lulutia/"/>
    
    
      <category term="Vue" scheme="http://xgfe.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>用CSS实现各种图片滤镜效果演示</title>
    <link href="http://xgfe.github.io/2017/10/18/liuhongyu/filter/"/>
    <id>http://xgfe.github.io/2017/10/18/liuhongyu/filter/</id>
    <published>2017-10-18T13:46:00.000Z</published>
    <updated>2017-10-31T07:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本演示关键使用了几个新型的CSS属性(background-blend-mode, mix-blend-mode, 和 filter)，利用这些属性，我们可以让同一张图片呈现出各种不可思议的神奇效果。</p>
<a id="more"></a>
<h3 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h3><ul>
<li>以下大多数的效果图中，背景图片源 background-image url 通常会反复使用数次，同时利用CSS混合模式 (multiply, overlay, screen, difference 等)进行处理。</li>
<li>在某些效果中，使用了 CSS filter 属性进一步处理图片，比如 grayscale(), brightness(), 和 contrast() 等可以让图片呈现出更好的效果。</li>
<li>使用 CSS @supports 来检测某种 CSS 属性是否在浏览器中受支持，不支持展示原图。</li>
</ul>
<h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><h4 id="mix-blend-mode属性"><a href="#mix-blend-mode属性" class="headerlink" title="mix-blend-mode属性"></a>mix-blend-mode属性</h4><pre><code>mix-blend-mode: normal; //正常
mix-blend-mode: multiply; //正片叠底
mix-blend-mode: screen;  //滤色
mix-blend-mode: overlay; //叠加
mix-blend-mode: darken; //变暗
mix-blend-mode: lighten; //变亮
mix-blend-mode: color-dodge; //颜色变淡
mix-blend-mode: color-burn; //颜色加深
mix-blend-mode: hard-light; //强光
mix-blend-mode: soft-light; //柔光
mix-blend-mode: difference; //插值
mix-blend-mode: exclusion; //排除
mix-blend-mode: hue; //色调
mix-blend-mode: saturation; //饱和度
mix-blend-mode: color; //颜色
mix-blend-mode: luminosity; //亮度
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode" target="_blank" rel="external">具体可参考</a></p>
<h4 id="background-blend-mode属性"><a href="#background-blend-mode属性" class="headerlink" title="background-blend-mode属性"></a>background-blend-mode属性</h4><p>*属性值和mix-blend-mode一样<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode" target="_blank" rel="external">具体可参考</a></p>
<h4 id="filter属性"><a href="#filter属性" class="headerlink" title="filter属性"></a>filter属性</h4><pre><code>/* URL to SVG filter */
filter: url(&quot;filters.svg#filter-id&quot;);

/* &lt;filter-function&gt; values */
filter: blur(5px); //模糊
filter: brightness(0.4); //亮度
filter: contrast(200%); //对比度
filter: drop-shadow(16px 16px 20px blue); //阴影
filter: grayscale(50%); //灰度
filter: hue-rotate(90deg); //色相旋转
filter: invert(75%); //反色
filter: opacity(25%); //透明度
filter: saturate(30%); //饱和度
filter: sepia(60%); //褪色

/* Multiple filters */
filter: contrast(175%) brightness(3%);
</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter" target="_blank" rel="external">具体可参考</a></p>
<h3 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h3><h4 id="原图效果"><a href="#原图效果" class="headerlink" title="原图效果"></a>原图效果</h4><p><img src="http://p0.meituan.net/xgfe/5bdb72c861a17a9749cff76b099a356d212585.jpg" alt=""></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.pencil-effect</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg);</div><div class="line">  <span class="attribute">background-size</span>: cover;</div><div class="line">  <span class="attribute">background-position</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">supports</span> (filter: invert(<span class="number">1</span>)) and (background-blend-mode: difference) &#123;</div><div class="line">  <span class="selector-class">.pencil-effect</span> &#123;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg), <span class="built_in">url</span>(minions.jpg);</div><div class="line">    <span class="attribute">background-blend-mode</span>: difference;</div><div class="line">    <span class="attribute">background-position</span>: <span class="built_in">calc</span>(50% - 1px) <span class="built_in">calc</span>(50% - 1px), <span class="built_in">calc</span>(50% + 1px) <span class="built_in">calc</span>(50% + 1px);</div><div class="line">    <span class="attribute">filter</span>: <span class="built_in">brightness</span>(2) <span class="built_in">invert</span>(1) <span class="built_in">grayscale</span>(1);</div><div class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="pencil效果"><a href="#pencil效果" class="headerlink" title="pencil效果"></a>pencil效果</h4><p><img src="http://p0.meituan.net/xgfe/4c64f176d177c77b4fb42d988015af19145095.jpg" alt=""></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.watercolor-effect</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg);</div><div class="line">  <span class="attribute">background-size</span>: cover;</div><div class="line">  <span class="attribute">background-position</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">supports</span> (filter: blur(<span class="number">2px</span>)) and (mix-blend-mode: multiply) &#123;</div><div class="line">  <span class="selector-class">.watercolor-effect</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.watercolor-effect</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.watercolor-effect</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">background-size</span>: cover;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.watercolor-effect</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg), <span class="built_in">url</span>(minions.jpg);</div><div class="line">    <span class="attribute">background-blend-mode</span>: difference;</div><div class="line">    <span class="attribute">background-position</span>: <span class="built_in">calc</span>(50% - 1px) <span class="built_in">calc</span>(50% - 1px), <span class="built_in">calc</span>(50% + 1px) <span class="built_in">calc</span>(50% + 1px);</div><div class="line">    <span class="attribute">filter</span>: <span class="built_in">brightness</span>(2) <span class="built_in">invert</span>(1) <span class="built_in">grayscale</span>(1);</div><div class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.watercolor-effect</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg);</div><div class="line">    <span class="attribute">background-position</span>: center;</div><div class="line">    <span class="attribute">mix-blend-mode</span>: multiply;</div><div class="line">    <span class="attribute">filter</span>: <span class="built_in">brightness</span>(1.3) <span class="built_in">blur</span>(2px) <span class="built_in">contrast</span>(2);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="watercolor效果"><a href="#watercolor效果" class="headerlink" title="watercolor效果"></a>watercolor效果</h4><p><img src="http://p1.meituan.net/xgfe/27a8948fbda95756722abcc5b7c8aba5227184.jpg" alt=""></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.colored-pencil-effect</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg);</div><div class="line">  <span class="attribute">background-size</span>: cover;</div><div class="line">  <span class="attribute">background-position</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">supports</span> (filter: invert(<span class="number">1</span>)) and (mix-blend-mode: color) &#123;</div><div class="line">  <span class="selector-class">.colored-pencil-effect</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.colored-pencil-effect</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.colored-pencil-effect</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">background-size</span>: cover;</div><div class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> black;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.colored-pencil-effect</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg), <span class="built_in">url</span>(minions.jpg);</div><div class="line">    <span class="attribute">background-blend-mode</span>: difference;</div><div class="line">    <span class="attribute">background-position</span>: <span class="built_in">calc</span>(50% - 1px) <span class="built_in">calc</span>(50% - 1px), <span class="built_in">calc</span>(50% + 1px) <span class="built_in">calc</span>(50% + 1px);</div><div class="line">    <span class="attribute">filter</span>: <span class="built_in">brightness</span>(2) <span class="built_in">invert</span>(1) <span class="built_in">grayscale</span>(1);</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.colored-pencil-effect</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">    <span class="attribute">background</span>: inherit;</div><div class="line">    <span class="attribute">mix-blend-mode</span>: color;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="colored-pencil效果"><a href="#colored-pencil效果" class="headerlink" title="colored-pencil效果"></a>colored-pencil效果</h4><p><img src="http://p0.meituan.net/xgfe/50e1cef7923d032a304a90c078bdbbba86681.jpg" alt=""></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.warhol-effect</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg);</div><div class="line">  <span class="attribute">background-size</span>: cover;</div><div class="line">  <span class="attribute">background-position</span>: center;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">supports</span> (background-blend-mode: color) &#123;</div><div class="line">  <span class="selector-class">.warhol-effect</span> &#123;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#14EBFF 0, #14EBFF 50%, #FFFF70 50%, #FFFF70 100%), <span class="built_in">linear-gradient</span>(#FF85DA 0, #FF85DA 50%, #AAA 50%, #AAA 100%), <span class="built_in">url</span>(minions.jpg);</div><div class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">100%</span>, <span class="number">50%</span> <span class="number">100%</span>, <span class="number">50%</span> <span class="number">50%</span>;</div><div class="line">    <span class="attribute">background-position</span>: top left, top right;</div><div class="line">    <span class="attribute">background-repeat</span>: no-repeat, no-repeat, repeat;</div><div class="line">    <span class="attribute">background-blend-mode</span>: color;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="warhol效果"><a href="#warhol效果" class="headerlink" title="warhol效果"></a>warhol效果</h4><p><img src="http://p1.meituan.net/xgfe/c3f854448e4e29a81747f6f2cc27426a90904.jpg" alt=""></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.infrared-effect</span> &#123;</div><div class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(minions.jpg);</div><div class="line">  <span class="attribute">background-size</span>: cover;</div><div class="line">  <span class="attribute">background-position</span>: center;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(180deg) <span class="built_in">saturate</span>(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="infrared效果"><a href="#infrared效果" class="headerlink" title="infrared效果"></a>infrared效果</h4><p><img src="http://p1.meituan.net/xgfe/c0b7f1e52f4e11a4a55bad3ba1157f6f69507.jpg" alt=""></p>
<h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><ul>
<li>background-blend-mode不支持IE具体详情见下图（mix-blend-mode类似） </li>
</ul>
<p><img src="http://p1.meituan.net/xgfe/02a2dec38a572e4175a74533c2589854308285.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本演示关键使用了几个新型的CSS属性(background-blend-mode, mix-blend-mode, 和 filter)，利用这些属性，我们可以让同一张图片呈现出各种不可思议的神奇效果。&lt;/p&gt;
    
    </summary>
    
      <category term="liuhongyu" scheme="http://xgfe.github.io/categories/liuhongyu/"/>
    
    
      <category term="CSS3" scheme="http://xgfe.github.io/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>基于IntersectionObserver的曝光统计测试</title>
    <link href="http://xgfe.github.io/2017/10/18/lulutia/IntersectionObserver/"/>
    <id>http://xgfe.github.io/2017/10/18/lulutia/IntersectionObserver/</id>
    <published>2017-10-18T09:23:00.000Z</published>
    <updated>2017-10-18T09:23:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了IntersectionObserver API，并且就如何将其用于数据埋点给出了尝试。</p>
<a id="more"></a>
<h4 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h4><p>  作为一款产品，往往希望能得到用户的反馈，从而通过对用户行为的分析进行功能、交互等方方面面的改进。然而直接的一对一的用户交流是低效且困难的，因此最普遍的做法便是通过数据埋点来反推用户的行为。那么数据埋点中很重要的一环便是：曝光。<br>  所谓曝光，便是页面被展示的时候进行打点。举个简单的例子：用户进入分类页面，商品以行为单位从上而下进行排列。当用户滚动页面时，之前不在视窗范围内的商品就会出现，此时，这部分商品就算曝光了。需要进行一次记录。<br>  那么为了实现上面功能，最普遍的做法有两个。其一：跟踪滚动事件，然后计算某个商品与视窗的相对位置，从而判断是否可见。其二：维持一个timer，然后以固定的时间为间隔计算某个商品与视窗的相对位置。<br>  上面两种做法在某种程度上能够实现我们的目的，但是会有一些问题，比如最明显的：慢。因为计算相对位置时会调用getBoundingClientRect()，这个操作会导致浏览器进行全页面的重新布局，不用我说，大家都知道这个性能开销是很大的，特别是在频繁进行时。除此之外，如果页面是作为一个iframe包裹的也会产生问题，因为同源策略和浏览器不会允许你获取包裹iframe的页面的数据。然而在现有情况下，很多广告都是通过iframe的形式镶嵌在网页内的。<br>  基于以上的情况，我们急需一种性能良好且iframe友好的方式来实现曝光的功能，因此IntersectionObserver API进入了我们的视野。</p>
<h4 id="IntersectionObserver-API介绍"><a href="#IntersectionObserver-API介绍" class="headerlink" title="IntersectionObserver API介绍"></a>IntersectionObserver API介绍</h4><p>关于IntersectionObserver API的官方文档<a href="https://w3c.github.io/IntersectionObserver/" target="_blank" rel="external">见此</a>。截止本文为止，其兼容性如下图所示:<br><img src="http://okzzg7ifm.bkt.clouddn.com/IntersectionObserver.png" alt="API 兼容性">简单的说IntersectionObserver让你知道什么时候observe的元素进入或者存在在root区域里了。下面我们来看下这个API的具体内容:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用构造函数生成观察者实例，回调函数是必须的，后面的配置对象是可选的</span></div><div class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">changes</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> change <span class="keyword">of</span> changes) &#123;</div><div class="line">    <span class="built_in">console</span>.log(change.time);               <span class="comment">// 相交发生时经过的时间</span></div><div class="line">    <span class="built_in">console</span>.log(change.rootBounds);         <span class="comment">// 表示发生相交时根元素可见区域的矩形信息，是一个对象值</span></div><div class="line">    <span class="built_in">console</span>.log(change.boundingClientRect); <span class="comment">// target.boundingClientRect()发生相交时目标元素的矩形信息，也是个对象值</span></div><div class="line">    <span class="built_in">console</span>.log(change.intersectionRect);   <span class="comment">// 根元素与目标元素相交时的矩形信息</span></div><div class="line">    <span class="built_in">console</span>.log(change.intersectionRatio);  <span class="comment">// 表示相交区域占目标区域的百分比，是一个0到1的值</span></div><div class="line">    <span class="built_in">console</span>.log(change.target);             <span class="comment">// 相交发生时的目标元素</span></div><div class="line">  &#125;</div><div class="line">&#125;, &#123;</div><div class="line">	<span class="attr">root</span>: <span class="literal">null</span>,</div><div class="line">  	<span class="attr">threshold</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</div><div class="line">  	<span class="attr">rootMargin</span>: <span class="string">"50px"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 实例属性</span></div><div class="line">observer.root</div><div class="line"></div><div class="line">observer.rootMargin</div><div class="line"></div><div class="line">observer.thresholds</div><div class="line"></div><div class="line"><span class="comment">// 实例方法</span></div><div class="line">observer.observe(target); <span class="comment">// 观察针对某个特定元素的相交事件</span></div><div class="line"></div><div class="line">observer.unobserve(target); <span class="comment">// 停止对某个特定元素的相交事件的观察</span></div><div class="line"></div><div class="line">observer.disconnect(); <span class="comment">// 停止对所有目标元素的阈值事件的观察，简单的说就是停用整个IntersectionObserver</span></div><div class="line"></div><div class="line"><span class="comment">// 除了上面三个实例方法，还有一个takeRecords()的方法，之后会详细介绍</span></div></pre></td></tr></table></figure>
<p>IntersectionObserver API允许开发人员了解目标dom元素相对于intersection root的可见性。这个root可以通过实例属性获取。默认情况下它为null，此时它不是真正意义上的元素，它指视窗范围，因此只要视窗范围内的目标元素(当然是后代元素)滚入视窗时，就会触发回调函数[如果root元素不存在了，则执行其任何的observe都会出错]。下面举个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>intersectionObserve<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">			#target &#123;</div><div class="line">			   position: relative;</div><div class="line">			   top: calc(100vh + 500px);</div><div class="line">			   width: 100px;</div><div class="line">			   height: 100px;</div><div class="line">			   background: red;</div><div class="line">			&#125;</div><div class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">			<span class="keyword">let</span> ele = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">				<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">			  		<span class="built_in">console</span>.log(entries);</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line"></div><div class="line">			ele.observe(target);</div><div class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的栗子中，当红色的块滚入滚出视窗，都会触发回调函数，回调函数在调用时会传入一个由IntersectionObserverEntry 对象组成的数组。每个IntersectionObserverEntry 对象包含对应的observed元素的更新信息，大概数据结构如下，其具体意思在第一段代码里有详细说明:<br><img src="http://okzzg7ifm.bkt.clouddn.com/intersectionObject.png" alt=""><br>我们可以在配置对象中将root改为具体的元素，此时当目标元素出现在root元素中时会触发回调，注意，在这种情况下相交可能发生在视窗下面。具体代码在下，感兴趣的孩子可以试一下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>intersectionObserve<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">			#root &#123;</div><div class="line">				position: relative;</div><div class="line">				width: 400px;</div><div class="line">				height: calc(100vh + 200px);</div><div class="line">				background: lightblue;</div><div class="line">				overflow: scroll;</div><div class="line">			&#125;</div><div class="line">			#target &#123;</div><div class="line">			   position: absolute;</div><div class="line">			   top: calc(100vh + 800px);</div><div class="line">			   width: 100px;</div><div class="line">			   height: 100px;</div><div class="line">			   background: red;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">			<span class="keyword">let</span> ele = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">				<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">			  		<span class="built_in">console</span>.log(entries);</div><div class="line">			  &#125;, &#123;</div><div class="line">			  	<span class="attr">root</span>: root</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line"></div><div class="line">			ele.observe(target);</div><div class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在上面一条中，回调函数打印出来的对象中有一个intersectionRatio值，这个值其实涉及到了整个API的核心功能：当目标元素和根元素相交的面积占目标元素面积的百分比到达或跨过某些指定的临界值时就会触发回调函数。因此相对的在配置对象里有一个threshold来对这个百分比进行配置，默认情况下这个值是[0]，注意里面的值不能在0-1之外，否则会报错。我们举个栗子如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">let ele = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">	<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">  		<span class="built_in">console</span>.log(entries);</div><div class="line">  &#125;, &#123;</div><div class="line">  	<span class="attr">threshold</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>]</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">ele.observe(target);</div></pre></td></tr></table></figure>
<p>在上面这个栗子中，我们设定了0，0.5，1.0这三个值，因此当交叉区域跨越0，0.5，1.0时都会触发回调函数。注意我这边的用词是跨越，而不是到达。因为会存在以下两种情况导致回调打印出来的intersectionRatio不为0，0.5和1.0.<br>其一： 浏览器对相交的检测是有时间间隔的。浏览器的渲染工作都是以帧为单位的，而IntersectionObserver是发生在帧里面的。因此假如你设定了[0,0.1,0.2,0.3,0.4,0.5]这个threshold，但是你的滚动过程特别快，导致所有的绘制在一帧里面结束了，此时回调只会挑最近的临界值触发一次。<br>其二： IntersectionObserver是异步的。在浏览器内部，当一个观察者实例观察到众多的相交行为时，它不会立即执行。关于IntersectionObserver的草案里面写明了其实现是基于requestIdleCallback()来异步的执行我们的回调函数的，并且规定了最大的延迟时间是100ms。关于这部分涉及到前面第一段代码里的一个实例方法takeRecords()。如果你很迫切的希望马上知道是否有相交，你不希望等待可能的100ms，此时你就能调用takeRecords()，此后你能马上获得包含IntersectionObserverEntry 对象的数组，里面有相交信息，如果没有任何相交行为发生，则返回一个空数组。但这个方法与正常的异步回调是互斥的，如果它先执行了则正常回调里面就没信息了，反之亦然。<br>除开上面的问题，如果目标元素的面积为0会产生什么情况呢？因为与0计算相交率是没有意义的，实际我们举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>intersectionObserve<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">			#target &#123;</div><div class="line">			   position: relative;</div><div class="line">			   top: calc(100vh + 500px);</div><div class="line">			   width: 100px;</div><div class="line">			   height: 100px;</div><div class="line">			   background: red;</div><div class="line">			&#125;</div><div class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"img"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">			<span class="keyword">let</span> ele = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">				<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">			  		<span class="built_in">console</span>.log(entries);</div><div class="line">			  &#125;, &#123;</div><div class="line">			  	<span class="attr">threshold</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>]</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line"></div><div class="line">			ele.observe(img);</div><div class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>我们会看到，虽然我们设定了0.5这个阈值，但实际回调只会在0与1.0时触发。这是一种特殊的处理方式。</p>
<p>上面我们讨论了整个API的核心功能，实际其内部遵循的逻辑如下: 每个观察者实例为所有的目标元素都维护着上次的相交率(previousThreshold)，在新执行Observe的时候会将previousThreshold置为0，之后每次检测到满足threshold的相交率，并且与previousThreshold不同，那么就会触发回调并将previousThreshold重置为这个新值。那么这里可能会有下面几个问题：<br>其一：既然初始值是0，如果阈值设置为0，且刚刚满足滚动到0的位置，回调还会触发吗？实际是会的，这是一种特例，与目标元素在根元素内部(此时相交率为1)滚动到刚刚要超出的位置依然会触发回调函数一样。但是这种情况可能导致一个问题，我们无法直接用intersectionRatio&gt;0来判断目标是否滚入了根元素，因为在慢速滚动下，当目标元素的上边与根元素的下边相交时，此时intersectionRatio=0并且触发了回调，之后当intersectionRatio&gt;0时并不会触发回调了(这里排除还有其他自定义阈值的情况)。这种情况下，可以自定义一个变量值来存展示状态，或者也可以定义一个无限接近0的threshold.<br>其二：如果一个元素初始化就在根元素内部了，然后再执行observe，依然会触发回调吗？会的，因为初始值默认为0，在下一次检测时更新为了实际的相交值。</p>
<p>这里需要强调一点的是，我们的目标元素在Observe的时候可以不存在的[注意这里的不存在是指没有插入dom结构，但是元素本身是需要存在的]，只需要在相交发生时存在就行了，我们来举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>intersectionObserve<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">			#target &#123;</div><div class="line">			   position: relative;</div><div class="line">			   top: calc(100vh + 500px);</div><div class="line">			   width: 100px;</div><div class="line">			   height: 100px;</div><div class="line">			   background: red;</div><div class="line">			&#125;</div><div class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">			<span class="keyword">let</span> ele = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">				<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">			  		<span class="built_in">console</span>.log(entries);</div><div class="line">			  &#125;, &#123;</div><div class="line">			  	<span class="attr">threshold</span>: [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1.0</span>]</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line"></div><div class="line">			<span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">			ele.observe(img);</div><div class="line">			setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">				<span class="built_in">document</span>.body.appendChild(img);</div><div class="line">			&#125;, <span class="number">5000</span>);</div><div class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同理，如果目标元素与根元素处于相交状态，但是在一段时间后目标元素不存在了(比如remove，或者display:none)了，那么此时依然会触发一次回调。但是如果本身就不处于相交状态，然后消失掉了，因为0-&gt;0没有变化，所以不会触发回调，具体如下面的栗子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>intersectionObserve<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">			#target &#123;</div><div class="line">			   position: relative;</div><div class="line">			   top: calc(100vh + 500px);</div><div class="line">			   width: 100px;</div><div class="line">			   height: 100px;</div><div class="line">			   background: red;</div><div class="line">			&#125;</div><div class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">			<span class="keyword">let</span> ele = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">				<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">			  		<span class="built_in">console</span>.log(entries);</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line"></div><div class="line">			ele.observe(target);</div><div class="line">			setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">				<span class="built_in">document</span>.body.removeChild(target);</div><div class="line">			&#125;, <span class="number">5000</span>);</div><div class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="IntersectionObserver-API与iframe"><a href="#IntersectionObserver-API与iframe" class="headerlink" title="IntersectionObserver API与iframe"></a>IntersectionObserver API与iframe</h4><p>互联网上的很多小广告都是通过iframe嵌入的，而上面我们也说了现有的情况下很难获取iframe在顶层视窗内的曝光，但是使用IntersectionObserver API我们却可以做到这点。下面举个栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>intersectionObserve<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">			#root &#123;</div><div class="line">			   position: relative;</div><div class="line">			   top: calc(100vh + 800px);</div><div class="line">			   width: 100px;</div><div class="line">			   height: 100px;</div><div class="line">			&#125;</div><div class="line">			#iframe &#123;</div><div class="line">				width: 600px;</div><div class="line">				height: 600px;</div><div class="line">				margin-bottom: 300px;</div><div class="line">			&#125;</div><div class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></div><div class="line">  			<span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml"></span></div><div class="line">		  let iframeTemplate = `</div><div class="line">		    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>i am iframe<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">		      #target &#123;</div><div class="line">		        width: 500px;</div><div class="line">		        height: 500px;</div><div class="line">		        background: red;</div><div class="line">		      &#125;</div><div class="line">		      #target p &#123;</div><div class="line">		      	font-size: 90px;</div><div class="line">		      &#125;</div><div class="line">		    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">		    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">		      <span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">		        <span class="built_in">console</span>.log(entries)</div><div class="line">		      &#125;, &#123;</div><div class="line">		      	<span class="attr">threshold</span>: [<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1.0</span>]</div><div class="line">		      &#125;)</div><div class="line">		      observer.observe(target)</div><div class="line">		    &lt;\/script&gt;<span class="string">`</span></div><div class="line"></div><div class="line">		  iframe.src = URL.createObjectURL(new Blob([iframeTemplate], &#123;"type": "text/html"&#125;))</div><div class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>从上面的栗子可以看出，使用此API不仅能够使iframe在视窗内出现时触发回调，而且threshold值同样能够起作用。这样一来，大大简化了此类情况下获取曝光的难度。</p>
<h4 id="延迟加载与无限滚动"><a href="#延迟加载与无限滚动" class="headerlink" title="延迟加载与无限滚动"></a>延迟加载与无限滚动</h4><p>上面我们关于配置参数已经提到了root和threshold，实际上还有一个值：rootMargin。这个值实际就是给根元素添加了一个假想的margin值。其使用场景最普遍的是用于延迟加载。因为如果真的等目标元素与根元素相交的时候再进行加载图片等功能就已经晚了，所以有一个rootMargin值，这样等于根元素延伸开去了，目标元素只要与延伸部分相交就会触发回调，下面我们来继续举个栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span></div><div class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>intersectionObserve<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">			#root &#123;</div><div class="line">				width: 500px;</div><div class="line">				height: 800px;</div><div class="line">				overflow: scroll;</div><div class="line">				background-color: pink;</div><div class="line">			&#125;</div><div class="line">			#target &#123;</div><div class="line">			   position: relative;</div><div class="line">			   top: calc(100vh + 500px);</div><div class="line">			   width: 100px;</div><div class="line">			   height: 100px;</div><div class="line">			   background: red;</div><div class="line">			&#125;</div><div class="line">		<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">			<span class="keyword">let</span> ele = <span class="keyword">new</span> IntersectionObserver(</div><div class="line">				<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">			  		<span class="built_in">console</span>.log(entries);</div><div class="line">			  &#125;, &#123;</div><div class="line">			  	<span class="attr">rootMargin</span>: <span class="string">'100px'</span>,</div><div class="line">			  	<span class="attr">root</span>: root</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line"></div><div class="line">			ele.observe(target);</div><div class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>很明显，在上面的栗子中，目标元素并没有出现在根元素的视窗里的时候就已经触发回调了。</p>
<p>整个API可以用来实现无限滚动和延迟加载，下面就分别举出两个简单的栗子来启发思路，更完善健壮的功能就交给看官自己去尝试了哦：<br>延迟加载的栗子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="en"&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset="utf-8" /&gt;</div><div class="line">		&lt;title&gt;intersectionObserve&lt;/title&gt;</div><div class="line">		&lt;style type="text/css"&gt;</div><div class="line">			.img &#123;</div><div class="line">				height: 1000px;</div><div class="line">				overflow-y: hidden;</div><div class="line">			&#125;</div><div class="line">		&lt;/style&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;ul&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="" class="img-item" data-src="http://okzzg7ifm.bkt.clouddn.com/cat.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="" class="img-item" data-src="http://okzzg7ifm.bkt.clouddn.com/01.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="" class="img-item" data-src="http://okzzg7ifm.bkt.clouddn.com/virtualdom.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="" class="img-item" data-src="http://okzzg7ifm.bkt.clouddn.com/reactlife.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">		&lt;/ul&gt;</div><div class="line">		&lt;script type="text/javascript"&gt;</div><div class="line">			let ele = new IntersectionObserver(</div><div class="line">				(entries) =&gt; &#123;</div><div class="line">			  		entries.forEach((entry) =&gt; &#123;</div><div class="line">			  			if (entry.intersectionRatio &gt; 0) &#123;</div><div class="line">			  				entry.target.src = entry.target.dataset.src;</div><div class="line">			  			&#125;</div><div class="line">			  		&#125;)</div><div class="line">			  &#125;, &#123;</div><div class="line">			  	rootMargin: '100px',</div><div class="line">			  	threshold: [0.000001]</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line">			let eleArray = Array.from(document.getElementsByClassName('img-item'));</div><div class="line">			eleArray.forEach((item) =&gt; &#123;</div><div class="line">				ele.observe(item);</div><div class="line">			&#125;)</div><div class="line">		&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>无限滚动的栗子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="en"&gt;</div><div class="line">	&lt;head&gt;</div><div class="line">		&lt;meta charset="utf-8" /&gt;</div><div class="line">		&lt;title&gt;intersectionObserve&lt;/title&gt;</div><div class="line">		&lt;style type="text/css"&gt;</div><div class="line">			.img &#123;</div><div class="line">				height: 1200px;</div><div class="line">				overflow: hidden;</div><div class="line">			&#125;</div><div class="line">			#flag &#123;</div><div class="line">				height: 20px;</div><div class="line">				background-color: pink;</div><div class="line">			&#125;</div><div class="line">		&lt;/style&gt;</div><div class="line">	&lt;/head&gt;</div><div class="line">	&lt;body&gt;</div><div class="line">		&lt;ul id="imgContainer"&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="http://okzzg7ifm.bkt.clouddn.com/cat.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="http://okzzg7ifm.bkt.clouddn.com/01.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="http://okzzg7ifm.bkt.clouddn.com/virtualdom.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">			&lt;li class="img"&gt;</div><div class="line">				&lt;img src="http://okzzg7ifm.bkt.clouddn.com/reactlife.png"/&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">		&lt;/ul&gt;</div><div class="line">		&lt;div id="flag"&gt;&lt;/div&gt;</div><div class="line">		&lt;script type="text/javascript"&gt;</div><div class="line">			let imgList = [</div><div class="line">				'http://okzzg7ifm.bkt.clouddn.com/immutable-coperation.png',</div><div class="line">				'http://okzzg7ifm.bkt.clouddn.com/flexdirection.png',</div><div class="line">				'http://okzzg7ifm.bkt.clouddn.com/immutable-exampleLayout.png'</div><div class="line">			]</div><div class="line">			let ele = new IntersectionObserver(</div><div class="line">				(entries) =&gt; &#123;</div><div class="line">					if (entries[0].intersectionRatio &gt; 0) &#123;</div><div class="line">						if (imgList.length) &#123;</div><div class="line">							let newImgli = document.createElement('li');</div><div class="line">							newImgli.setAttribute("class", "img");</div><div class="line">							let newImg = document.createElement('img');</div><div class="line">							newImg.setAttribute("src", imgList[0]);</div><div class="line">							newImgli.appendChild(newImg);</div><div class="line">							document.getElementById('imgContainer').appendChild(newImgli);</div><div class="line">							imgList.shift();</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line"></div><div class="line">			  &#125;, &#123;</div><div class="line">			  	rootMargin: '100px',</div><div class="line">			  	threshold: [0.000001]</div><div class="line">			  &#125;</div><div class="line">			);</div><div class="line">			ele.observe(flag);</div><div class="line">		&lt;/script&gt;</div><div class="line">	&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>通篇看下来大家是不是感觉这个API还是很好玩的，然而因为其兼容性，所以使用区域还是受限的。基于此，规范制订者在github上发布了其<a href="https://github.com/w3c/IntersectionObserver" target="_blank" rel="external">Polyfill</a>，不过因为是Polyfill，所以在实现性能上肯定是比不上原生的。而且就其github来看，待解决的issue数量还是比较多的。</p>
<h4 id="具体集成到项目中【项目本身基于vue】"><a href="#具体集成到项目中【项目本身基于vue】" class="headerlink" title="具体集成到项目中【项目本身基于vue】"></a>具体集成到项目中【项目本身基于vue】</h4><p>实际项目里面可能需要使用到曝光的地方相当的多，这里我们就首页进行了尝试，主要有以下几个问题需要解决：</p>
<ul>
<li>实例的创建时间</li>
<li>observe()调用的时机</li>
<li>dom元素与埋点数据的关联</li>
</ul>
<p>针对实例的创建时间，因为首页上需要划分区域进行曝光报告，因此我选择在整个页面的初始化的时候就进行实例的创建。同时，因为希望整个埋点的处理逻辑一致，在实例的回调里面进行了统一处理。具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">   this.ele = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</div><div class="line">          entries.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">if</span> (item.intersectionRatio &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">let</span> node = item.target.querySelector(<span class="string">'.need-data'</span>);</div><div class="line">              <span class="built_in">console</span>.log(node.attributes[<span class="string">'code'</span>].value);</div><div class="line">            &#125;</div><div class="line">          &#125;)</div><div class="line">        &#125;, &#123;</div><div class="line">          <span class="attr">threshold</span>: [<span class="number">0.000001</span>]</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>observe()调用的时机，因为页面采用组件化的方式，在最初进行实例化的时候，需要的dom结构都是没有的。之后通过与后端进行数据，采用数据驱动进行页面渲染。因此在数据获取后在下一次DOM循环更新之后才进行observe()的调用。此时所需的dom结构都有了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> newArray = <span class="built_in">Array</span>.from(<span class="built_in">document</span>.getElementsByClassName(<span class="string">'need-data'</span>));</div><div class="line">            newArray.forEach(<span class="function">(<span class="params">newItem</span>) =&gt;</span> &#123;</div><div class="line">              <span class="keyword">this</span>.ele.observe(newItem);</div><div class="line">            &#125;)</div><div class="line">          &#125;)</div></pre></td></tr></table></figure>
<p>dom元素与埋点数据的关联，因为之前的逻辑中我们的dom与业务数据耦合度不大，因此获取单纯的dom后无法获取需要上报的数据。同时我们希望这一块对于大部分的曝光需求能够进行逻辑统一。因此我们采取了最简单的方法，将需要上报的数据直接放在dom的一个属性中。因为这部分dom是组件化生成的一部分，所以逻辑上也是一致的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item-content clearfix"</span> :<span class="class"><span class="keyword">class</span></span>=<span class="string">"'item-wrapper-type'+type"</span> :code=<span class="string">"needData.code"</span>&gt;</div><div class="line">....</div><div class="line">&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure>
<p>基本进行这三个地方的改动后就能满足我们的大部分类型的需求了。其最后的结果如下:<br><img src="http://okzzg7ifm.bkt.clouddn.com/dataResult.png" alt="结果图"></p>
<h4 id="利弊介绍"><a href="#利弊介绍" class="headerlink" title="利弊介绍"></a>利弊介绍</h4><ul>
<li>优<ul>
<li>性能比直接的监听scroll事件或者设置timer都好</li>
<li>使用简单</li>
<li>利用它的功能组合可以实现很多其他效果，比如无限滚动等</li>
<li>对iframe的支持好</li>
</ul>
</li>
<li>缺<ul>
<li>兼容性不好</li>
<li>它不是完美像素与无延迟的，毕竟根本上是异步的。因此不适合做滚动动画</li>
</ul>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://www.cnblogs.com/ziyunfei/p/5558712.html" target="_blank" rel="external">IntersectionObserver API</a>: 强烈推荐这篇文章，干货满满</li>
<li><a href="https://w3c.github.io/IntersectionObserver/#intersection-observer-processing-model" target="_blank" rel="external">Intersection Observer</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank" rel="external">Intersection Observer API</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API/Timing_element_visibility" target="_blank" rel="external">Timing element visibility with the Intersection Observer API</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了IntersectionObserver API，并且就如何将其用于数据埋点给出了尝试。&lt;/p&gt;
    
    </summary>
    
      <category term="lulutia" scheme="http://xgfe.github.io/categories/lulutia/"/>
    
    
      <category term="data" scheme="http://xgfe.github.io/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>关于富文本AttributedString的使用总结</title>
    <link href="http://xgfe.github.io/2017/09/22/Sudaxi/attributeStr1/"/>
    <id>http://xgfe.github.io/2017/09/22/Sudaxi/attributeStr1/</id>
    <published>2017-09-22T08:00:00.000Z</published>
    <updated>2017-10-16T10:03:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析了富文本常用的属性设置，平时工作过程经常遇到一些有特殊需求的label、UITextField、UITextView。一般情况下，大家都喜欢直接用多个label来实现其不同的属性，很多人忽略了label本身的富文本属性。本文针对富文本进行了详细的介绍。<br><a id="more"></a></p>
<p>首先先大概了解一下NSAttributedString 的21个属性。<br>常见的属性大概如下：<br><img src="http://p0.meituan.net/xgfe/8ac5ef6b34677319cfc020c8a1406681105850.jpg" width="600" height="600" alt="常见属性"></p>
<p>API: Character Attributes , NSAttributedString 共有21个属性</p>
<pre><code>1. NSFontAttributeName -&gt;设置字体属性，默认值：字体：Helvetica(Neue) 字号：12
2. NSParagraphStyleAttributeName -&gt;设置文本段落排版格式，取值为 NSParagraphStyle 对象
3. NSForegroundColorAttributeName -&gt;设置字体颜色，取值为 UIColor对象，默认值为黑色
4. NSBackgroundColorAttributeName -&gt;设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色
5. NSLigatureAttributeName -&gt;设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符
6. NSKernAttributeName -&gt;设置字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄
7. NSStrikethroughStyleAttributeName -&gt;设置删除线，取值为 NSNumber 对象（整数）
8. NSStrikethroughColorAttributeName -&gt;设置删除线颜色，取值为 UIColor 对象，默认值为黑色
9. NSUnderlineStyleAttributeName -&gt;设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似
10. NSUnderlineColorAttributeName -&gt;设置下划线颜色，取值为 UIColor 对象，默认值为黑色
11. NSStrokeWidthAttributeName -&gt;设置笔画宽度(粗细)，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果
12. NSStrokeColorAttributeName -&gt;填充部分颜色，不是字体颜色，取值为 UIColor 对象
13. NSShadowAttributeName -&gt;设置阴影属性，取值为 NSShadow 对象
14. NSTextEffectAttributeName -&gt;设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用
15. NSBaselineOffsetAttributeName -&gt;设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏
16. NSObliquenessAttributeName -&gt;设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾
17. NSExpansionAttributeName -&gt;设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本
18. NSWritingDirectionAttributeName -&gt;设置文字书写方向，从左向右书写或者从右向左书写
19. NSVerticalGlyphFormAttributeName -&gt;设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本
20. NSLinkAttributeName -&gt;设置链接属性，点击后调用浏览器打开指定URL地址
21.NSAttachmentAttributeName -&gt;设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排
</code></pre><p>下面分别详细介绍整段文字不同属性的两种使用方式：</p>
<p>1、对一整段文字进行初始化，分范围（range主要是NSMakeRange(NSUInteger loc, NSUInteger len)）下标和长度进行属性化。实现不同的文字样式，再进行控件赋值。</p>
<pre><code>//其中\n可以达到分行的效果
NSString *str = @&quot;鲁班七号\n啦哈哈哈哈，不得了了。\n有人需要技术支持吗？\n鲁班大师，智商二百五，膜拜，极度膜拜。\n正在思考，如何攻克地心引力。\n请你们绕行，见识新发明的威力。\n不得不承认，有时候肌肉比头脑管用。\n检测了对面的智商，嘿嘿嘿，看来无法发挥全部实力啦。\n漏漏漏漏漏漏油啦。\n看，天上的飞机。\n相信科学。\n刮风了，吓到了。\n我想静～静～～&quot;;
NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:str];
//改变某个范围的文字颜色
[attributedStr addAttribute:NSForegroundColorAttributeName value:[UIColor magentaColor] range:NSMakeRange(16, 10)];
//设置特殊字体
[attributedStr addAttribute:NSFontAttributeName value:[UIFont boldSystemFontOfSize:20] range:NSMakeRange(27, 4)];

[attributedStr addAttributes:@{NSFontAttributeName:[UIFont boldSystemFontOfSize:17],
                               NSUnderlineStyleAttributeName:@1,
                               NSUnderlineColorAttributeName:[UIColor redColor]
                               } range:NSMakeRange(32, 5)];

[attributedStr addAttributes:@{NSFontAttributeName:[UIFont boldSystemFontOfSize:30],
                               NSForegroundColorAttributeName:[UIColor brownColor],
                               NSBackgroundColorAttributeName:[UIColor yellowColor]
                               } range:NSMakeRange(0, 4)];
//给控件赋值
self.showLa.attributedText = attributedStr;
</code></pre><p> 运行效果如下：<br> <img src="http://p0.meituan.net/xgfe/c2aebeaf980a1a784389fa2c4afa2efa113929.jpg" width="300" height="300" alt=""></p>
<p> 2、整段文字，根据不同的需求，拆分成n个string。创建字典，将每个string的属性初始化。然后通过拼接string将文字串起来。再给控件的赋值</p>
<pre><code> NSMutableAttributedString *muAttributedStr = [[NSMutableAttributedString alloc] init];
 NSString *titleStr = @&quot;王昭君。\n&quot;;
 NSDictionary *titleDict = @{
                             NSFontAttributeName:[UIFont boldSystemFontOfSize:30],
                             NSForegroundColorAttributeName:[UIColor brownColor],
                             NSBackgroundColorAttributeName:[UIColor yellowColor]
                             };
 NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:titleStr attributes:titleDict];
 [muAttributedStr appendAttributedString:attStr];

 NSShadow *shadow = [[NSShadow alloc] init];
 shadow.shadowColor = [UIColor purpleColor];
 shadow.shadowOffset = CGSizeMake(5, 5);
 shadow.shadowBlurRadius = 3.0; 
NSString *str1 = @&quot;凛冬已至，故乡的梅花开了吗。\n心已经融化。\n身躯已然冰封，灵魂仍旧火热。\n寒梅，无处不在。\n&quot;;
NSDictionary *dict1 = @{
                         NSKernAttributeName:@5,//字符间距
                         NSShadowAttributeName:shadow,//阴影
                         NSStrikethroughStyleAttributeName:@2,
                         NSStrikethroughColorAttributeName:[UIColor redColor]
                         };
 NSAttributedString *attStr1 = [[NSAttributedString alloc] initWithString:str1 attributes:dict1];
 [muAttributedStr appendAttributedString:attStr1];


 NSString *str2 = @&quot;凛寒梅，无处不在。\n替你们消消火。\n&quot;;
 NSDictionary *dict2 = @{
                         NSKernAttributeName:@5,//字符间距
                         NSShadowAttributeName:shadow,//阴影
                         NSStrikethroughStyleAttributeName:@2,
                         NSStrikethroughColorAttributeName:[UIColor redColor]
                         };
 NSAttributedString *attStr2 = [[NSAttributedString alloc] initWithString:str2 attributes:dict2];
 [muAttributedStr appendAttributedString:attStr2];

 NSString *str3 = @&quot;百梅落下之日，归去故里之时。\n&quot;;
 NSDictionary *dict3 = @{
                         NSBaselineOffsetAttributeName:@5,
                         NSUnderlineStyleAttributeName:@1,
                         NSUnderlineColorAttributeName:[UIColor redColor],
                         NSObliquenessAttributeName:@1
                         };
 NSAttributedString *attStr3 = [[NSAttributedString alloc] initWithString:str3 attributes:dict3];
 [muAttributedStr appendAttributedString:attStr3];

 NSString *str31 = @&quot;美貌是种罪孽，暴雪也无法掩埋。\n&quot;;
 NSDictionary *dict31 = @{
                         NSBaselineOffsetAttributeName:@2,
                         NSUnderlineStyleAttributeName:@3,
                         NSUnderlineColorAttributeName:[UIColor yellowColor],
                         NSObliquenessAttributeName:@0
                         };
 NSAttributedString *attStr31 = [[NSAttributedString alloc] initWithString:str31 attributes:dict31];
 [muAttributedStr appendAttributedString:attStr31];

 NSString *str32 = @&quot;看见了.....故乡的.......春天。\n&quot;;
 NSDictionary *dict32 = @{
                          NSBaselineOffsetAttributeName:@24,
                          NSUnderlineStyleAttributeName:@2,
                          NSUnderlineColorAttributeName:[UIColor greenColor],
                          NSObliquenessAttributeName:@(-1),
                          NSExpansionAttributeName:@(-0.5)
                          };
 NSAttributedString *attStr32 = [[NSAttributedString alloc] initWithString:str32 attributes:dict32];
 [muAttributedStr appendAttributedString:attStr32];
</code></pre><p>其中需要注意的是：<br>NSStrikethroughStyleAttributeName（删除线）、NSUnderlineStyleAttributeName的value（下划线）: 1~7单线,依次加粗  9~15:双线,依次加粗<br>NSObliquenessAttributeName（倾斜）：正值右倾,负值左倾<br> 运行效果如下：<br> <img src="http://p1.meituan.net/xgfe/9da9d0eeed5b545b73b8e7d14e2b3afe99240.jpg" width="300" height="300" alt=""></p>
<p>图文混排的使用：<br>一、将图片和文字分别初始化成不同的NSAttributedString，然后拼接到NSMutableAttributedString，赋值到控件上。</p>
<pre><code>NSString *str1= @&quot;刻骨铭心~霸王！明媚如风，轻盈似箭！啊~已经放弃了做个淑女~&quot;;
NSString *str2= @&quot;净化森林，净化污秽，净化心灵，净化自己。风会带走你曾经存在过的证明。&quot;;

NSMutableAttributedString *muAttributedStr = [[NSMutableAttributedString alloc] init];

NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:str1 attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:16],
                                                                                          NSForegroundColorAttributeName:[UIColor magentaColor]
                                                                                          }];
NSTextAttachment *attachment = [[NSTextAttachment alloc]init];
attachment.image = [UIImage imageNamed:@&quot;yujiphoto&quot;];
attachment.bounds = CGRectMake(0, 0, 110, 70);

NSAttributedString *attStr1 = [NSAttributedString attributedStringWithAttachment:attachment];

NSAttributedString *attStr2= [[NSAttributedString alloc] initWithString:str2 attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:14],
                                                                                          NSBackgroundColorAttributeName:[UIColor clearColor]}];

 [muAttributedStr appendAttributedString:attStr];
 [muAttributedStr appendAttributedString:attStr1];
 [muAttributedStr appendAttributedString:attStr2];
</code></pre><p>二、使用insertAttributedString将图片插入到文字中。</p>
<pre><code>NSString *str3 = @&quot;一点疼痛能让偷窥者牢记我的魅力！不为所爱之人哭泣，只因从未离去。想和风比赛脚力吗？弱小，并非服从恐惧的理由！&quot;;
NSMutableAttributedString *mustr = [[NSMutableAttributedString alloc] initWithString:str3];
NSTextAttachment *attachMent1 = [[NSTextAttachment alloc] init];
attachMent1.image = [UIImage imageNamed:@&quot;photo23&quot;];
attachMent1.bounds = CGRectMake(0, 0, 110, 70);
[mustr addAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:20],
                         NSForegroundColorAttributeName:[UIColor greenColor]
                         } range:NSMakeRange(0, 8)];
NSAttributedString *att = [NSAttributedString attributedStringWithAttachment:attachMent1];
[mustr insertAttributedString:att atIndex:6];
[muAttributedStr appendAttributedString:mustr];
使用
self.showLa.attributedText = muAttributedStr;
</code></pre><p> 运行效果如下：<br>  <img src="http://p0.meituan.net/xgfe/dccd36a6ac1a8845cbad513316355332110431.jpg" width="300" height="300" alt=""></p>
<p>介绍了富文本的常用属性，并且介绍了一些常用的场景后，安利一个富文本第三方库—YYText（github的地址—<a href="https://github.com/ibireme/YYText）。详细的使用可以参考一下github上面的介绍。" target="_blank" rel="external">https://github.com/ibireme/YYText）。详细的使用可以参考一下github上面的介绍。</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分析了富文本常用的属性设置，平时工作过程经常遇到一些有特殊需求的label、UITextField、UITextView。一般情况下，大家都喜欢直接用多个label来实现其不同的属性，很多人忽略了label本身的富文本属性。本文针对富文本进行了详细的介绍。&lt;br&gt;
    
    </summary>
    
      <category term="Sudaxi" scheme="http://xgfe.github.io/categories/Sudaxi/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>由一个表格需求引发的blog-DOM中的尺寸属性</title>
    <link href="http://xgfe.github.io/2017/09/20/Young/DOM-size/"/>
    <id>http://xgfe.github.io/2017/09/20/Young/DOM-size/</id>
    <published>2017-09-20T08:37:00.000Z</published>
    <updated>2017-10-16T10:03:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近数据平台有一个需求，页面滚动的时候，表格的表头悬停在页面顶部，实现的时候遇到了不少问题，也尝试了几种方案，下一篇blog会尝试分享一下，由于涉及到较多的DOM操作，尤其是各种尺寸位置属性，所以对这些尺寸属性的含义做了一些总结。</p>
<a id="more"></a>
<h2 id="偏移量相关属性"><a href="#偏移量相关属性" class="headerlink" title="偏移量相关属性"></a>偏移量相关属性</h2><p>偏移量相关属性包括偏移量尺寸和位置属性，其中偏移量尺寸指的是元素在屏幕上占用的所有可见空间，包括其内容区的空间，内边距，边框以及滚动条占用的空间（不包括外边距）。偏移量位置属性是一个相对的概念，其偏移量是参照最近的定位（display值非none或static）祖先元素计算的。以像素作为单位。</p>
<ol>
<li><p>偏移量尺寸</p>
<ul>
<li>offsetWidth:元素在水平方向占用的空间大小，包括元素内容区的宽度，左右内边距的宽度，垂直滚动条的宽度，左右边框的宽度。</li>
<li>offsetHeight:元素在垂直方向占用的空间大小，包括元素内容区高度，上下内边距的高度，水平滚动条的高度，上下边框的高度。</li>
</ul>
</li>
<li><p>偏移量位置</p>
<ul>
<li>offsetParent:返回被引用元素最近的定位过的祖先元素。如果没有定位过的祖先元素，则返回body。</li>
<li>offsetTop:被引用元素上边框的外边缘与其offsetParent上边框的内边缘之间像素距离。</li>
<li>offsetLeft:被引用元素左边框的外边缘与其offsetParent左边框的内边缘之间的像素距离。</li>
</ul>
</li>
</ol>
<p><strong>用法：</strong>通常，如果想要获取某个元素在页面上的偏移量，将这个元素的offsetLeft或offsetTop与其offsetParent的相同属性相加，递归的计算直到根元素，就可以得到一个比较准确的结果。需要注意上述属性都是只读的，每次访问都需要重新计算。</p>
<h2 id="客户区尺寸"><a href="#客户区尺寸" class="headerlink" title="客户区尺寸"></a>客户区尺寸</h2><p>客户区尺寸只与元素自身所占区域大小有关，相关的属性如下。</p>
<ul>
<li>clientWidth:元素内容区宽度加上左右内边距的宽度。</li>
<li>clientHeight:元素内容区高度加上上下内边距的高度。</li>
<li>clientTop:元素上边框的宽度。</li>
<li>clientLeft:元素左边框的宽度。</li>
</ul>
<p><strong>用法：</strong>最常见的用途之一是用来确定浏览器视口的尺寸，根据浏览器的支持情况，使用document.documentElement或者document.body的相应尺寸来获取视口宽高信息。</p>
<h2 id="滚动元素相关属性"><a href="#滚动元素相关属性" class="headerlink" title="滚动元素相关属性"></a>滚动元素相关属性</h2><p>滚动元素是包含滚动条的元素，相关属性如下。</p>
<ol>
<li><p>滚动尺寸</p>
<ul>
<li>scrollWidth:元素内容的实际宽度（包含左右内边距），即在没有滚动条的情况下，元素内容的总宽度。</li>
<li>scrollHeight:元素内容的实际高度（包含上下内边距），即在没有滚动条的情况下，元素内容的总高度。</li>
</ul>
</li>
<li><p>滚动位置</p>
<ul>
<li>scrollTop:被隐藏在内容区域上方的像素数，这个属性和scrollLeft均是可配置的，可以通过设置这个属性的值来改变元素滚动的位置。</li>
<li>scrollLeft:被隐藏在内容区域左侧的像素数。</li>
</ul>
</li>
</ol>
<p><strong>用法：</strong>滚动尺寸主要用来确定元素内容的实际大小，滚动位置既可以用来确定当前滚动的状态也可以设置滚动位置。一个很常见的使用场景就是判断页面的滚动情况，不同的浏览器的获取scrollTop方法不同，document.documentElement返回的是文档的根节点即<html>，document.body返回的是body，在chrome中，获取页面scrollTop只能通过document.body.scrollTop来获取，document.documentElement获取相同属性始终返回0，而在FF下（只测试了chrome和FF）正好相反。</html></p>
<h2 id="无图无真相"><a href="#无图无真相" class="headerlink" title="无图无真相"></a>无图无真相</h2><p>作为一个斗图新人，没有图没有底气，所以虽然手残，我还是画了一个图，首先我们就假装图中那个灰色的东西是滚动条，然后看图对应上述属性吧~</p>
<p><img src="http://p1.meituan.net/xgfe/447fe588baa4cd81ed6e3cd6fc38b55d85970.png" alt=""></p>
<h2 id="事件event位置"><a href="#事件event位置" class="headerlink" title="事件event位置"></a>事件event位置</h2><p>对于页面中发生的事件，获取点击事件鼠标的位置信息在应用中很常见，以垂直位置为例，常用相关属性有三个：pageY, clientY, screenY。</p>
<ul>
<li>pageY:鼠标在页面上的文档坐标，以文档为参照，距离文档左上角的垂直像素距离，所以这个属性和页面是否滚动无关。</li>
<li>clientY:以视口为参照，鼠标距离视口左上角的垂直像素距离。</li>
<li>screenY:以浏览器为参照，鼠标距离浏览器左上角的垂直像素距离，包含工具栏之类。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近数据平台有一个需求，页面滚动的时候，表格的表头悬停在页面顶部，实现的时候遇到了不少问题，也尝试了几种方案，下一篇blog会尝试分享一下，由于涉及到较多的DOM操作，尤其是各种尺寸位置属性，所以对这些尺寸属性的含义做了一些总结。&lt;/p&gt;
    
    </summary>
    
      <category term="Young" scheme="http://xgfe.github.io/categories/Young/"/>
    
    
      <category term="DOM" scheme="http://xgfe.github.io/tags/DOM/"/>
    
      <category term="跨浏览器属性" scheme="http://xgfe.github.io/tags/%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintLayout 采用代码方式布局用法简介</title>
    <link href="http://xgfe.github.io/2017/09/17/ivanchou/layout-with-constraintlayout-by-programming/"/>
    <id>http://xgfe.github.io/2017/09/17/ivanchou/layout-with-constraintlayout-by-programming/</id>
    <published>2017-09-16T16:00:00.000Z</published>
    <updated>2017-09-21T09:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 ConstraintLayout 的 xml 方式布局的介绍有很多，但是你知道 ConstraintSet 吗？<br>本文对于 ConstraintLayout 采用代码进行布局的方式进行了介绍。</p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们知道，Android 界面的布局按照传统方式是通过编写 xml 代码去实现的。虽然 Android Studio 提供可视化的方式去编写界面，但是并没有编写 xml 代码好用。为了解决这一问题 ConstraintLayout 诞生了，这是 Google 在 I/O 2016 推出的用可视化的方式编写界面的布局。（注：从 Android Studio 2.2 开始提供支持）</p>
<p>ConstraintLayout 的优点在于使用扁平的层次结构创建出复杂的布局，类似于 RelativeLayout 通过定义自身与其他 View 或者 Parent 之间的关系实现布局，ConstraintLayout 比 RelativeLayout 更加灵活。同时，在 Android Studio 中可以且推荐使用可视化的方式去编写界面。</p>
<ul>
<li><p>在 xml 中使用</p>
<p>  关于 xml 方式进行布局的资料有很多，就不再赘述了。</p>
</li>
<li><p>通过编程的方式布局</p>
<p>  android.support.constraint 包下有四个类，分别是 ConstraintLayout、ConstraintLayout.LayoutParams、ConstraintSet 与 Guideline。官方文档对它们的说明如下表，</p>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>类名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConstraintLayout</td>
<td>A ConstraintLayout is a ViewGroup which allows you to position and size widgets in a flexible way.</td>
</tr>
<tr>
<td>ConstraintLayout.LayoutParams</td>
<td>This class contains the different attributes specifying how a view want to be laid out inside a ConstraintLayout.</td>
</tr>
<tr>
<td>ConstraintSet</td>
<td>This class allows you to define programmatically a set of constraints to be used with ConstraintLayout.</td>
</tr>
<tr>
<td>Guideline</td>
<td>Utility class representing a Guideline helper object for ConstraintLayout.</td>
</tr>
</tbody>
</table>
</blockquote>
<p>   对于 ConstraintSet 的描述是可以通过编程的方式定义一系列约束，本文的主题就是围绕着 ConstraintSet 来进行的。</p>
<h2 id="编程实现约束布局"><a href="#编程实现约束布局" class="headerlink" title="编程实现约束布局"></a>编程实现约束布局</h2><p>要通过编程的方式实现约束布局，分为以下几个步骤：</p>
<ul>
<li><p>添加 View 到 Activity 中</p>
<p>  在 onCreate() 方法中创建 ConstraintLayout，并添加两个按钮到布局上，通过 setContentView() 设置 Activity 的布局。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    Button mOkBtn;</div><div class="line">    Button mCancelBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        ConstraintLayout cl = <span class="keyword">new</span> ConstraintLayout(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mOkBtn = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</div><div class="line">        mOkBtn.setText(<span class="string">"OK"</span>);</div><div class="line">        cl.addView(mOkBtn);</div><div class="line"></div><div class="line">        mCancelBtn = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</div><div class="line">        mCancelBtn.setText(<span class="string">"Cancel"</span>);</div><div class="line">        cl.addView(mCancelBtn);</div><div class="line"></div><div class="line">        setContentView(cl);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>给 View 设置 id</p>
<p>  通常在 xml 中添加 View 时，Android SDK 会自动帮我们生成资源文件的 id，存储在 R.java 中。但是通过代码的方式并不会触发生成 id，所以需要进行手动绑定。</p>
<p>  首先，在 res/values 目录中新建一个资源文件 ids.xml，</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"btnCancel"</span> <span class="attr">type</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"btnOk"</span> <span class="attr">type</span>=<span class="string">"id"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  然后在代码中进行绑定，</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mOkBtn.setId(R.id.btnOk);</div><div class="line">mCancelBtn.setId(R.id.btnCancel);</div></pre></td></tr></table></figure>
<p>  这时候之后设置的相关约束才会真正生效。</p>
</li>
<li><p>设置 View 的属性</p>
<p>  必须设置的属性除了 view id 还有宽高，宽高属性是通过 ConstraintSet 来设置的，通过指定 view id 及可选的有水平方向的依赖以及垂直方向的依赖。</p>
<p>  我们知道采用 xml 进行布局的时候对于宽高的设置有三种选项，分别是 wrap_content、match constraints(0dp) 以及 fixed ，而通过代码的方式只有前面两种，没有 fiexd 这个选项。</p>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">常量值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ConstraintSet.WRAP_CONTENT</td>
<td style="text-align:center">WRAP_CONTENT</td>
</tr>
<tr>
<td style="text-align:left">ConstraintSet.MATCH_CONSTRAINT</td>
<td style="text-align:center">0 dp</td>
</tr>
</tbody>
</table>
</blockquote>
<p>设置 view 宽高的方法如下，</p>
<blockquote>
<table>
<thead>
<tr>
<th>xml 属性</th>
<th>对应方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>android:layout_height</td>
<td>ConstraintSet.constrainHeight(int viewId, int height)</td>
</tr>
<tr>
<td>android:layout_width</td>
<td>ConstraintSet.constrainWidth(int viewId, int width)</td>
</tr>
</tbody>
</table>
</blockquote>
<ul>
<li><p>配置依赖关系 ConstraintSet</p>
<p>  官方推荐使用 ConstraintSet 来进行约束配置，这里很奇怪为什么不能通过 LayoutParams 来配置依赖关系。ConstraintSet 可以用来通过编程的方式定义一系列用在 ConstraintLayout 上的约束，可以用来创建、保存约束，并且可以将其应用在已有的 ConstraintLayout 上，可以通过以下 3 种方式来获取 ConstraintSet。</p>
<ol>
<li><p>手动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c = <span class="keyword">new</span> ConstraintSet(); c.connect(....);</div></pre></td></tr></table></figure>
</li>
<li><p>读取 xml 文件中的约束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.clone(context, R.layout.layout1);</div></pre></td></tr></table></figure>
</li>
<li><p>从其他 ConstraintLayout 复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c.clone(clayout);</div></pre></td></tr></table></figure>
<p>第2、3两种方法具体使用参见官方文档说明，这篇文章主要介绍手动编码的方式，我们重点来看 connect 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> startID, <span class="keyword">int</span> startSide, <span class="keyword">int</span> endID, <span class="keyword">int</span> endSide, <span class="keyword">int</span> margin)</span></span></div></pre></td></tr></table></figure>
<p>connect 方法需要四个参数，可以理解为连线的起始 view 的边与终止 view 的边，描述一个 view 的边需要通过 view id 与 side 来确定，对应到 xml 中则是 layout_constraint{$startSide}_to{$endSide}Of = “endID” 属性。这里的 view id 非常重要，在没有设置 view id 的情况下会导致无法找到正确的 view，也就无法正确应用约束设置。</p>
<p>尝试在代码中打印出 view id 的值，可以发现通过 new 方式得到的 view 的 id 默认为 -1，也正是因为这个原因，你会发现没有设置 view id 的情况下布局并没有生效。ConstraintSet 中用来描述约束特征的常量有如下几种，</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>常量值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ConstraintSet.LEFT</td>
<td>View 的左边界</td>
</tr>
<tr>
<td>ConstraintSet.RIGHT</td>
<td>View 的右边界</td>
</tr>
<tr>
<td>ConstraintSet.TOP</td>
<td>View 的顶部</td>
</tr>
<tr>
<td>ConstraintSet.BOTTOM</td>
<td>View 的底部</td>
</tr>
<tr>
<td>ConstraintSet.BASELINE</td>
<td>View 中 text 的基线</td>
</tr>
<tr>
<td>ConstraintSet.PARENT_ID</td>
<td>父控件的 id，通常情况下为 ConstraintLayout</td>
</tr>
</tbody>
</table>
</blockquote>
<ul>
<li><p>dpTopx</p>
<p>  通常我们在 xml 中可以直接输入具体的 dp 值，但是在代码中具体的数值代表的是 px，所以需要根据屏幕具体的分辨率进行转换。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpToPx</span><span class="params">(<span class="keyword">int</span> dp)</span> </span>&#123;</div><div class="line">    DisplayMetrics displayMetrics = getContext().getResources().getDisplayMetrics();</div><div class="line">    <span class="keyword">return</span> Math.round(dp * (displayMetrics.xdpi / DisplayMetrics.DENSITY_DEFAULT));     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>接下来我们通过一个简单的 demo 来了解一下 ConstraintSet 的用法。编写一个只包含确定、取消按钮的界面，采用 xml 的方式配置的代码如下，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/btnCancel"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_marginBottom</span>=<span class="string">"8dp"</span></div><div class="line">    <span class="attr">android:layout_marginLeft</span>=<span class="string">"8dp"</span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"Cancel"</span></div><div class="line">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></div><div class="line">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/btnOK"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">    <span class="attr">android:layout_marginBottom</span>=<span class="string">"8dp"</span></div><div class="line">    <span class="attr">android:layout_marginRight</span>=<span class="string">"8dp"</span></div><div class="line">    <span class="attr">android:text</span>=<span class="string">"OK"</span></div><div class="line">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></div><div class="line">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span> /&gt;</div></pre></td></tr></table></figure>
<p>将其转换成对应的 Java code，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    Button mOkBtn;</div><div class="line">    Button mCancelBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">        ConstraintLayout cl = <span class="keyword">new</span> ConstraintLayout(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mOkBtn = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</div><div class="line">        mOkBtn.setText(<span class="string">"OK"</span>);</div><div class="line">        cl.addView(mOkBtn);</div><div class="line"></div><div class="line">        mCancelBtn = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</div><div class="line">        mCancelBtn.setText(<span class="string">"Cancel"</span>);</div><div class="line">        cl.addView(mCancelBtn);</div><div class="line"></div><div class="line">        ConstraintSet set = <span class="keyword">new</span> ConstraintSet();</div><div class="line"></div><div class="line">        set.connect(mCancelBtn.getId(), ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM, dpTopx(<span class="number">8</span>));</div><div class="line">        set.connect(mCancelBtn.getId(), ConstraintSet.LEFT, ConstraintSet.PARENT_ID, ConstraintSet.LEFT, dpTopx(<span class="number">8</span>));</div><div class="line">        set.constrainHeight(mCancelBtn.getId(), ConstraintSet.WRAP_CONTENT);</div><div class="line">        set.constrainWidth(mCancelBtn.getId(), ConstraintSet.WRAP_CONTENT);</div><div class="line">        </div><div class="line">        set.connect(mOkBtn.getId(), ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID, ConstraintSet.BOTTOM, dpTopx(<span class="number">8</span>));</div><div class="line">        set.connect(mOkBtn.getId(), ConstraintSet.RIGHT, ConstraintSet.PARENT_ID, ConstraintSet.RIGHT, dpTopx(<span class="number">8</span>));</div><div class="line">        set.constrainHeight(mOkBtn.getId(), ConstraintSet.WRAP_CONTENT);</div><div class="line">        set.constrainWidth(mOkBtn.getId(), ConstraintSet.WRAP_CONTENT);</div><div class="line">        </div><div class="line">        set.applyTo(cl);</div><div class="line">        setContentView(cl);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到相比于 xml 代码，Java 代码既繁琐又长，更何况 ConstraintLayout 的出现本来就不推荐手写 xml，在 Android Stuidio 中以直接拖动的方式进行布局操作最少只需要 3 步：</p>
<ul>
<li>拖动控件到界面上</li>
<li>设置 id（可省略）</li>
<li>选中控件，将控件左边界连接到父空间的左边</li>
<li>选中控件，将控件下边界连接到父空间的底部</li>
</ul>
<p>所以采用代码的方式进行布局，效率反而进一步降低了。除非必要，这并不是一种值的推荐的方式。</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>在进行代码布局的过程中，发现对 view 设置的与父控件的左／右间隔并没有生效，不知道是不是一个已知的 bug，有待进一步深入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初次接触到 ConstraintLayout 时被这种快速便捷的操作方式吸引，意味着可以不用为了实现复杂的布局而进行多层嵌套。顺理成章，当我在自定义控件时第一时刻便想到了它，也就有了这篇简介。其实后来仔细一想这种需求还是比较奇怪，本身 ConstraintLayout 的出现是为了解决 Android 开发中可视化编辑界面的不便，然而偏要选择写 xml 的方式去布局，甚至是 Java code，那就是自找麻烦了。这可能也是为什么官方没有在 Tutorial 中提及而只是在 API Doc 中一笔带过的原因吧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://developer.android.com/training/constraint-layout/index.html" target="_blank" rel="external">Build a Responsive UI with ConstraintLayout | Android Developers</a></li>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/53122387" target="_blank" rel="external">Android新特性介绍，ConstraintLayout完全解析</a></li>
<li><a href="https://developer.android.com/reference/android/support/constraint/package-summary.html" target="_blank" rel="external">ConstraintLayout | Android Developers</a></li>
<li><a href="http://www.techotopia.com/index.php/An_Android_ConstraintSet_Tutorial" target="_blank" rel="external">An Android ConstraintSet Tutorial</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 ConstraintLayout 的 xml 方式布局的介绍有很多，但是你知道 ConstraintSet 吗？&lt;br&gt;本文对于 ConstraintLayout 采用代码进行布局的方式进行了介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="ivanchou" scheme="http://xgfe.github.io/categories/ivanchou/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="布局" scheme="http://xgfe.github.io/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTML解析和资源加载</title>
    <link href="http://xgfe.github.io/2017/09/07/felix/html-parsing-and-resources-load/"/>
    <id>http://xgfe.github.io/2017/09/07/felix/html-parsing-and-resources-load/</id>
    <published>2017-09-07T03:00:00.000Z</published>
    <updated>2017-09-21T09:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习浏览器的内部工作原理将有助于您作出更明智的决策，并理解那些最佳开发实践的个中缘由。</p>
<p>本文主要针对WebKit内核的浏览器。</p>
<a id="more"></a>
<h2 id="渲染引擎工作流"><a href="#渲染引擎工作流" class="headerlink" title="渲染引擎工作流"></a>渲染引擎工作流</h2><p><img src="http://p1.meituan.net/xgfe/6112586223b0a8894049a9ece14c0201173121.png" alt=""></p>
<h2 id="HTML并行加载和解析"><a href="#HTML并行加载和解析" class="headerlink" title="HTML并行加载和解析"></a>HTML并行加载和解析</h2><ul>
<li>js是单线程的，浏览器是多线程的，chrome是多进程的</li>
<li>浏览器的多线程：<ul>
<li>GUI渲染线程</li>
<li>javascript引擎线程</li>
<li>定时器触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
<li>js引擎线程和GUI渲染线程互斥</li>
</ul>
</li>
<li>浏览器加载、解析和渲染同时进行</li>
</ul>
<h2 id="浏览器并发请求限制"><a href="#浏览器并发请求限制" class="headerlink" title="浏览器并发请求限制"></a>浏览器并发请求限制</h2><ul>
<li>webkit 同域并发请求限制为6</li>
</ul>
<h2 id="外部资源的加载规则"><a href="#外部资源的加载规则" class="headerlink" title="外部资源的加载规则"></a>外部资源的加载规则</h2><ol>
<li>HTML【highest】：iframe，非阻塞</li>
<li>css【highest】<ul>
<li>css文件异步加载和解析，不影响HTML文档的解析和DOMContentLoaded事件，但是会阻塞<strong>整个</strong>DOM的渲染</li>
<li>css文件的加载和解析会阻塞后续js文件的执行</li>
<li>内部import的css文件，立即加入请求队伍并继续阻塞后续js文件的执行</li>
</ul>
</li>
<li>javascript<ul>
<li>js文件的加载和解析会阻塞<strong>后续</strong>DOM的解析和渲染[阻塞主线程]</li>
<li>head里面的js文件【high】</li>
<li>body末尾的js文件【medium】</li>
<li>async和defer的js文件不阻塞主线程【low】</li>
</ul>
</li>
<li>图片【low】:非阻塞</li>
<li>字体文件【highest】:非阻塞</li>
<li>其他资源基本都是非阻塞且低优先级的</li>
<li>preload和prefetch(可能被浏览器忽略)不改变优先级</li>
</ol>
<p><strong>【预解析】当主线程被阻碍时，WebKit会启动另外一个线程去遍历后面的HTML网页，收集需要的资源URL，然后发送请求，这样就可以避免被阻碍。实现资源的并发下载，包括js文件。</strong></p>
<h2 id="DOMContentLoaded-和-load事件"><a href="#DOMContentLoaded-和-load事件" class="headerlink" title="DOMContentLoaded 和 load事件"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/Events/DOMContentLoaded" target="_blank" rel="external">DOMContentLoaded</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/Events/load" target="_blank" rel="external">load</a>事件</h2><ul>
<li>初始HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待<strong>样式表</strong>、<strong>图像</strong>和<strong>子框架</strong>完成加载；[完成DOMTree]</li>
<li>当一个资源及其依赖资源已完成加载时，将触发load事件。</li>
</ul>
<h2 id="js文件非阻塞加载"><a href="#js文件非阻塞加载" class="headerlink" title="js文件非阻塞加载"></a>js文件非阻塞加载</h2><ul>
<li>script[async]<ul>
<li>js文件异步加载，不阻塞主线程(HTML解析，其他js执行)</li>
<li>js文件的执行时间不可预期，不对其它流程产生影响</li>
</ul>
</li>
<li>script[defer]<ul>
<li>js文件异步加载，不阻塞主线程(HTML解析，其他js执行)</li>
<li>js文件的执行在HTML解析完成之后，所有defer js文件按顺序先后执行<ul>
<li>FF在DOMContentLoaded事件之前（defer的js文件会延迟DOMContentLoaded事件）</li>
<li>WebKit内核中不影响DOMContentLoaded事件</li>
</ul>
</li>
</ul>
</li>
<li>XHR异步请求然后eval()执行</li>
<li>动态插入script标签<ul>
<li>document.write()：同script标签，但不会阻塞当前脚本后续执行</li>
<li>动态创建script标签，再append到DOM中：同script[async]</li>
</ul>
</li>
</ul>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="external">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习浏览器的内部工作原理将有助于您作出更明智的决策，并理解那些最佳开发实践的个中缘由。&lt;/p&gt;
&lt;p&gt;本文主要针对WebKit内核的浏览器。&lt;/p&gt;
    
    </summary>
    
      <category term="felix" scheme="http://xgfe.github.io/categories/felix/"/>
    
    
      <category term="html" scheme="http://xgfe.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>如何将html保存成图片</title>
    <link href="http://xgfe.github.io/2017/09/07/huanglifen/html2image/"/>
    <id>http://xgfe.github.io/2017/09/07/huanglifen/html2image/</id>
    <published>2017-09-06T16:00:00.000Z</published>
    <updated>2017-09-21T09:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何将HTML保存成高清图片？本文带你一探究竟。<br><a id="more"></a></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>现在流行于朋友圈分享的一些活动页，经常会玩这样的一个功能：将诸如测试之类的结果页保存成图片分享至朋友圈，以此来吸引用户参与，提高活动的pv和uv。</p>
<h2 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h2><p>一般来说有这两个技术步骤：</p>
<ul>
<li>html2canvas</li>
<li>canvas2image</li>
</ul>
<p>当需要连同html中跨域的图片一起转换时，需要增加一个base步骤：</p>
<ul>
<li>image proxy（因为canvas2image不支持跨域的图片, 本篇只是点到，不做展开）</li>
<li>html2canvas</li>
<li>canvas2image</li>
</ul>
<p>首先需要将html转成canvas， 再接着将canvas转为图片，至此，用户用手机自带的功能长按就可以保存，当然你也可以自己做长按保存的功能，canvas2image 提供了保存成图片的api。</p>
<h2 id="html2canvas"><a href="#html2canvas" class="headerlink" title="html2canvas"></a>html2canvas</h2><h3 id="如何转换的"><a href="#如何转换的" class="headerlink" title="如何转换的"></a>如何转换的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">The script traverses through the DOM of the page it is loaded on. </div><div class="line">It gathers information on all the elements there, which it then uses to build a representation of the page. </div><div class="line">In other words, it does not actually take a screenshot of the page, </div><div class="line">but builds a representation of it based on the properties it reads from the DOM.</div><div class="line">As a result, it is only able to render correctly properties that it understands, </div><div class="line">meaning there are many CSS properties which do not work.</div></pre></td></tr></table></figure>
<p>翻译过来就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过脚本去遍历页面加载的DOM元素，收集所有元素的有关信息，然后用收集到的信息来构建页面的表示。</div><div class="line">换句话说，它实际上并不是页面的屏幕截图，而是基于从DOM读取的属性来构建页面的表示。</div><div class="line">因此，它只能够正确地呈现其理解的属性，这就意味着有许多CSS属性不起作用。</div></pre></td></tr></table></figure></p>
<h3 id="制约点"><a href="#制约点" class="headerlink" title="制约点"></a>制约点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">All the images that the script uses need to reside under the same origin </div><div class="line">for it to be able to read them without the assistance of a proxy. </div><div class="line">Similarly, if you have other canvas elements on the page, which have been </div><div class="line">tainted with cross-origin content, they will become dirty and no longer readable by html2canvas.</div><div class="line">The script doesn&apos;t render plugin content such as Flash or Java applets.</div><div class="line">It doesn&apos;t render iframe content either.</div></pre></td></tr></table></figure>
<p>翻译过来就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">脚本使用的所有图像都必须位于相同的起源点，以便脚本不需要代理协助就可以读取它们的信息。</div><div class="line">类似地，如果页面上有其他canvas元素，这些元素已经被不是同源的内容所污染，就不能被html2canvas读取。</div><div class="line">简单来说就两点：</div><div class="line">- 不支持跨域</div><div class="line">- 不支持HTML中包含canvas</div></pre></td></tr></table></figure></p>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>allowTaint</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td>是否允许图片跨域</td>
</tr>
<tr>
<td>background</td>
<td style="text-align:center">string</td>
<td style="text-align:center">#fff</td>
<td>画布背景颜色，如果DOM中未指定，值为透明</td>
</tr>
<tr>
<td>height</td>
<td style="text-align:center">number</td>
<td style="text-align:center">null</td>
<td>以像素为单位定义画布的高度。 如果为空，则按窗口的高度来渲染</td>
</tr>
<tr>
<td>width</td>
<td style="text-align:center">number</td>
<td style="text-align:center">null</td>
<td>以像素为单位定义画布的宽度。 如果为空，则按窗口的宽度来渲染</td>
</tr>
<tr>
<td>letterRendering</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td>是否分别渲染每一个字符，必要时使用letter-spacing</td>
</tr>
<tr>
<td>logging</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td>是否开启控制台日志</td>
</tr>
<tr>
<td>proxy</td>
<td style="text-align:center">string</td>
<td style="text-align:center">undefined</td>
<td>设置用于加载跨域图片的代理域名，如果为空，跨域的图片不会被加载</td>
</tr>
<tr>
<td>taintTest</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">true</td>
<td>设置是否在渲染前检测每张图片加载完</td>
</tr>
<tr>
<td>timeout</td>
<td style="text-align:center">number</td>
<td style="text-align:center">0</td>
<td>设置超时加载图片，毫秒为单位，设置为0则无超时</td>
</tr>
<tr>
<td>useCORS</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">false</td>
<td>是否在还原到代理服务器之前尝试将跨域的图像加载为CORS</td>
</tr>
<tr>
<td>scale</td>
<td style="text-align:center">number</td>
<td style="text-align:center">1</td>
<td>转换时放大的倍数，可以通过获取设备的像素密度来定义，也可以自定义</td>
</tr>
</tbody>
</table>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>转换后的canvas会传递到回调函数中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">html2canvas(element, &#123;</div><div class="line">    <span class="attr">onrendered</span>: <span class="function"><span class="keyword">function</span>(<span class="params">canvas</span>) </span>&#123;</div><div class="line">        <span class="comment">// canvas is the final rendered &lt;canvas&gt; element</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">html2canvas(element, options).then(<span class="function"><span class="keyword">function</span> (<span class="params">canvas</span>) </span>&#123;</div><div class="line">    <span class="comment">// canvas is the final rendered &lt;canvas&gt; element</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>想要了解更多信息，请前往官网地址：<a href="http://html2canvas.hertzen.com/" target="_blank" rel="external">http://html2canvas.hertzen.com/</a></p>
<h2 id="canvas2image"><a href="#canvas2image" class="headerlink" title="canvas2image"></a>canvas2image</h2><p>你可以使用的API:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Canvas2Image.saveAsImage(canvasObj, width, height, type)</div><div class="line">Canvas2Image.saveAsPNG(canvasObj, width, height)</div><div class="line">Canvas2Image.saveAsJPEG(canvasObj, width, height)</div><div class="line">Canvas2Image.saveAsGIF(canvasObj, width, height)</div><div class="line">Canvas2Image.saveAsBMP(canvasObj, width, height)</div><div class="line"></div><div class="line">Canvas2Image.convertToImage(canvasObj, width, height, type)</div><div class="line">Canvas2Image.convertToPNG(canvasObj, width, height)</div><div class="line">Canvas2Image.convertToJPEG(canvasObj, width, height)</div><div class="line">Canvas2Image.convertToGIF(canvasObj, width, height)</div><div class="line">Canvas2Image.convertToBMP(canvasObj, width, height)</div></pre></td></tr></table></figure></p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"html-source width-6 fl"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/timg.jpeg"</span> <span class="attr">class</span>=<span class="string">"width-6"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>图片描述文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"option-content width-4 fl"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button start-to-do"</span>&gt;</span>转换成图片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button"</span>&gt;</span>下载图片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"png-content width-6 fl"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>核心js：为获得高清的图片，先以N倍的尺寸转换成canvas, 再1：1转换成png, 最后通过样式去控制最后生成的图片展示尺寸。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> me = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> sourceContent = me.$el.$htmlSource;</div><div class="line"><span class="keyword">var</span> width = sourceContent.width();</div><div class="line"><span class="keyword">var</span> height = sourceContent.height();</div><div class="line"><span class="keyword">var</span> offsetTop = sourceContent.offset().top;</div><div class="line"><span class="keyword">var</span> offsetLeft = sourceContent.offset().left;</div><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</div><div class="line"><span class="keyword">var</span> canvas2D = canvas.getContext(<span class="string">"2d"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 不能小于1，否则图片不完整，通过获取设备的像素密度不能统一得到清晰的图片，建议写固定值</span></div><div class="line"><span class="keyword">var</span> scale = N;</div><div class="line">canvas.width = (width + offsetLeft) * scale;</div><div class="line">canvas.height = (height + offsetTop) * scale;</div><div class="line">canvas2D.scale(scale, scale);</div><div class="line">canvas2D.font = <span class="string">"Microsoft YaHei"</span>;</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line"></div><div class="line">    <span class="comment">//检测每张图片都已经加载完成</span></div><div class="line">    tainttest:<span class="literal">true</span>,</div><div class="line">    <span class="attr">canvas</span>: canvas,</div><div class="line">    <span class="attr">scale</span>: scale,</div><div class="line"></div><div class="line">    <span class="comment">//dom 放大的宽度，放大倍数和清晰度在一定范围内成正相关</span></div><div class="line">    width: width + offsetLeft,</div><div class="line"></div><div class="line">    <span class="comment">// 开启日志，可以方便调试</span></div><div class="line">    logging: <span class="literal">true</span>,</div><div class="line"></div><div class="line">    <span class="comment">//dom 放大的宽度，放大倍数和清晰度在一定范围内成正相关</span></div><div class="line">    height: height + offsetTop</div><div class="line">&#125;;</div><div class="line">html2canvas(sourceContent, options).then(<span class="function"><span class="keyword">function</span> (<span class="params">canvas</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> img = <span class="built_in">window</span>.Canvas2Image.convertToPNG(canvas, width * scale, height * scale);</div><div class="line">    me.$el.$pngContent.append(img);</div><div class="line"></div><div class="line">    <span class="comment">// 将图片恢复到原始大小</span></div><div class="line">    me.$el.$pngContent.find(<span class="string">'img'</span>).css(&#123;</div><div class="line">        <span class="attr">width</span>: width,</div><div class="line">        <span class="attr">height</span>: height</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下面是不同的倍数N，生成的不同清晰度的图片：<br><img src="http://p0.meituan.net/xgfe/9a8e54d6457a682eb167d77fd1d2d2ef594412.png" alt="效果图（倍数N: 1~3.5）"></p>
<p>之前做过一次项目，N设为3 可以满足多种主流手机的高清图片要求。</p>
<h3 id="附完整源代码"><a href="#附完整源代码" class="headerlink" title="附完整源代码"></a>附完整源代码</h3><p>需要说明的是： 页面需要运行于服务器中转换才能生效。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> win = <span class="built_in">window</span>, html = <span class="built_in">document</span>.documentElement;</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">setRem</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> width = html.getBoundingClientRect().width;</div><div class="line">                width = (width == <span class="number">980</span>) ? <span class="number">360</span> : width;</div><div class="line">                <span class="keyword">var</span> rem = width / <span class="number">20</span>;</div><div class="line">                win.rem = rem;</div><div class="line">                html.style.fontSize = rem + <span class="string">'px'</span>;</div><div class="line">            &#125;</div><div class="line">            setRem();</div><div class="line">        &#125;)();</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line">        * &#123;</div><div class="line">            padding: 0;</div><div class="line">            margin: 0;</div><div class="line">        &#125;</div><div class="line">        .main &#123;</div><div class="line">            padding: 0.2rem;</div><div class="line">            background: #fafafa;</div><div class="line">            overflow: auto;</div><div class="line">        &#125;</div><div class="line">        .width-2 &#123;</div><div class="line">            width: 2rem;</div><div class="line">        &#125;</div><div class="line">        .fl &#123;</div><div class="line">            float: left;</div><div class="line">        &#125;</div><div class="line">        .html-source &#123;</div><div class="line">            height: 10rem;</div><div class="line">        &#125;</div><div class="line">        .html-text &#123;</div><div class="line">            font-size: 0.2rem;</div><div class="line">        &#125;</div><div class="line">        .png-content &#123;</div><div class="line">            height: 20rem;</div><div class="line">        &#125;</div><div class="line">        .png-content img &#123;</div><div class="line">            border: 0;</div><div class="line">            margin: 0 0.2rem;</div><div class="line">        &#125;</div><div class="line">        .button &#123;</div><div class="line">            color: #fff;</div><div class="line">            background-color: #23b7e5;</div><div class="line">            border-color: #23b7e5;</div><div class="line">            font-weight: 500;</div><div class="line">            border-radius: 0.1rem;</div><div class="line">            outline: 0;</div><div class="line">            font-size: 0.2rem;</div><div class="line">            margin: 0 0.5rem;</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"html-source width-2 fl"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/timg.jpeg"</span> <span class="attr">class</span>=<span class="string">"width-2"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"html-text"</span>&gt;</span>图片描述文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"option-content fl"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button start-to-do"</span>&gt;</span>转换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"png-content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/html2canvas.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/canvas2image.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> page = &#123;</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.initDom();</div><div class="line">            <span class="keyword">this</span>.initEvent();</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">initDom</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.$el = &#123;&#125;;</div><div class="line">            <span class="keyword">this</span>.$el.$startBtn = $(<span class="string">'.start-to-do'</span>);</div><div class="line">            <span class="keyword">this</span>.$el.$htmlSource = $(<span class="string">'.html-source'</span>);</div><div class="line">            <span class="keyword">this</span>.$el.$pngContent = $(<span class="string">'.png-content'</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">initEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> me = <span class="keyword">this</span>;</div><div class="line">            <span class="keyword">this</span>.$el.$startBtn.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; <span class="number">8</span>; i++) &#123;</div><div class="line">                    me.initSavePng(i * <span class="number">0.5</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">initSavePng</span>: <span class="function"><span class="keyword">function</span>(<span class="params">N</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> me = <span class="keyword">this</span>;</div><div class="line">            <span class="keyword">var</span> sourceContent = me.$el.$htmlSource;</div><div class="line">            <span class="keyword">var</span> width = sourceContent.width();</div><div class="line">            <span class="keyword">var</span> height = sourceContent.height();</div><div class="line">            <span class="keyword">var</span> offsetTop = sourceContent.offset().top;</div><div class="line">            <span class="keyword">var</span> offsetLeft = sourceContent.offset().left;</div><div class="line">            <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</div><div class="line">            <span class="keyword">var</span> canvas2D = canvas.getContext(<span class="string">"2d"</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 不能小于1，否则图片不完整</span></div><div class="line">            <span class="keyword">var</span> scale = N;</div><div class="line">            canvas.width = (width + offsetLeft) * scale;</div><div class="line">            canvas.height = (height + offsetTop) * scale;</div><div class="line">            canvas2D.scale(scale, scale);</div><div class="line">            canvas2D.font = <span class="string">"Microsoft YaHei"</span>;</div><div class="line">            <span class="keyword">var</span> options = &#123;</div><div class="line"></div><div class="line">                <span class="comment">//检测每张图片都已经加载完成</span></div><div class="line">                tainttest:<span class="literal">true</span>,</div><div class="line">                <span class="attr">canvas</span>: canvas,</div><div class="line">                <span class="attr">scale</span>: scale,</div><div class="line"></div><div class="line">                <span class="comment">//dom 放大的宽度，放大倍数和清晰度在一定范围内成正相关</span></div><div class="line">                width: width + offsetLeft,</div><div class="line"></div><div class="line">                <span class="comment">// 开启日志，可以方便调试</span></div><div class="line">                logging: <span class="literal">true</span>,</div><div class="line"></div><div class="line">                <span class="comment">//dom 放大的宽度，放大倍数和清晰度在一定范围内成正相关</span></div><div class="line">                height: height + offsetTop</div><div class="line">            &#125;;</div><div class="line">            html2canvas(sourceContent, options).then(<span class="function"><span class="keyword">function</span> (<span class="params">canvas</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> img = <span class="built_in">window</span>.Canvas2Image.convertToPNG(canvas, width * scale, height * scale);</div><div class="line">                me.$el.$pngContent.append(img);</div><div class="line"></div><div class="line">                <span class="comment">// 将图片恢复到原始大小</span></div><div class="line">                me.$el.$pngContent.find(<span class="string">'img'</span>).css(&#123;</div><div class="line">                    <span class="attr">width</span>: width,</div><div class="line">                    <span class="attr">height</span>: height</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    page.init();</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>完整示例代码git地址：<a href="https://github.com/huanlifen/html2image" target="_blank" rel="external">https://github.com/huanlifen/html2image</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://github.com/niklasvh/html2canvas" target="_blank" rel="external">原版html2canvas</a><br>2.<a href="https://github.com/omwteam/html2canvas" target="_blank" rel="external">优化版html2canvas 0.5.0-beta4</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何将HTML保存成高清图片？本文带你一探究竟。&lt;br&gt;
    
    </summary>
    
      <category term="huanglifen" scheme="http://xgfe.github.io/categories/huanglifen/"/>
    
    
      <category term="html2canvas" scheme="http://xgfe.github.io/tags/html2canvas/"/>
    
      <category term="canvas2image" scheme="http://xgfe.github.io/tags/canvas2image/"/>
    
      <category term="html2image" scheme="http://xgfe.github.io/tags/html2image/"/>
    
  </entry>
  
</feed>
